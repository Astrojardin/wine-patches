diff --git a/configure b/configure
index 543ac3d..bc651bc 100755
--- a/configure
+++ b/configure
@@ -1024,6 +1024,7 @@ enable_dwmapi
 enable_dwrite
 enable_dxdiagn
 enable_dxgi
+enable_dxva2
 enable_explorerframe
 enable_ext_ms_win_gdi_devcaps_l1_1_0
 enable_faultrep
@@ -13694,6 +13695,31 @@ $as_echo "$ac_cv_cflags__Wunused_but_set_parameter" >&6; }
 if test "x$ac_cv_cflags__Wunused_but_set_parameter" = xyes; then :
   EXTRACFLAGS="$EXTRACFLAGS -Wunused-but-set-parameter"
 fi
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wvla" >&5
+$as_echo_n "checking whether the compiler supports -Wvla... " >&6; }
+if ${ac_cv_cflags__Wvla+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_wine_try_cflags_saved=$CFLAGS
+CFLAGS="$CFLAGS -Wvla"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+int main(int argc, char **argv) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_cflags__Wvla=yes
+else
+  ac_cv_cflags__Wvla=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wvla" >&5
+$as_echo "$ac_cv_cflags__Wvla" >&6; }
+if test "x$ac_cv_cflags__Wvla" = xyes; then :
+  EXTRACFLAGS="$EXTRACFLAGS -Wvla"
+fi
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wwrite-strings" >&5
 $as_echo_n "checking whether the compiler supports -Wwrite-strings... " >&6; }
 if ${ac_cv_cflags__Wwrite_strings+:} false; then :
@@ -16851,6 +16877,7 @@ wine_fn_config_lib dxerr9
 wine_fn_config_dll dxgi enable_dxgi implib
 wine_fn_config_test dlls/dxgi/tests dxgi_test
 wine_fn_config_lib dxguid
+wine_fn_config_dll dxva2 enable_dxva2
 wine_fn_config_dll explorerframe enable_explorerframe clean
 wine_fn_config_test dlls/explorerframe/tests explorerframe_test
 wine_fn_config_dll ext-ms-win-gdi-devcaps-l1-1-0 enable_ext_ms_win_gdi_devcaps_l1_1_0
@@ -17024,6 +17051,7 @@ wine_fn_config_dll nddeapi enable_nddeapi implib
 wine_fn_config_dll netapi32 enable_netapi32 implib
 wine_fn_config_test dlls/netapi32/tests netapi32_test
 wine_fn_config_dll netcfgx enable_netcfgx clean
+wine_fn_config_test dlls/netcfgx/tests netcfgx_test
 wine_fn_config_dll newdev enable_newdev implib
 wine_fn_config_dll normaliz enable_normaliz implib
 wine_fn_config_dll npmshtml enable_npmshtml
@@ -17328,7 +17356,7 @@ wine_fn_config_program regasm enable_regasm install
 wine_fn_config_program regedit enable_regedit install,installbin,manpage,po
 wine_fn_config_test programs/regedit/tests regedit.exe_test
 wine_fn_config_program regsvcs enable_regsvcs install
-wine_fn_config_program regsvr32 enable_regsvr32 install,installbin,manpage
+wine_fn_config_program regsvr32 enable_regsvr32 install,installbin,manpage,po
 wine_fn_config_program rpcss enable_rpcss clean,install
 wine_fn_config_program rundll.exe16 enable_win16 install
 wine_fn_config_program rundll32 enable_rundll32 install
diff --git a/configure.ac b/configure.ac
index 09c7e5a..d517184 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1780,6 +1780,7 @@ then
   WINE_TRY_CFLAGS([-Wstrict-prototypes])
   WINE_TRY_CFLAGS([-Wtype-limits])
   WINE_TRY_CFLAGS([-Wunused-but-set-parameter])
+  WINE_TRY_CFLAGS([-Wvla])
   WINE_TRY_CFLAGS([-Wwrite-strings])
 
   dnl Check for noisy string.h
@@ -2855,6 +2856,7 @@ WINE_CONFIG_LIB(dxerr9)
 WINE_CONFIG_DLL(dxgi,,[implib])
 WINE_CONFIG_TEST(dlls/dxgi/tests)
 WINE_CONFIG_LIB(dxguid)
+WINE_CONFIG_DLL(dxva2)
 WINE_CONFIG_DLL(explorerframe,,[clean])
 WINE_CONFIG_TEST(dlls/explorerframe/tests)
 WINE_CONFIG_DLL(ext-ms-win-gdi-devcaps-l1-1-0)
@@ -3028,6 +3030,7 @@ WINE_CONFIG_DLL(nddeapi,,[implib])
 WINE_CONFIG_DLL(netapi32,,[implib])
 WINE_CONFIG_TEST(dlls/netapi32/tests)
 WINE_CONFIG_DLL(netcfgx,,[clean])
+WINE_CONFIG_TEST(dlls/netcfgx/tests)
 WINE_CONFIG_DLL(newdev,,[implib])
 WINE_CONFIG_DLL(normaliz,,[implib])
 WINE_CONFIG_DLL(npmshtml)
@@ -3332,7 +3335,7 @@ WINE_CONFIG_PROGRAM(regasm,,[install])
 WINE_CONFIG_PROGRAM(regedit,,[install,installbin,manpage,po])
 WINE_CONFIG_TEST(programs/regedit/tests)
 WINE_CONFIG_PROGRAM(regsvcs,,[install])
-WINE_CONFIG_PROGRAM(regsvr32,,[install,installbin,manpage])
+WINE_CONFIG_PROGRAM(regsvr32,,[install,installbin,manpage,po])
 WINE_CONFIG_PROGRAM(rpcss,,[clean,install])
 WINE_CONFIG_PROGRAM(rundll.exe16,enable_win16,[install])
 WINE_CONFIG_PROGRAM(rundll32,,[install])
diff --git a/dlls/api-ms-win-core-synch-l1-2-0/api-ms-win-core-synch-l1-2-0.spec b/dlls/api-ms-win-core-synch-l1-2-0/api-ms-win-core-synch-l1-2-0.spec
index 43be0c8..d35fe78 100644
--- a/dlls/api-ms-win-core-synch-l1-2-0/api-ms-win-core-synch-l1-2-0.spec
+++ b/dlls/api-ms-win-core-synch-l1-2-0/api-ms-win-core-synch-l1-2-0.spec
@@ -39,7 +39,7 @@
 @ stdcall SetCriticalSectionSpinCount(ptr long) kernel32.SetCriticalSectionSpinCount
 @ stdcall SetEvent(long) kernel32.SetEvent
 @ stdcall SetWaitableTimer(long ptr long ptr ptr long) kernel32.SetWaitableTimer
-@ stub SetWaitableTimerEx
+@ stdcall SetWaitableTimerEx(long ptr long ptr ptr ptr long) kernel32.SetWaitableTimerEx
 @ stdcall SignalObjectAndWait(long long long long) kernel32.SignalObjectAndWait
 @ stdcall Sleep(long) kernel32.Sleep
 @ stdcall SleepConditionVariableCS(ptr ptr long) kernel32.SleepConditionVariableCS
diff --git a/dlls/comctl32/comctl32.spec b/dlls/comctl32/comctl32.spec
index ef638a4..0dff369 100644
--- a/dlls/comctl32/comctl32.spec
+++ b/dlls/comctl32/comctl32.spec
@@ -62,32 +62,32 @@
 341 stdcall -noname SendNotify(long long long ptr)
 342 stdcall -noname SendNotifyEx(long long long ptr long)
 345 stdcall -ordinal TaskDialogIndirect(ptr ptr ptr ptr)
-350 stdcall -noname StrChrA(str str)
-351 stdcall -noname StrRChrA(str str long)
-352 stdcall -noname StrCmpNA(str str long)
-353 stdcall -noname StrCmpNIA(str str long)
-354 stdcall -noname StrStrA(str str)
-355 stdcall -noname StrStrIA(str str)
-356 stdcall -noname StrCSpnA(str str)
-357 stdcall -noname StrToIntA(str)
-358 stdcall -noname StrChrW(wstr long)
-359 stdcall -noname StrRChrW(wstr wstr long)
-360 stdcall -noname StrCmpNW(wstr wstr long)
-361 stdcall -noname StrCmpNIW(wstr wstr long)
-362 stdcall -noname StrStrW(wstr wstr)
-363 stdcall -noname StrStrIW(wstr wstr)
-364 stdcall -noname StrCSpnW(wstr wstr)
-365 stdcall -noname StrToIntW(wstr)
-366 stdcall -noname StrChrIA(str long)
-367 stdcall -noname StrChrIW(wstr long)
-368 stdcall -noname StrRChrIA(str str long)
-369 stdcall -noname StrRChrIW(wstr wstr long)
-372 stdcall -noname StrRStrIA(str str str)
-373 stdcall -noname StrRStrIW(wstr wstr wstr)
-374 stdcall -noname StrCSpnIA(str str)
-375 stdcall -noname StrCSpnIW(wstr wstr)
-376 stdcall -noname IntlStrEqWorkerA(long str str long)
-377 stdcall -noname IntlStrEqWorkerW(long wstr wstr long)
+350 stdcall -noname -private StrChrA(str str)
+351 stdcall -noname -private StrRChrA(str str long)
+352 stdcall -noname -private StrCmpNA(str str long)
+353 stdcall -noname -private StrCmpNIA(str str long)
+354 stdcall -noname -private StrStrA(str str)
+355 stdcall -noname -private StrStrIA(str str)
+356 stdcall -noname -private StrCSpnA(str str)
+357 stdcall -noname -private StrToIntA(str)
+358 stdcall -noname -private StrChrW(wstr long)
+359 stdcall -noname -private StrRChrW(wstr wstr long)
+360 stdcall -noname -private StrCmpNW(wstr wstr long)
+361 stdcall -noname -private StrCmpNIW(wstr wstr long)
+362 stdcall -noname -private StrStrW(wstr wstr)
+363 stdcall -noname -private StrStrIW(wstr wstr)
+364 stdcall -noname -private StrCSpnW(wstr wstr)
+365 stdcall -noname -private StrToIntW(wstr)
+366 stdcall -noname -private StrChrIA(str long)
+367 stdcall -noname -private StrChrIW(wstr long)
+368 stdcall -noname -private StrRChrIA(str str long)
+369 stdcall -noname -private StrRChrIW(wstr wstr long)
+372 stdcall -noname -private StrRStrIA(str str str)
+373 stdcall -noname -private StrRStrIW(wstr wstr wstr)
+374 stdcall -noname -private StrCSpnIA(str str)
+375 stdcall -noname -private StrCSpnIW(wstr wstr)
+376 stdcall -noname -private IntlStrEqWorkerA(long str str long)
+377 stdcall -noname -private IntlStrEqWorkerW(long wstr wstr long)
 382 stdcall -noname SmoothScrollWindow(ptr)
 383 stub -noname DoReaderMode
 384 stdcall -noname SetPathWordBreakProc(ptr long)
diff --git a/dlls/comctl32/dpa.c b/dlls/comctl32/dpa.c
index 41fb799..148d3f1 100644
--- a/dlls/comctl32/dpa.c
+++ b/dlls/comctl32/dpa.c
@@ -129,8 +129,10 @@ HRESULT WINAPI DPA_LoadStream (HDPA *phDpa, PFNDPASTREAM loadProc,
     if (!hDpa)
         return E_OUTOFMEMORY;
 
-    if (!DPA_Grow (hDpa, streamData.dwItems))
+    if (!DPA_Grow (hDpa, streamData.dwItems)) {
+        DPA_Destroy (hDpa);
         return E_OUTOFMEMORY;
+    }
 
     /* load data from the stream into the dpa */
     ptr = hDpa->ptrs;
diff --git a/dlls/comctl32/tests/header.c b/dlls/comctl32/tests/header.c
index d6e5a01..2c1320b 100644
--- a/dlls/comctl32/tests/header.c
+++ b/dlls/comctl32/tests/header.c
@@ -442,6 +442,7 @@ static LRESULT WINAPI parent_wnd_proc(HWND hwnd, UINT message, WPARAM wParam, LP
         if (defwndproc_counter) msg.flags |= defwinproc;
         msg.wParam = wParam;
         msg.lParam = lParam;
+        msg.id = 0;
         add_message(sequences, PARENT_SEQ_INDEX, &msg);
    }
 
diff --git a/dlls/d3d8/tests/visual.c b/dlls/d3d8/tests/visual.c
index 616dd41..9c1a748 100644
--- a/dlls/d3d8/tests/visual.c
+++ b/dlls/d3d8/tests/visual.c
@@ -4624,7 +4624,7 @@ static void add_dirty_rect_test(IDirect3DDevice8 *device)
     fill_surface(surface_managed, 0x0000ff00, D3DLOCK_NO_DIRTY_UPDATE);
     add_dirty_rect_test_draw(device);
     color = getPixelColor(device, 320, 240);
-    ok(color_match(color, 0x00ff0000, 1),
+    todo_wine ok(color_match(color, 0x00ff0000, 1),
             "Expected color 0x00ff0000, got 0x%08x.\n", color);
     hr = IDirect3DDevice8_Present(device, NULL, NULL, NULL, NULL);
     ok(SUCCEEDED(hr), "Failed to present, hr %#x.\n", hr);
diff --git a/dlls/d3d9/buffer.c b/dlls/d3d9/buffer.c
index d543b27..cc93b18 100644
--- a/dlls/d3d9/buffer.c
+++ b/dlls/d3d9/buffer.c
@@ -50,7 +50,7 @@ static HRESULT WINAPI d3d9_vertexbuffer_QueryInterface(IDirect3DVertexBuffer9 *i
 static ULONG WINAPI d3d9_vertexbuffer_AddRef(IDirect3DVertexBuffer9 *iface)
 {
     struct d3d9_vertexbuffer *buffer = impl_from_IDirect3DVertexBuffer9(iface);
-    ULONG refcount = InterlockedIncrement(&buffer->refcount);
+    ULONG refcount = InterlockedIncrement(&buffer->resource.refcount);
 
     TRACE("%p increasing refcount to %u.\n", iface, refcount);
 
@@ -68,7 +68,7 @@ static ULONG WINAPI d3d9_vertexbuffer_AddRef(IDirect3DVertexBuffer9 *iface)
 static ULONG WINAPI d3d9_vertexbuffer_Release(IDirect3DVertexBuffer9 *iface)
 {
     struct d3d9_vertexbuffer *buffer = impl_from_IDirect3DVertexBuffer9(iface);
-    ULONG refcount = InterlockedDecrement(&buffer->refcount);
+    ULONG refcount = InterlockedDecrement(&buffer->resource.refcount);
 
     TRACE("%p decreasing refcount to %u.\n", iface, refcount);
 
@@ -105,52 +105,28 @@ static HRESULT WINAPI d3d9_vertexbuffer_SetPrivateData(IDirect3DVertexBuffer9 *i
         REFGUID guid, const void *data, DWORD data_size, DWORD flags)
 {
     struct d3d9_vertexbuffer *buffer = impl_from_IDirect3DVertexBuffer9(iface);
-    struct wined3d_resource *resource;
-    HRESULT hr;
-
     TRACE("iface %p, guid %s, data %p, data_size %u, flags %#x.\n",
             iface, debugstr_guid(guid), data, data_size, flags);
 
-    wined3d_mutex_lock();
-    resource = wined3d_buffer_get_resource(buffer->wined3d_buffer);
-    hr = wined3d_resource_set_private_data(resource, guid, data, data_size, flags);
-    wined3d_mutex_unlock();
-
-    return hr;
+    return d3d9_resource_set_private_data(&buffer->resource, guid, data, data_size, flags);
 }
 
 static HRESULT WINAPI d3d9_vertexbuffer_GetPrivateData(IDirect3DVertexBuffer9 *iface,
         REFGUID guid, void *data, DWORD *data_size)
 {
     struct d3d9_vertexbuffer *buffer = impl_from_IDirect3DVertexBuffer9(iface);
-    struct wined3d_resource *resource;
-    HRESULT hr;
-
     TRACE("iface %p, guid %s, data %p, data_size %p.\n",
             iface, debugstr_guid(guid), data, data_size);
 
-    wined3d_mutex_lock();
-    resource = wined3d_buffer_get_resource(buffer->wined3d_buffer);
-    hr = wined3d_resource_get_private_data(resource, guid, data, data_size);
-    wined3d_mutex_unlock();
-
-    return hr;
+    return d3d9_resource_get_private_data(&buffer->resource, guid, data, data_size);
 }
 
 static HRESULT WINAPI d3d9_vertexbuffer_FreePrivateData(IDirect3DVertexBuffer9 *iface, REFGUID guid)
 {
     struct d3d9_vertexbuffer *buffer = impl_from_IDirect3DVertexBuffer9(iface);
-    struct wined3d_resource *resource;
-    HRESULT hr;
-
     TRACE("iface %p, guid %s.\n", iface, debugstr_guid(guid));
 
-    wined3d_mutex_lock();
-    resource = wined3d_buffer_get_resource(buffer->wined3d_buffer);
-    hr = wined3d_resource_free_private_data(resource, guid);
-    wined3d_mutex_unlock();
-
-    return hr;
+    return d3d9_resource_free_private_data(&buffer->resource, guid);
 }
 
 static DWORD WINAPI d3d9_vertexbuffer_SetPriority(IDirect3DVertexBuffer9 *iface, DWORD priority)
@@ -275,7 +251,9 @@ static const IDirect3DVertexBuffer9Vtbl d3d9_vertexbuffer_vtbl =
 
 static void STDMETHODCALLTYPE d3d9_vertexbuffer_wined3d_object_destroyed(void *parent)
 {
-    HeapFree(GetProcessHeap(), 0, parent);
+    struct d3d9_vertexbuffer *buffer = parent;
+    d3d9_resource_cleanup(&buffer->resource);
+    HeapFree(GetProcessHeap(), 0, buffer);
 }
 
 static const struct wined3d_parent_ops d3d9_vertexbuffer_wined3d_parent_ops =
@@ -289,8 +267,8 @@ HRESULT vertexbuffer_init(struct d3d9_vertexbuffer *buffer, struct d3d9_device *
     HRESULT hr;
 
     buffer->IDirect3DVertexBuffer9_iface.lpVtbl = &d3d9_vertexbuffer_vtbl;
-    buffer->refcount = 1;
     buffer->fvf = fvf;
+    d3d9_resource_init(&buffer->resource);
 
     wined3d_mutex_lock();
     hr = wined3d_buffer_create_vb(device->wined3d_device, size, usage & WINED3DUSAGE_MASK,
@@ -344,7 +322,7 @@ static HRESULT WINAPI d3d9_indexbuffer_QueryInterface(IDirect3DIndexBuffer9 *ifa
 static ULONG WINAPI d3d9_indexbuffer_AddRef(IDirect3DIndexBuffer9 *iface)
 {
     struct d3d9_indexbuffer *buffer = impl_from_IDirect3DIndexBuffer9(iface);
-    ULONG refcount = InterlockedIncrement(&buffer->refcount);
+    ULONG refcount = InterlockedIncrement(&buffer->resource.refcount);
 
     TRACE("%p increasing refcount to %u.\n", iface, refcount);
 
@@ -362,7 +340,7 @@ static ULONG WINAPI d3d9_indexbuffer_AddRef(IDirect3DIndexBuffer9 *iface)
 static ULONG WINAPI d3d9_indexbuffer_Release(IDirect3DIndexBuffer9 *iface)
 {
     struct d3d9_indexbuffer *buffer = impl_from_IDirect3DIndexBuffer9(iface);
-    ULONG refcount = InterlockedDecrement(&buffer->refcount);
+    ULONG refcount = InterlockedDecrement(&buffer->resource.refcount);
 
     TRACE("%p decreasing refcount to %u.\n", iface, refcount);
 
@@ -399,52 +377,28 @@ static HRESULT WINAPI d3d9_indexbuffer_SetPrivateData(IDirect3DIndexBuffer9 *ifa
         REFGUID guid, const void *data, DWORD data_size, DWORD flags)
 {
     struct d3d9_indexbuffer *buffer = impl_from_IDirect3DIndexBuffer9(iface);
-    struct wined3d_resource *resource;
-    HRESULT hr;
-
     TRACE("iface %p, guid %s, data %p, data_size %u, flags %#x.\n",
             iface, debugstr_guid(guid), data, data_size, flags);
 
-    wined3d_mutex_lock();
-    resource = wined3d_buffer_get_resource(buffer->wined3d_buffer);
-    hr = wined3d_resource_set_private_data(resource, guid, data, data_size, flags);
-    wined3d_mutex_unlock();
-
-    return hr;
+    return d3d9_resource_set_private_data(&buffer->resource, guid, data, data_size, flags);
 }
 
 static HRESULT WINAPI d3d9_indexbuffer_GetPrivateData(IDirect3DIndexBuffer9 *iface,
         REFGUID guid, void *data, DWORD *data_size)
 {
     struct d3d9_indexbuffer *buffer = impl_from_IDirect3DIndexBuffer9(iface);
-    struct wined3d_resource *resource;
-    HRESULT hr;
-
     TRACE("iface %p, guid %s, data %p, data_size %p.\n",
             iface, debugstr_guid(guid), data, data_size);
 
-    wined3d_mutex_lock();
-    resource = wined3d_buffer_get_resource(buffer->wined3d_buffer);
-    hr = wined3d_resource_get_private_data(resource, guid, data, data_size);
-    wined3d_mutex_unlock();
-
-    return hr;
+    return d3d9_resource_get_private_data(&buffer->resource, guid, data, data_size);
 }
 
 static HRESULT WINAPI d3d9_indexbuffer_FreePrivateData(IDirect3DIndexBuffer9 *iface, REFGUID guid)
 {
     struct d3d9_indexbuffer *buffer = impl_from_IDirect3DIndexBuffer9(iface);
-    struct wined3d_resource *resource;
-    HRESULT hr;
-
     TRACE("iface %p, guid %s.\n", iface, debugstr_guid(guid));
 
-    wined3d_mutex_lock();
-    resource = wined3d_buffer_get_resource(buffer->wined3d_buffer);
-    hr = wined3d_resource_free_private_data(resource, guid);
-    wined3d_mutex_unlock();
-
-    return hr;
+    return d3d9_resource_free_private_data(&buffer->resource, guid);
 }
 
 static DWORD WINAPI d3d9_indexbuffer_SetPriority(IDirect3DIndexBuffer9 *iface, DWORD priority)
@@ -567,7 +521,9 @@ static const IDirect3DIndexBuffer9Vtbl d3d9_indexbuffer_vtbl =
 
 static void STDMETHODCALLTYPE d3d9_indexbuffer_wined3d_object_destroyed(void *parent)
 {
-    HeapFree(GetProcessHeap(), 0, parent);
+    struct d3d9_indexbuffer *buffer = parent;
+    d3d9_resource_cleanup(&buffer->resource);
+    HeapFree(GetProcessHeap(), 0, buffer);
 }
 
 static const struct wined3d_parent_ops d3d9_indexbuffer_wined3d_parent_ops =
@@ -581,8 +537,8 @@ HRESULT indexbuffer_init(struct d3d9_indexbuffer *buffer, struct d3d9_device *de
     HRESULT hr;
 
     buffer->IDirect3DIndexBuffer9_iface.lpVtbl = &d3d9_indexbuffer_vtbl;
-    buffer->refcount = 1;
     buffer->format = wined3dformat_from_d3dformat(format);
+    d3d9_resource_init(&buffer->resource);
 
     wined3d_mutex_lock();
     hr = wined3d_buffer_create_ib(device->wined3d_device, size, usage & WINED3DUSAGE_MASK,
diff --git a/dlls/d3d9/d3d9_main.c b/dlls/d3d9/d3d9_main.c
index d8c5e23..8796733 100644
--- a/dlls/d3d9/d3d9_main.c
+++ b/dlls/d3d9/d3d9_main.c
@@ -162,3 +162,81 @@ void WINAPI D3DPERF_SetRegion(D3DCOLOR color, const WCHAR *name)
 {
     FIXME("color 0x%08x, name %s stub!\n", color, debugstr_w(name));
 }
+
+void d3d9_resource_cleanup(struct d3d9_resource *resource)
+{
+    wined3d_private_store_cleanup(&resource->private_store);
+}
+
+HRESULT d3d9_resource_free_private_data(struct d3d9_resource *resource, const GUID *guid)
+{
+    struct wined3d_private_data *entry;
+
+    wined3d_mutex_lock();
+    entry = wined3d_private_store_get_private_data(&resource->private_store, guid);
+    if (!entry)
+    {
+        wined3d_mutex_unlock();
+        return D3DERR_NOTFOUND;
+    }
+
+    wined3d_private_store_free_private_data(&resource->private_store, entry);
+    wined3d_mutex_unlock();
+
+    return D3D_OK;
+}
+
+HRESULT d3d9_resource_get_private_data(struct d3d9_resource *resource, const GUID *guid,
+        void *data, DWORD *data_size)
+{
+    const struct wined3d_private_data *stored_data;
+    DWORD size_in;
+    HRESULT hr;
+
+    wined3d_mutex_lock();
+    stored_data = wined3d_private_store_get_private_data(&resource->private_store, guid);
+    if (!stored_data)
+    {
+        hr = D3DERR_NOTFOUND;
+        goto done;
+    }
+
+    size_in = *data_size;
+    *data_size = stored_data->size;
+    if (!data)
+    {
+        hr = D3D_OK;
+        goto done;
+    }
+    if (size_in < stored_data->size)
+    {
+        hr = D3DERR_MOREDATA;
+        goto done;
+    }
+
+    if (stored_data->flags & WINED3DSPD_IUNKNOWN)
+        IUnknown_AddRef(stored_data->content.object);
+    memcpy(data, stored_data->content.data, stored_data->size);
+    hr = D3D_OK;
+
+done:
+    wined3d_mutex_unlock();
+    return hr;
+}
+
+void d3d9_resource_init(struct d3d9_resource *resource)
+{
+    resource->refcount = 1;
+    wined3d_private_store_init(&resource->private_store);
+}
+
+HRESULT d3d9_resource_set_private_data(struct d3d9_resource *resource, const GUID *guid,
+        const void *data, DWORD data_size, DWORD flags)
+{
+    HRESULT hr;
+
+    wined3d_mutex_lock();
+    hr = wined3d_private_store_set_private_data(&resource->private_store, guid, data, data_size, flags);
+    wined3d_mutex_unlock();
+    return hr;
+}
diff --git a/dlls/d3d9/d3d9_private.h b/dlls/d3d9/d3d9_private.h
index 5172a78..8d75f62 100644
--- a/dlls/d3d9/d3d9_private.h
+++ b/dlls/d3d9/d3d9_private.h
@@ -166,10 +166,24 @@ HRESULT device_init(struct d3d9_device *device, struct d3d9 *parent, struct wine
         UINT adapter, D3DDEVTYPE device_type, HWND focus_window, DWORD flags,
         D3DPRESENT_PARAMETERS *parameters, D3DDISPLAYMODEEX *mode) DECLSPEC_HIDDEN;
 
+struct d3d9_resource
+{
+    LONG refcount;
+    struct wined3d_private_store private_store;
+};
+
+void d3d9_resource_cleanup(struct d3d9_resource *resource) DECLSPEC_HIDDEN;
+HRESULT d3d9_resource_free_private_data(struct d3d9_resource *resource, const GUID *guid) DECLSPEC_HIDDEN;
+HRESULT d3d9_resource_get_private_data(struct d3d9_resource *resource, const GUID *guid,
+        void *data, DWORD *data_size) DECLSPEC_HIDDEN;
+void d3d9_resource_init(struct d3d9_resource *resource) DECLSPEC_HIDDEN;
+HRESULT d3d9_resource_set_private_data(struct d3d9_resource *resource, const GUID *guid,
+        const void *data, DWORD data_size, DWORD flags) DECLSPEC_HIDDEN;
+
 struct d3d9_volume
 {
     IDirect3DVolume9 IDirect3DVolume9_iface;
-    LONG refcount;
+    struct d3d9_resource resource;
     struct wined3d_volume *wined3d_volume;
     IUnknown *container;
     IUnknown *forwardReference;
@@ -192,7 +206,7 @@ HRESULT d3d9_swapchain_create(struct d3d9_device *device, struct wined3d_swapcha
 struct d3d9_surface
 {
     IDirect3DSurface9 IDirect3DSurface9_iface;
-    LONG refcount;
+    struct d3d9_resource resource;
     struct wined3d_surface *wined3d_surface;
     IDirect3DDevice9Ex *parent_device;
     IUnknown *container;
@@ -207,7 +221,7 @@ struct d3d9_surface *unsafe_impl_from_IDirect3DSurface9(IDirect3DSurface9 *iface
 struct d3d9_vertexbuffer
 {
     IDirect3DVertexBuffer9 IDirect3DVertexBuffer9_iface;
-    LONG refcount;
+    struct d3d9_resource resource;
     struct wined3d_buffer *wined3d_buffer;
     IDirect3DDevice9Ex *parent_device;
     DWORD fvf;
@@ -220,7 +234,7 @@ struct d3d9_vertexbuffer *unsafe_impl_from_IDirect3DVertexBuffer9(IDirect3DVerte
 struct d3d9_indexbuffer
 {
     IDirect3DIndexBuffer9 IDirect3DIndexBuffer9_iface;
-    LONG refcount;
+    struct d3d9_resource resource;
     struct wined3d_buffer *wined3d_buffer;
     IDirect3DDevice9Ex *parent_device;
     enum wined3d_format_id format;
@@ -233,7 +247,7 @@ struct d3d9_indexbuffer *unsafe_impl_from_IDirect3DIndexBuffer9(IDirect3DIndexBu
 struct d3d9_texture
 {
     IDirect3DBaseTexture9 IDirect3DBaseTexture9_iface;
-    LONG refcount;
+    struct d3d9_resource resource;
     struct wined3d_texture *wined3d_texture;
     IDirect3DDevice9Ex *parent_device;
 };
diff --git a/dlls/d3d9/device.c b/dlls/d3d9/device.c
index 66bee95..263ac12 100644
--- a/dlls/d3d9/device.c
+++ b/dlls/d3d9/device.c
@@ -581,7 +581,7 @@ static HRESULT CDECL reset_enum_callback(struct wined3d_resource *resource)
         }
 
         surface = wined3d_resource_get_parent(resource);
-        if (surface->refcount)
+        if (surface->resource.refcount)
         {
             WARN("Surface %p (resource %p) in pool D3DPOOL_DEFAULT blocks the Reset call.\n", surface, resource);
             return D3DERR_INVALIDCALL;
diff --git a/dlls/d3d9/surface.c b/dlls/d3d9/surface.c
index 0c96d50..bf8b41a 100644
--- a/dlls/d3d9/surface.c
+++ b/dlls/d3d9/surface.c
@@ -61,7 +61,7 @@ static ULONG WINAPI d3d9_surface_AddRef(IDirect3DSurface9 *iface)
         return IUnknown_AddRef(surface->forwardReference);
     }
 
-    refcount = InterlockedIncrement(&surface->refcount);
+    refcount = InterlockedIncrement(&surface->resource.refcount);
     TRACE("%p increasing refcount to %u.\n", iface, refcount);
 
     if (refcount == 1)
@@ -89,7 +89,7 @@ static ULONG WINAPI d3d9_surface_Release(IDirect3DSurface9 *iface)
         return IUnknown_Release(surface->forwardReference);
     }
 
-    refcount = InterlockedDecrement(&surface->refcount);
+    refcount = InterlockedDecrement(&surface->resource.refcount);
     TRACE("%p decreasing refcount to %u.\n", iface, refcount);
 
     if (!refcount)
@@ -143,52 +143,28 @@ static HRESULT WINAPI d3d9_surface_SetPrivateData(IDirect3DSurface9 *iface, REFG
         const void *data, DWORD data_size, DWORD flags)
 {
     struct d3d9_surface *surface = impl_from_IDirect3DSurface9(iface);
-    struct wined3d_resource *resource;
-    HRESULT hr;
-
     TRACE("iface %p, guid %s, data %p, data_size %u, flags %#x.\n",
             iface, debugstr_guid(guid), data, data_size, flags);
 
-    wined3d_mutex_lock();
-    resource = wined3d_surface_get_resource(surface->wined3d_surface);
-    hr = wined3d_resource_set_private_data(resource, guid, data, data_size, flags);
-    wined3d_mutex_unlock();
-
-    return hr;
+    return d3d9_resource_set_private_data(&surface->resource, guid, data, data_size, flags);
 }
 
 static HRESULT WINAPI d3d9_surface_GetPrivateData(IDirect3DSurface9 *iface, REFGUID guid,
         void *data, DWORD *data_size)
 {
     struct d3d9_surface *surface = impl_from_IDirect3DSurface9(iface);
-    struct wined3d_resource *resource;
-    HRESULT hr;
-
     TRACE("iface %p, guid %s, data %p, data_size %p.\n",
             iface, debugstr_guid(guid), data, data_size);
 
-    wined3d_mutex_lock();
-    resource = wined3d_surface_get_resource(surface->wined3d_surface);
-    hr = wined3d_resource_get_private_data(resource, guid, data, data_size);
-    wined3d_mutex_unlock();
-
-    return hr;
+    return d3d9_resource_get_private_data(&surface->resource, guid, data, data_size);
 }
 
 static HRESULT WINAPI d3d9_surface_FreePrivateData(IDirect3DSurface9 *iface, REFGUID guid)
 {
     struct d3d9_surface *surface = impl_from_IDirect3DSurface9(iface);
-    struct wined3d_resource *resource;
-    HRESULT hr;
-
     TRACE("iface %p, guid %s.\n", iface, debugstr_guid(guid));
 
-    wined3d_mutex_lock();
-    resource = wined3d_surface_get_resource(surface->wined3d_surface);
-    hr = wined3d_resource_free_private_data(resource, guid);
-    wined3d_mutex_unlock();
-
-    return hr;
+    return d3d9_resource_free_private_data(&surface->resource, guid);
 }
 
 static DWORD WINAPI d3d9_surface_SetPriority(IDirect3DSurface9 *iface, DWORD priority)
@@ -385,7 +361,9 @@ static const struct IDirect3DSurface9Vtbl d3d9_surface_vtbl =
 
 static void STDMETHODCALLTYPE surface_wined3d_object_destroyed(void *parent)
 {
-    HeapFree(GetProcessHeap(), 0, parent);
+    struct d3d9_surface *surface = parent;
+    d3d9_resource_cleanup(&surface->resource);
+    HeapFree(GetProcessHeap(), 0, surface);
 }
 
 static const struct wined3d_parent_ops d3d9_surface_wined3d_parent_ops =
@@ -399,7 +377,7 @@ void surface_init(struct d3d9_surface *surface, struct wined3d_surface *wined3d_
     struct wined3d_resource_desc desc;
 
     surface->IDirect3DSurface9_iface.lpVtbl = &d3d9_surface_vtbl;
-    surface->refcount = 1;
+    d3d9_resource_init(&surface->resource);
 
     wined3d_resource_get_desc(wined3d_surface_get_resource(wined3d_surface), &desc);
     switch (d3dformat_from_wined3dformat(desc.format))
diff --git a/dlls/d3d9/tests/visual.c b/dlls/d3d9/tests/visual.c
index 9d3d201..c528679 100644
--- a/dlls/d3d9/tests/visual.c
+++ b/dlls/d3d9/tests/visual.c
@@ -1746,17 +1746,25 @@ out:
  *                linear table fog with non foggy vertex shader
  *                vertex fog with foggy vertex shader, non-linear
  *                fog with shader, non-linear fog with foggy shader,
- *                linear table fog with foggy shader
- */
-static void fog_with_shader_test(IDirect3DDevice9 *device)
+ *                linear table fog with foggy shader */
+static void fog_with_shader_test(void)
 {
-    HRESULT hr;
+    IDirect3DVertexShader9 *vertex_shader[4] = {NULL, NULL, NULL, NULL};
+    IDirect3DPixelShader9 *pixel_shader[3] = {NULL, NULL, NULL};
+    IDirect3DVertexDeclaration9 *vertex_declaration = NULL;
+    IDirect3DDevice9 *device;
+    unsigned int i, j;
+    IDirect3D9 *d3d;
+    ULONG refcount;
+    D3DCAPS9 caps;
     DWORD color;
-    union {
+    HWND window;
+    HRESULT hr;
+    union
+    {
         float f;
         DWORD i;
     } start, end;
-    unsigned int i, j;
 
     /* basic vertex shader without fog computation ("non foggy") */
     static const DWORD vertex_shader_code1[] =
@@ -1808,32 +1816,31 @@ static void fog_with_shader_test(IDirect3DDevice9 *device)
         0x02000001, 0x800f0800, 0x90e40000,                                     /* mov oC0, v0 */
         0x0000ffff
     };
-
-    static struct vertex quad[] = {
+    static struct vertex quad[] =
+    {
         {-1.0f, -1.0f,  0.0f,          0xffff0000  },
         {-1.0f,  1.0f,  0.0f,          0xffff0000  },
         { 1.0f, -1.0f,  0.0f,          0xffff0000  },
         { 1.0f,  1.0f,  0.0f,          0xffff0000  },
     };
-
-    static const D3DVERTEXELEMENT9 decl_elements[] = {
+    static const D3DVERTEXELEMENT9 decl_elements[] =
+    {
         {0,  0, D3DDECLTYPE_FLOAT3,   D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_POSITION, 0},
         {0, 12, D3DDECLTYPE_D3DCOLOR, D3DDECLMETHOD_DEFAULT,    D3DDECLUSAGE_COLOR, 0},
         D3DDECL_END()
     };
-
-    IDirect3DVertexDeclaration9 *vertex_declaration = NULL;
-    IDirect3DVertexShader9      *vertex_shader[4]   = {NULL, NULL, NULL, NULL};
-    IDirect3DPixelShader9       *pixel_shader[3]    = {NULL, NULL, NULL};
-
-    /* This reference data was collected on a nVidia GeForce 7600GS driver version 84.19 DirectX version 9.0c on Windows XP */
-    static const struct test_data_t {
+    /* This reference data was collected on a nVidia GeForce 7600GS driver
+     * version 84.19 DirectX version 9.0c on Windows XP. */
+    static const struct test_data_t
+    {
         int vshader;
         int pshader;
         D3DFOGMODE vfog;
         D3DFOGMODE tfog;
         unsigned int color[11];
-    } test_data[] = {
+    }
+    test_data[] =
+    {
         /* only pixel shader: */
         {0, 1, D3DFOG_NONE, D3DFOG_LINEAR,
         {0x00ff0000, 0x00ff0000, 0x00df2000, 0x00bf4000, 0x009f6000, 0x007f8000,
@@ -2010,10 +2017,43 @@ static void fog_with_shader_test(IDirect3DDevice9 *device)
         {0x00ff0000, 0x00ff0000, 0x00df2000, 0x00bf4000, 0x009f6000, 0x007f8000,
         0x005fa000, 0x0040bf00, 0x0020df00, 0x0000ff00, 0x0000ff00}},
     };
+    static const D3DMATRIX identity =
+    {{{
+        1.0f, 0.0f, 0.0f, 0.0f,
+        0.0f, 1.0f, 0.0f, 0.0f,
+        0.0f, 0.0f, 1.0f, 0.0f,
+        0.0f, 0.0f, 0.0f, 1.0f,
+    }}};
+
+    window = CreateWindowA("static", "d3d9_test", WS_OVERLAPPEDWINDOW | WS_VISIBLE,
+            0, 0, 640, 480, NULL, NULL, NULL, NULL);
+    d3d = Direct3DCreate9(D3D_SDK_VERSION);
+    ok(!!d3d, "Failed to create a D3D object.\n");
+    if (!(device = create_device(d3d, window, window, TRUE)))
+    {
+        skip("Failed to create a D3D device, skipping tests.\n");
+        goto done;
+    }
+
+    hr = IDirect3DDevice9_GetDeviceCaps(device, &caps);
+    ok(SUCCEEDED(hr), "Failed to get device caps, hr %#x.\n", hr);
+    if (caps.VertexShaderVersion < D3DVS_VERSION(2, 0) || caps.PixelShaderVersion < D3DPS_VERSION(2, 0))
+    {
+        skip("No shader model 2 support, skipping tests.\n");
+        IDirect3DDevice9_Release(device);
+        goto done;
+    }
+
+    /* NOTE: Changing these values will not affect the tests with foggy vertex
+     * shader, as the values are hardcoded in the shader. */
+    start.f = 0.1f;
+    end.f = 0.9f;
 
-    /* NOTE: changing these values will not affect the tests with foggy vertex shader, as the values are hardcoded in the shader*/
-    start.f=0.1f;
-    end.f=0.9f;
+    /* Some of the tests seem to depend on the projection matrix explicitly
+     * being set to an identity matrix, even though that's the default.
+     * (AMD Radeon HD 6310, Windows 7) */
+    hr = IDirect3DDevice9_SetTransform(device, D3DTS_PROJECTION, &identity);
+    ok(SUCCEEDED(hr), "Failed to set projection transform, hr %#x.\n", hr);
 
     hr = IDirect3DDevice9_CreateVertexShader(device, vertex_shader_code1, &vertex_shader[1]);
     ok(SUCCEEDED(hr), "CreateVertexShader failed (%08x)\n", hr);
@@ -2068,7 +2108,7 @@ static void fog_with_shader_test(IDirect3DDevice9 *device)
             quad[2].z = 0.001f + (float)j / 10.02f;
             quad[3].z = 0.001f + (float)j / 10.02f;
 
-            hr = IDirect3DDevice9_Clear(device, 0, NULL, D3DCLEAR_TARGET, 0xffff00ff, 0.0, 0);
+            hr = IDirect3DDevice9_Clear(device, 0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0xffff00ff, 1.0f, 0);
             ok(hr == D3D_OK, "IDirect3DDevice9_Clear failed (%08x)\n", hr);
 
             hr = IDirect3DDevice9_BeginScene(device);
@@ -2090,22 +2130,17 @@ static void fog_with_shader_test(IDirect3DDevice9 *device)
         }
     }
 
-    /* reset states */
-    hr = IDirect3DDevice9_SetVertexShader(device, NULL);
-    ok(SUCCEEDED(hr), "SetVertexShader failed (%08x)\n", hr);
-    hr = IDirect3DDevice9_SetPixelShader(device, NULL);
-    ok(SUCCEEDED(hr), "SetPixelShader failed (%08x)\n", hr);
-    hr = IDirect3DDevice9_SetVertexDeclaration(device, NULL);
-    ok(SUCCEEDED(hr), "SetVertexDeclaration failed (%08x)\n", hr);
-    hr = IDirect3DDevice9_SetRenderState(device, D3DRS_FOGENABLE, FALSE);
-    ok(hr == D3D_OK, "Turning off fog calculations failed (%08x)\n", hr);
-
     IDirect3DVertexShader9_Release(vertex_shader[1]);
     IDirect3DVertexShader9_Release(vertex_shader[2]);
     IDirect3DVertexShader9_Release(vertex_shader[3]);
     IDirect3DPixelShader9_Release(pixel_shader[1]);
     IDirect3DPixelShader9_Release(pixel_shader[2]);
     IDirect3DVertexDeclaration9_Release(vertex_declaration);
+    refcount = IDirect3DDevice9_Release(device);
+    ok(!refcount, "Device has %u references left.\n", refcount);
+done:
+    IDirect3D9_Release(d3d);
+    DestroyWindow(window);
 }
 
 static void generate_bumpmap_textures(IDirect3DDevice9 *device) {
@@ -2179,23 +2214,36 @@ static void generate_bumpmap_textures(IDirect3DDevice9 *device) {
     }
 }
 
-/* test the behavior of the texbem instruction
- * with normal 2D and projective 2D textures
- */
-static void texbem_test(IDirect3DDevice9 *device)
+/* Test the behavior of the texbem instruction with normal 2D and projective
+ * 2D textures. */
+static void texbem_test(void)
 {
-    HRESULT hr;
+    IDirect3DVertexDeclaration9 *vertex_declaration = NULL;
+    /* Use asymmetric matrix to test loading. */
+    float bumpenvmat[4] = {0.0f, 0.5f, -0.5f, 0.0f};
+    IDirect3DPixelShader9 *pixel_shader = NULL;
+    IDirect3DTexture9 *texture1, *texture2;
+    IDirect3DTexture9 *texture = NULL;
+    D3DLOCKED_RECT locked_rect;
+    IDirect3DDevice9 *device;
+    IDirect3D9 *d3d;
+    ULONG refcount;
+    D3DCAPS9 caps;
     DWORD color;
+    HWND window;
+    HRESULT hr;
     int i;
 
-    static const DWORD pixel_shader_code[] = {
+    static const DWORD pixel_shader_code[] =
+    {
         0xffff0101,                         /* ps_1_1*/
         0x00000042, 0xb00f0000,             /* tex t0*/
         0x00000043, 0xb00f0001, 0xb0e40000, /* texbem t1, t0*/
         0x00000001, 0x800f0000, 0xb0e40001, /* mov r0, t1*/
         0x0000ffff
     };
-    static const DWORD double_texbem_code[] =  {
+    static const DWORD double_texbem_code[] =
+    {
         0xffff0103,                                         /* ps_1_3           */
         0x00000042, 0xb00f0000,                             /* tex t0           */
         0x00000043, 0xb00f0001, 0xb0e40000,                 /* texbem t1, t0    */
@@ -2204,40 +2252,61 @@ static void texbem_test(IDirect3DDevice9 *device)
         0x00000002, 0x800f0000, 0xb0e40001, 0xb0e40003,     /* add r0, t1, t3   */
         0x0000ffff                                          /* end              */
     };
-
-
-    static const float quad[][7] = {
+    static const float quad[][7] =
+    {
         {-128.0f/640.0f, -128.0f/480.0f, 0.1f, 0.0f, 0.0f, 0.0f, 0.0f},
         {-128.0f/640.0f,  128.0f/480.0f, 0.1f, 0.0f, 1.0f, 0.0f, 1.0f},
         { 128.0f/640.0f, -128.0f/480.0f, 0.1f, 1.0f, 0.0f, 1.0f, 0.0f},
         { 128.0f/640.0f,  128.0f/480.0f, 0.1f, 1.0f, 1.0f, 1.0f, 1.0f},
     };
-    static const float quad_proj[][9] = {
+    static const float quad_proj[][9] =
+    {
         {-128.0f/640.0f, -128.0f/480.0f, 0.1f, 0.0f, 0.0f,   0.0f,   0.0f, 0.0f, 128.0f},
         {-128.0f/640.0f,  128.0f/480.0f, 0.1f, 0.0f, 1.0f,   0.0f, 128.0f, 0.0f, 128.0f},
         { 128.0f/640.0f, -128.0f/480.0f, 0.1f, 1.0f, 0.0f, 128.0f,   0.0f, 0.0f, 128.0f},
         { 128.0f/640.0f,  128.0f/480.0f, 0.1f, 1.0f, 1.0f, 128.0f, 128.0f, 0.0f, 128.0f},
     };
+    static const float double_quad[] =
+    {
+        -1.0f, -1.0f, 0.0f, 0.0f, 0.0f, 0.5f, 0.5f, 0.0f, 0.0f, 0.5f, 0.5f,
+        -1.0f,  1.0f, 0.0f, 0.0f, 0.0f, 0.5f, 0.5f, 0.0f, 0.0f, 0.5f, 0.5f,
+         1.0f, -1.0f, 0.0f, 0.0f, 0.0f, 0.5f, 0.5f, 0.0f, 0.0f, 0.5f, 0.5f,
+         1.0f,  1.0f, 0.0f, 0.0f, 0.0f, 0.5f, 0.5f, 0.0f, 0.0f, 0.5f, 0.5f,
+    };
+    static const D3DVERTEXELEMENT9 decl_elements[][4] =
+    {
+        {
+            {0, 0,  D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_POSITION, 0},
+            {0, 12, D3DDECLTYPE_FLOAT2, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_TEXCOORD, 0},
+            {0, 20, D3DDECLTYPE_FLOAT2, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_TEXCOORD, 1},
+            D3DDECL_END()
+        },
+        {
+            {0, 0,  D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_POSITION, 0},
+            {0, 12, D3DDECLTYPE_FLOAT2, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_TEXCOORD, 0},
+            {0, 20, D3DDECLTYPE_FLOAT4, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_TEXCOORD, 1},
+            D3DDECL_END()
+        },
+    };
 
-    static const D3DVERTEXELEMENT9 decl_elements[][4] = { {
-        {0, 0,  D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_POSITION, 0},
-        {0, 12, D3DDECLTYPE_FLOAT2, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_TEXCOORD, 0},
-        {0, 20, D3DDECLTYPE_FLOAT2, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_TEXCOORD, 1},
-        D3DDECL_END()
-    },{
-        {0, 0,  D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_POSITION, 0},
-        {0, 12, D3DDECLTYPE_FLOAT2, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_TEXCOORD, 0},
-        {0, 20, D3DDECLTYPE_FLOAT4, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_TEXCOORD, 1},
-        D3DDECL_END()
-    } };
-
-    /* use asymmetric matrix to test loading */
-    float bumpenvmat[4] = {0.0,0.5,-0.5,0.0};
+    window = CreateWindowA("static", "d3d9_test", WS_OVERLAPPEDWINDOW | WS_VISIBLE,
+            0, 0, 640, 480, NULL, NULL, NULL, NULL);
+    d3d = Direct3DCreate9(D3D_SDK_VERSION);
+    ok(!!d3d, "Failed to create a D3D object.\n");
+    if (!(device = create_device(d3d, window, window, TRUE)))
+    {
+        skip("Failed to create a D3D device, skipping tests.\n");
+        goto done;
+    }
 
-    IDirect3DVertexDeclaration9 *vertex_declaration = NULL;
-    IDirect3DPixelShader9       *pixel_shader       = NULL;
-    IDirect3DTexture9           *texture            = NULL, *texture1, *texture2;
-    D3DLOCKED_RECT locked_rect;
+    hr = IDirect3DDevice9_GetDeviceCaps(device, &caps);
+    ok(SUCCEEDED(hr), "Failed to get device caps, hr %#x.\n", hr);
+    if (caps.PixelShaderVersion < D3DPS_VERSION(1, 1))
+    {
+        skip("No ps_1_1 support, skipping tests.\n");
+        IDirect3DDevice9_Release(device);
+        goto done;
+    }
 
     generate_bumpmap_textures(device);
 
@@ -2250,7 +2319,7 @@ static void texbem_test(IDirect3DDevice9 *device)
     hr = IDirect3DDevice9_SetVertexShader(device, NULL);
     ok(SUCCEEDED(hr), "SetVertexShader failed (%08x)\n", hr);
 
-    hr = IDirect3DDevice9_Clear(device, 0, NULL, D3DCLEAR_TARGET, 0xffff00ff, 0.0, 0);
+    hr = IDirect3DDevice9_Clear(device, 0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0xffff00ff, 1.0f, 0);
     ok(hr == D3D_OK, "IDirect3DDevice9_Clear failed (%08x)\n", hr);
 
     for(i=0; i<2; i++)
@@ -2427,34 +2496,14 @@ static void texbem_test(IDirect3DDevice9 *device)
     ok(SUCCEEDED(hr), "IDirect3DDevice9_SetSamplerState returned %#x.\n", hr);
 
     hr = IDirect3DDevice9_BeginScene(device);
-    ok(SUCCEEDED(hr), "BeginScene failed (0x%08x)\n", hr);
-    if(SUCCEEDED(hr)) {
-        static const float double_quad[] = {
-            -1.0,   -1.0,   0.0,    0.0,    0.0,    0.5,    0.5,    0.0,    0.0,    0.5,    0.5,
-             1.0,   -1.0,   0.0,    0.0,    0.0,    0.5,    0.5,    0.0,    0.0,    0.5,    0.5,
-            -1.0,    1.0,   0.0,    0.0,    0.0,    0.5,    0.5,    0.0,    0.0,    0.5,    0.5,
-             1.0,    1.0,   0.0,    0.0,    0.0,    0.5,    0.5,    0.0,    0.0,    0.5,    0.5,
-        };
-
-        hr = IDirect3DDevice9_DrawPrimitiveUP(device, D3DPT_TRIANGLESTRIP, 2, double_quad, sizeof(float) * 11);
-        ok(SUCCEEDED(hr), "DrawPrimitiveUP failed (0x%08x)\n", hr);
-        hr = IDirect3DDevice9_EndScene(device);
-        ok(SUCCEEDED(hr), "EndScene failed (0x%08x)\n", hr);
-    }
+    ok(SUCCEEDED(hr), "Failed to begin scene, hr %#x.\n", hr);
+    hr = IDirect3DDevice9_DrawPrimitiveUP(device, D3DPT_TRIANGLESTRIP, 2, double_quad, sizeof(float) * 11);
+    ok(SUCCEEDED(hr), "Failed to draw primitive, hr %#x.\n", hr);
+    hr = IDirect3DDevice9_EndScene(device);
+    ok(SUCCEEDED(hr), "Failed to end scene, hr %#x.\n", hr);
     color = getPixelColor(device, 320, 240);
     ok(color == 0x00ffff00, "double texbem failed: Got color 0x%08x, expected 0x00ffff00.\n", color);
 
-    hr = IDirect3DDevice9_SetTexture(device, 0, NULL);
-    ok(SUCCEEDED(hr), "IDirect3DDevice9_SetTexture failed (0x%08x)\n", hr);
-    hr = IDirect3DDevice9_SetTexture(device, 1, NULL);
-    ok(SUCCEEDED(hr), "IDirect3DDevice9_SetTexture failed (0x%08x)\n", hr);
-    hr = IDirect3DDevice9_SetTexture(device, 2, NULL);
-    ok(SUCCEEDED(hr), "IDirect3DDevice9_SetTexture failed (0x%08x)\n", hr);
-    hr = IDirect3DDevice9_SetTexture(device, 3, NULL);
-    ok(SUCCEEDED(hr), "IDirect3DDevice9_SetTexture failed (0x%08x)\n", hr);
-    hr = IDirect3DDevice9_SetPixelShader(device, NULL);
-    ok(SUCCEEDED(hr), "Direct3DDevice9_SetPixelShader failed (0x%08x)\n", hr);
-
     hr = IDirect3DDevice9_Present(device, NULL, NULL, NULL, NULL);
     ok(SUCCEEDED(hr), "Present failed (0x%08x)\n", hr);
 
@@ -2462,6 +2511,11 @@ static void texbem_test(IDirect3DDevice9 *device)
     IDirect3DTexture9_Release(texture);
     IDirect3DTexture9_Release(texture1);
     IDirect3DTexture9_Release(texture2);
+    refcount = IDirect3DDevice9_Release(device);
+    ok(!refcount, "Device has %u references left.\n", refcount);
+done:
+    IDirect3D9_Release(d3d);
+    DestroyWindow(window);
 }
 
 static void z_range_test(IDirect3DDevice9 *device)
@@ -4679,17 +4733,24 @@ static void texture_transform_flags_test(IDirect3DDevice9 *device)
     IDirect3DVertexDeclaration9_Release(decl4);
 }
 
-static void texdepth_test(IDirect3DDevice9 *device)
+static void texdepth_test(void)
 {
     IDirect3DPixelShader9 *shader;
+    IDirect3DDevice9 *device;
+    IDirect3D9 *d3d;
+    ULONG refcount;
+    D3DCAPS9 caps;
+    DWORD color;
+    HWND window;
     HRESULT hr;
-    const float texdepth_test_data1[] = { 0.25,  2.0, 0.0, 0.0};
-    const float texdepth_test_data2[] = { 0.25,  0.5, 0.0, 0.0};
-    const float texdepth_test_data3[] = {-1.00,  0.1, 0.0, 0.0};
-    const float texdepth_test_data4[] = {-0.25, -0.5, 0.0, 0.0};
-    const float texdepth_test_data5[] = { 1.00, -0.1, 0.0, 0.0};
-    const float texdepth_test_data6[] = { 1.00,  0.5, 0.0, 0.0};
-    const float texdepth_test_data7[] = { 0.50,  0.0, 0.0, 0.0};
+
+    static const float texdepth_test_data1[] = { 0.25f,  2.0f, 0.0f, 0.0f};
+    static const float texdepth_test_data2[] = { 0.25f,  0.5f, 0.0f, 0.0f};
+    static const float texdepth_test_data3[] = {-1.00f,  0.1f, 0.0f, 0.0f};
+    static const float texdepth_test_data4[] = {-0.25f, -0.5f, 0.0f, 0.0f};
+    static const float texdepth_test_data5[] = { 1.00f, -0.1f, 0.0f, 0.0f};
+    static const float texdepth_test_data6[] = { 1.00f,  0.5f, 0.0f, 0.0f};
+    static const float texdepth_test_data7[] = { 0.50f,  0.0f, 0.0f, 0.0f};
     static const DWORD shader_code[] =
     {
         0xffff0104,                                                                 /* ps_1_4               */
@@ -4700,19 +4761,40 @@ static void texdepth_test(IDirect3DDevice9 *device)
         0x00000001, 0x800f0000, 0xa0e40001,                                         /* mov r0, c1           */
         0x0000ffff                                                                  /* end                  */
     };
-    DWORD color;
-    float vertex[] = {
-       -1.0,   -1.0,    0.0,
-        1.0,   -1.0,    1.0,
-       -1.0,    1.0,    0.0,
-        1.0,    1.0,    1.0
+    static const float vertex[] =
+    {
+        -1.0f, -1.0f, 0.0f,
+        -1.0f,  1.0f, 0.0f,
+         1.0f, -1.0f, 1.0f,
+         1.0f,  1.0f, 1.0f,
     };
 
+    window = CreateWindowA("static", "d3d9_test", WS_OVERLAPPEDWINDOW | WS_VISIBLE,
+            0, 0, 640, 480, NULL, NULL, NULL, NULL);
+    d3d = Direct3DCreate9(D3D_SDK_VERSION);
+    ok(!!d3d, "Failed to create a D3D object.\n");
+    if (!(device = create_device(d3d, window, window, TRUE)))
+    {
+        skip("Failed to create a D3D device, skipping tests.\n");
+        goto done;
+    }
+
+    hr = IDirect3DDevice9_GetDeviceCaps(device, &caps);
+    ok(SUCCEEDED(hr), "Failed to get device caps, hr %#x.\n", hr);
+    if (caps.PixelShaderVersion < D3DPS_VERSION(1, 1))
+    {
+        skip("No ps_1_1 support, skipping tests.\n");
+        IDirect3DDevice9_Release(device);
+        goto done;
+    }
+
     hr = IDirect3DDevice9_CreatePixelShader(device, shader_code, &shader);
     ok(hr == D3D_OK, "IDirect3DDevice9_CreatePixelShader returned %08x\n", hr);
 
     hr = IDirect3DDevice9_Clear(device, 0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0xffffff00, 0.0, 0);
     ok(hr == D3D_OK, "IDirect3DDevice9_Clear returned %08x\n", hr);
+    hr = IDirect3DDevice9_SetRenderState(device, D3DRS_LIGHTING, FALSE);
+    ok(SUCCEEDED(hr), "Failed to disable lighting, hr %#x.\n", hr);
     hr = IDirect3DDevice9_SetRenderState(device, D3DRS_ZENABLE, D3DZB_TRUE);
     ok(hr == D3D_OK, "IDirect3DDevice9_SetRenderState returned %08x\n", hr);
     hr = IDirect3DDevice9_SetRenderState(device, D3DRS_ZWRITEENABLE, TRUE);
@@ -4897,15 +4979,12 @@ static void texdepth_test(IDirect3DDevice9 *device)
     hr = IDirect3DDevice9_Present(device, NULL, NULL, NULL, NULL);
     ok(hr == D3D_OK, "IDirect3DDevice9_Present failed with %08x\n", hr);
 
-    /* Cleanup */
-    hr = IDirect3DDevice9_SetPixelShader(device, NULL);
-    ok(hr == D3D_OK, "IDirect3DDevice9_SetPixelShader failed (%08x)\n", hr);
     IDirect3DPixelShader9_Release(shader);
-
-    hr = IDirect3DDevice9_SetRenderState(device, D3DRS_ZENABLE, D3DZB_FALSE);
-    ok(hr == D3D_OK, "IDirect3DDevice9_SetRenderState returned %08x\n", hr);
-    hr = IDirect3DDevice9_SetRenderState(device, D3DRS_ZWRITEENABLE, TRUE);
-    ok(hr == D3D_OK, "IDirect3DDevice9_SetRenderState returned %08x\n", hr);
+    refcount = IDirect3DDevice9_Release(device);
+    ok(!refcount, "Device has %u references left.\n", refcount);
+done:
+    IDirect3D9_Release(d3d);
+    DestroyWindow(window);
 }
 
 static void texkill_test(void)
@@ -8238,24 +8317,26 @@ static void fixed_function_decl_test(IDirect3DDevice9 *device)
     if(dcl_positiont) IDirect3DVertexDeclaration9_Release(dcl_positiont);
 }
 
-struct vertex_float16color {
-    float x, y, z;
-    DWORD c1, c2;
-};
-
-static void test_vshader_float16(IDirect3DDevice9 *device)
+static void test_vshader_float16(void)
 {
-    HRESULT hr;
+    IDirect3DVertexDeclaration9 *vdecl = NULL;
+    IDirect3DVertexBuffer9 *buffer = NULL;
+    IDirect3DVertexShader9 *shader;
+    IDirect3DDevice9 *device;
+    IDirect3D9 *d3d;
+    ULONG refcount;
+    D3DCAPS9 caps;
     DWORD color;
+    HWND window;
     void *data;
-    static const D3DVERTEXELEMENT9 decl_elements[] = {
+    HRESULT hr;
+
+    static const D3DVERTEXELEMENT9 decl_elements[] =
+    {
         {0,   0,  D3DDECLTYPE_FLOAT3,   D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_POSITION,       0},
         {0,  12,  D3DDECLTYPE_FLOAT16_4,D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_COLOR,          0},
         D3DDECL_END()
     };
-    IDirect3DVertexDeclaration9 *vdecl = NULL;
-    IDirect3DVertexBuffer9 *buffer = NULL;
-    IDirect3DVertexShader9 *shader;
     static const DWORD shader_code[] =
     {
         0xfffe0101,                             /* vs_1_1           */
@@ -8265,7 +8346,13 @@ static void test_vshader_float16(IDirect3DDevice9 *device)
         0x00000001, 0xd00f0000, 0x90e40001,     /* mov oD0, v1      */
         0x0000ffff,
     };
-    struct vertex_float16color quad[] = {
+    static const struct vertex_float16color
+    {
+        float x, y, z;
+        DWORD c1, c2;
+    }
+    quad[] =
+    {
         { -1.0,   -1.0,     0.1,        0x3c000000, 0x00000000 }, /* green */
         { -1.0,    0.0,     0.1,        0x3c000000, 0x00000000 },
         {  0.0,   -1.0,     0.1,        0x3c000000, 0x00000000 },
@@ -8287,7 +8374,26 @@ static void test_vshader_float16(IDirect3DDevice9 *device)
         {  0.0,    1.0,     0.1,        0x00000000, 0x3c000000 },
     };
 
-    hr = IDirect3DDevice9_Clear(device, 0, NULL, D3DCLEAR_TARGET, 0xff102030, 0.0, 0);
+    window = CreateWindowA("static", "d3d9_test", WS_OVERLAPPEDWINDOW | WS_VISIBLE,
+            0, 0, 640, 480, NULL, NULL, NULL, NULL);
+    d3d = Direct3DCreate9(D3D_SDK_VERSION);
+    ok(!!d3d, "Failed to create a D3D object.\n");
+    if (!(device = create_device(d3d, window, window, TRUE)))
+    {
+        skip("Failed to create a D3D device, skipping tests.\n");
+        goto done;
+    }
+
+    hr = IDirect3DDevice9_GetDeviceCaps(device, &caps);
+    ok(SUCCEEDED(hr), "Failed to get device caps, hr %#x.\n", hr);
+    if (caps.VertexShaderVersion < D3DVS_VERSION(3, 0))
+    {
+        skip("No vs_3_0 support, skipping tests.\n");
+        IDirect3DDevice9_Release(device);
+        goto done;
+    }
+
+    hr = IDirect3DDevice9_Clear(device, 0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0xff102030, 1.0f, 0);
     ok(hr == D3D_OK, "IDirect3DDevice9_Clear failed, hr=%08x\n", hr);
 
     hr = IDirect3DDevice9_CreateVertexDeclaration(device, decl_elements, &vdecl);
@@ -8372,16 +8478,14 @@ static void test_vshader_float16(IDirect3DDevice9 *device)
        "Input 0x00000000, 0x00003c00 returned color %08x, expected 0x000000ff\n", color);
     IDirect3DDevice9_Present(device, NULL, NULL, NULL, NULL);
 
-    hr = IDirect3DDevice9_SetStreamSource(device, 0, NULL, 0, 0);
-    ok(hr == D3D_OK, "IDirect3DDevice9_SetStreamSource failed, hr=%08x\n", hr);
-    hr = IDirect3DDevice9_SetVertexDeclaration(device, NULL);
-    ok(hr == D3D_OK, "IDirect3DDevice9_SetVertexDeclaration failed, hr=%08x\n", hr);
-    hr = IDirect3DDevice9_SetVertexShader(device, NULL);
-    ok(SUCCEEDED(hr), "IDirect3DDevice9_SetVertexShader failed hr=%08x\n", hr);
-
     IDirect3DVertexDeclaration9_Release(vdecl);
     IDirect3DVertexShader9_Release(shader);
     IDirect3DVertexBuffer9_Release(buffer);
+    refcount = IDirect3DDevice9_Release(device);
+    ok(!refcount, "Device has %u references left.\n", refcount);
+done:
+    IDirect3D9_Release(d3d);
+    DestroyWindow(window);
 }
 
 static void conditional_np2_repeat_test(IDirect3DDevice9 *device)
@@ -10136,61 +10240,64 @@ static void tssargtemp_test(IDirect3DDevice9 *device)
     ok(hr == D3D_OK, "SetTextureStageState failed, hr = %08x\n", hr);
 }
 
-struct testdata
-{
-    DWORD idxVertex; /* number of instances in the first stream */
-    DWORD idxColor; /* number of instances in the second stream */
-    DWORD idxInstance; /* should be 1 ?? */
-    DWORD color1; /* color 1 instance */
-    DWORD color2; /* color 2 instance */
-    DWORD color3; /* color 3 instance */
-    DWORD color4; /* color 4 instance */
-    WORD strVertex; /* specify which stream to use 0-2*/
-    WORD strColor;
-    WORD strInstance;
-};
-
-static const struct testdata testcases[]=
-{
-    {4, 4, 1, 0x00ff0000, 0x00ff0000, 0x00ff0000, 0x00ff0000, 0, 1, 2}, /*  0 */
-    {3, 4, 1, 0x00ff0000, 0x00ff0000, 0x00ff0000, 0x00ffffff, 0, 1, 2}, /*  1 */
-    {2, 4, 1, 0x00ff0000, 0x00ff0000, 0x00ffffff, 0x00ffffff, 0, 1, 2}, /*  2 */
-    {1, 4, 1, 0x00ff0000, 0x00ffffff, 0x00ffffff, 0x00ffffff, 0, 1, 2}, /*  3 */
-    {4, 3, 1, 0x00ff0000, 0x00ff0000, 0x00ff0000, 0x00ff0000, 0, 1, 2}, /*  4 */
-    {4, 2, 1, 0x00ff0000, 0x00ff0000, 0x00ff0000, 0x00ff0000, 0, 1, 2}, /*  5 */
-    {4, 1, 1, 0x00ff0000, 0x00ff0000, 0x00ff0000, 0x00ff0000, 0, 1, 2}, /*  6 */
-    {4, 0, 1, 0x00ff0000, 0x00ff0000, 0x00ff0000, 0x00ff0000, 0, 1, 2}, /*  7 */
-    {3, 3, 1, 0x00ff0000, 0x00ff0000, 0x00ff0000, 0x00ffffff, 0, 1, 2}, /*  8 */
-    {4, 4, 1, 0x00ff0000, 0x00ff0000, 0x00ff0000, 0x00ff0000, 1, 0, 2}, /*  9 */
-    {4, 4, 1, 0x00ff0000, 0x00ff0000, 0x00ff0000, 0x00ff0000, 0, 2, 1}, /* 10 */
-    {4, 4, 1, 0x00ff0000, 0x00ffffff, 0x00ffffff, 0x00ffffff, 2, 3, 1}, /* 11 */
-    {4, 4, 1, 0x00ff0000, 0x00ff0000, 0x00ff0000, 0x00ff0000, 2, 0, 1}, /* 12 */
-    {4, 4, 1, 0x00ff0000, 0x00ff0000, 0x00ff0000, 0x00ff0000, 1, 2, 3}, /* 13 */
-/*
-    This draws one instance on some machines, no instance on others
-    {0, 4, 1, 0x00ff0000, 0x00ffffff, 0x00ffffff, 0x00ffffff, 0, 1, 2},
-*/
-/*
-    This case is handled in a stand alone test, SetStreamSourceFreq(0,(D3DSTREAMSOURCE_INSTANCEDATA | 1))  has to return D3DERR_INVALIDCALL!
-    {4, 4, 1, 0x00ffffff, 0x00ffffff, 0x00ffffff, 0x00ffffff, 2, 1, 0, D3DERR_INVALIDCALL},
-*/
-};
-
 /* Drawing Indexed Geometry with instances*/
-static void stream_test(IDirect3DDevice9 *device)
+static void stream_test(void)
 {
-    IDirect3DVertexBuffer9 *vb = NULL;
-    IDirect3DVertexBuffer9 *vb2 = NULL;
-    IDirect3DVertexBuffer9 *vb3 = NULL;
-    IDirect3DIndexBuffer9 *ib = NULL;
     IDirect3DVertexDeclaration9 *pDecl = NULL;
     IDirect3DVertexShader9 *shader = NULL;
+    IDirect3DVertexBuffer9 *vb3 = NULL;
+    IDirect3DVertexBuffer9 *vb2 = NULL;
+    IDirect3DVertexBuffer9 *vb = NULL;
+    IDirect3DIndexBuffer9 *ib = NULL;
+    IDirect3DDevice9 *device;
+    IDirect3D9 *d3d;
+    ULONG refcount;
+    D3DCAPS9 caps;
+    DWORD color;
+    HWND window;
+    unsigned i;
     HRESULT hr;
     BYTE *data;
-    DWORD color;
     DWORD ind;
-    unsigned i;
 
+    static const struct testdata
+    {
+        DWORD idxVertex; /* number of instances in the first stream */
+        DWORD idxColor; /* number of instances in the second stream */
+        DWORD idxInstance; /* should be 1 ?? */
+        DWORD color1; /* color 1 instance */
+        DWORD color2; /* color 2 instance */
+        DWORD color3; /* color 3 instance */
+        DWORD color4; /* color 4 instance */
+        WORD strVertex; /* specify which stream to use 0-2*/
+        WORD strColor;
+        WORD strInstance;
+    }
+    testcases[]=
+    {
+        {4, 4, 1, 0x00ff0000, 0x00ff0000, 0x00ff0000, 0x00ff0000, 0, 1, 2}, /*  0 */
+        {3, 4, 1, 0x00ff0000, 0x00ff0000, 0x00ff0000, 0x00ffffff, 0, 1, 2}, /*  1 */
+        {2, 4, 1, 0x00ff0000, 0x00ff0000, 0x00ffffff, 0x00ffffff, 0, 1, 2}, /*  2 */
+        {1, 4, 1, 0x00ff0000, 0x00ffffff, 0x00ffffff, 0x00ffffff, 0, 1, 2}, /*  3 */
+        {4, 3, 1, 0x00ff0000, 0x00ff0000, 0x00ff0000, 0x00ff0000, 0, 1, 2}, /*  4 */
+        {4, 2, 1, 0x00ff0000, 0x00ff0000, 0x00ff0000, 0x00ff0000, 0, 1, 2}, /*  5 */
+        {4, 1, 1, 0x00ff0000, 0x00ff0000, 0x00ff0000, 0x00ff0000, 0, 1, 2}, /*  6 */
+        {4, 0, 1, 0x00ff0000, 0x00ff0000, 0x00ff0000, 0x00ff0000, 0, 1, 2}, /*  7 */
+        {3, 3, 1, 0x00ff0000, 0x00ff0000, 0x00ff0000, 0x00ffffff, 0, 1, 2}, /*  8 */
+        {4, 4, 1, 0x00ff0000, 0x00ff0000, 0x00ff0000, 0x00ff0000, 1, 0, 2}, /*  9 */
+        {4, 4, 1, 0x00ff0000, 0x00ff0000, 0x00ff0000, 0x00ff0000, 0, 2, 1}, /* 10 */
+        {4, 4, 1, 0x00ff0000, 0x00ffffff, 0x00ffffff, 0x00ffffff, 2, 3, 1}, /* 11 */
+        {4, 4, 1, 0x00ff0000, 0x00ff0000, 0x00ff0000, 0x00ff0000, 2, 0, 1}, /* 12 */
+        {4, 4, 1, 0x00ff0000, 0x00ff0000, 0x00ff0000, 0x00ff0000, 1, 2, 3}, /* 13 */
+#if 0
+        /* This draws one instance on some machines, no instance on others. */
+        {0, 4, 1, 0x00ff0000, 0x00ffffff, 0x00ffffff, 0x00ffffff, 0, 1, 2}, /* 14 */
+        /* This case is handled in a stand alone test,
+         * SetStreamSourceFreq(0, (D3DSTREAMSOURCE_INSTANCEDATA | 1)) has to
+         * return D3DERR_INVALIDCALL. */
+        {4, 4, 1, 0x00ffffff, 0x00ffffff, 0x00ffffff, 0x00ffffff, 2, 1, 0}, /* 15 */
+#endif
+    };
     static const DWORD shader_code[] =
     {
         0xfffe0101,                                     /* vs_1_1 */
@@ -10202,34 +10309,29 @@ static void stream_test(IDirect3DDevice9 *device)
         0x00000001, 0xd00f0000, 0x90e40001,             /* mov oD0, v1 */
         0x0000ffff
     };
-
-    const float quad[][3] =
+    static const float quad[][3] =
     {
         {-0.5f, -0.5f,  1.1f}, /*0 */
         {-0.5f,  0.5f,  1.1f}, /*1 */
         { 0.5f, -0.5f,  1.1f}, /*2 */
         { 0.5f,  0.5f,  1.1f}, /*3 */
     };
-
-    const float vertcolor[][4] =
+    static const float vertcolor[][4] =
     {
         {1.0f, 0.0f, 0.0f, 1.0f}, /*0 */
         {1.0f, 0.0f, 0.0f, 1.0f}, /*1 */
         {1.0f, 0.0f, 0.0f, 1.0f}, /*2 */
         {1.0f, 0.0f, 0.0f, 1.0f}, /*3 */
     };
-
     /* 4 position for 4 instances */
-    const float instancepos[][3] =
+    static const float instancepos[][3] =
     {
         {-0.6f,-0.6f, 0.0f},
         { 0.6f,-0.6f, 0.0f},
         { 0.6f, 0.6f, 0.0f},
         {-0.6f, 0.6f, 0.0f},
     };
-
-    short indices[] = {0, 1, 2, 1, 2, 3};
-
+    static const short indices[] = {0, 1, 2, 2, 1, 3};
     D3DVERTEXELEMENT9 decl[] =
     {
         {0, 0, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_POSITION, 0},
@@ -10238,6 +10340,25 @@ static void stream_test(IDirect3DDevice9 *device)
         D3DDECL_END()
     };
 
+    window = CreateWindowA("static", "d3d9_test", WS_OVERLAPPEDWINDOW | WS_VISIBLE,
+            0, 0, 640, 480, NULL, NULL, NULL, NULL);
+    d3d = Direct3DCreate9(D3D_SDK_VERSION);
+    ok(!!d3d, "Failed to create a D3D object.\n");
+    if (!(device = create_device(d3d, window, window, TRUE)))
+    {
+        skip("Failed to create a D3D device, skipping tests.\n");
+        goto done;
+    }
+
+    hr = IDirect3DDevice9_GetDeviceCaps(device, &caps);
+    ok(SUCCEEDED(hr), "Failed to get device caps, hr %#x.\n", hr);
+    if (caps.VertexShaderVersion < D3DVS_VERSION(3, 0))
+    {
+        skip("No vs_3_0 support, skipping tests.\n");
+        IDirect3DDevice9_Release(device);
+        goto done;
+    }
+
     /* set the default value because it isn't done in wine? */
     hr = IDirect3DDevice9_SetStreamSourceFreq(device, 1, 1);
     ok(hr == D3D_OK, "IDirect3DDevice9_SetStreamSourceFreq failed with %08x\n", hr);
@@ -10277,7 +10398,8 @@ static void stream_test(IDirect3DDevice9 *device)
     ok(hr == D3D_OK, "CreateVertexBuffer failed with %08x\n", hr);
     if(!vb) {
         skip("Failed to create a vertex buffer\n");
-        return;
+        IDirect3DDevice9_Release(device);
+        goto done;
     }
     hr = IDirect3DDevice9_CreateVertexBuffer(device, sizeof(vertcolor), 0, 0, D3DPOOL_MANAGED, &vb2, NULL);
     ok(hr == D3D_OK, "CreateVertexBuffer failed with %08x\n", hr);
@@ -10347,7 +10469,7 @@ static void stream_test(IDirect3DDevice9 *device)
         hr = IDirect3DDevice9_CreateVertexDeclaration(device, decl, &pDecl);
         ok(SUCCEEDED(hr), "IDirect3DDevice9_CreateVertexDeclaration failed hr=%08x (case %i)\n", hr, i);
 
-        hr = IDirect3DDevice9_Clear(device, 0, NULL, D3DCLEAR_TARGET, 0xffffffff, 0.0, 0);
+        hr = IDirect3DDevice9_Clear(device, 0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0xffffffff, 1.0f, 0);
         ok(hr == D3D_OK, "IDirect3DDevice9_Clear failed with %08x (case %i)\n", hr, i);
 
         hr = IDirect3DDevice9_BeginScene(device);
@@ -10408,15 +10530,17 @@ static void stream_test(IDirect3DDevice9 *device)
         ok(hr == D3D_OK, "IDirect3DDevice9_Present failed with %08x (case %i)\n", hr, i);
     }
 
-    hr = IDirect3DDevice9_SetIndices(device, NULL);
-    ok(hr == D3D_OK, "IDirect3DDevice9_SetIndices failed with %08x\n", hr);
-
 out:
     if(vb) IDirect3DVertexBuffer9_Release(vb);
     if(vb2)IDirect3DVertexBuffer9_Release(vb2);
     if(vb3)IDirect3DVertexBuffer9_Release(vb3);
     if(ib)IDirect3DIndexBuffer9_Release(ib);
     if(shader)IDirect3DVertexShader9_Release(shader);
+    refcount = IDirect3DDevice9_Release(device);
+    ok(!refcount, "Device has %u references left.\n", refcount);
+done:
+    IDirect3D9_Release(d3d);
+    DestroyWindow(window);
 }
 
 static void np2_stretch_rect_test(IDirect3DDevice9 *device) {
@@ -15855,7 +15979,7 @@ static void add_dirty_rect_test(void)
     fill_surface(surface_managed, 0x0000ff00, D3DLOCK_NO_DIRTY_UPDATE);
     add_dirty_rect_test_draw(device);
     color = getPixelColor(device, 320, 240);
-    ok(color_match(color, 0x00ff0000, 1),
+    todo_wine ok(color_match(color, 0x00ff0000, 1),
             "Expected color 0x00ff0000, got 0x%08x.\n", color);
     hr = IDirect3DDevice9_Present(device, NULL, NULL, NULL, NULL);
     ok(SUCCEEDED(hr), "Failed to present, hr %#x.\n", hr);
@@ -16026,30 +16150,20 @@ START_TEST(visual)
         clip_planes_test(device_ptr);
         if (caps.VertexShaderVersion >= D3DVS_VERSION(3, 0)) {
             test_vshader_input(device_ptr);
-            test_vshader_float16(device_ptr);
-            stream_test(device_ptr);
         } else {
             skip("No vs_3_0 support\n");
         }
     }
     else skip("No vs_2_0 support\n");
 
-    if (caps.VertexShaderVersion >= D3DVS_VERSION(2, 0) && caps.PixelShaderVersion >= D3DPS_VERSION(2, 0))
-    {
-        fog_with_shader_test(device_ptr);
-    }
-    else skip("No vs_2_0 and ps_2_0 support\n");
-
-    if (caps.PixelShaderVersion >= D3DPS_VERSION(1, 1))
-    {
-        texbem_test(device_ptr);
-        texdepth_test(device_ptr);
-    }
-    else skip("No ps_1_1 support\n");
-
     cleanup_device(device_ptr);
     device_ptr = NULL;
 
+    test_vshader_float16();
+    stream_test();
+    fog_with_shader_test();
+    texbem_test();
+    texdepth_test();
     texkill_test();
     x8l8v8u8_test();
     volume_v16u16_test();
diff --git a/dlls/d3d9/texture.c b/dlls/d3d9/texture.c
index b34fbc6..3c2107a 100644
--- a/dlls/d3d9/texture.c
+++ b/dlls/d3d9/texture.c
@@ -61,7 +61,7 @@ static HRESULT WINAPI d3d9_texture_2d_QueryInterface(IDirect3DTexture9 *iface, R
 static ULONG WINAPI d3d9_texture_2d_AddRef(IDirect3DTexture9 *iface)
 {
     struct d3d9_texture *texture = impl_from_IDirect3DTexture9(iface);
-    ULONG ref = InterlockedIncrement(&texture->refcount);
+    ULONG ref = InterlockedIncrement(&texture->resource.refcount);
 
     TRACE("%p increasing refcount to %u.\n", iface, ref);
 
@@ -79,7 +79,7 @@ static ULONG WINAPI d3d9_texture_2d_AddRef(IDirect3DTexture9 *iface)
 static ULONG WINAPI d3d9_texture_2d_Release(IDirect3DTexture9 *iface)
 {
     struct d3d9_texture *texture = impl_from_IDirect3DTexture9(iface);
-    ULONG ref = InterlockedDecrement(&texture->refcount);
+    ULONG ref = InterlockedDecrement(&texture->resource.refcount);
 
     TRACE("%p decreasing refcount to %u.\n", iface, ref);
 
@@ -115,52 +115,28 @@ static HRESULT WINAPI d3d9_texture_2d_SetPrivateData(IDirect3DTexture9 *iface,
         REFGUID guid, const void *data, DWORD data_size, DWORD flags)
 {
     struct d3d9_texture *texture = impl_from_IDirect3DTexture9(iface);
-    struct wined3d_resource *resource;
-    HRESULT hr;
-
     TRACE("iface %p, guid %s, data %p, data_size %u, flags %#x.\n",
             iface, debugstr_guid(guid), data, data_size, flags);
 
-    wined3d_mutex_lock();
-    resource = wined3d_texture_get_resource(texture->wined3d_texture);
-    hr = wined3d_resource_set_private_data(resource, guid, data, data_size, flags);
-    wined3d_mutex_unlock();
-
-    return hr;
+    return d3d9_resource_set_private_data(&texture->resource, guid, data, data_size, flags);
 }
 
 static HRESULT WINAPI d3d9_texture_2d_GetPrivateData(IDirect3DTexture9 *iface,
         REFGUID guid, void *data, DWORD *data_size)
 {
     struct d3d9_texture *texture = impl_from_IDirect3DTexture9(iface);
-    struct wined3d_resource *resource;
-    HRESULT hr;
-
     TRACE("iface %p, guid %s, data %p, data_size %p.\n",
             iface, debugstr_guid(guid), data, data_size);
 
-    wined3d_mutex_lock();
-    resource = wined3d_texture_get_resource(texture->wined3d_texture);
-    hr = wined3d_resource_get_private_data(resource, guid, data, data_size);
-    wined3d_mutex_unlock();
-
-    return hr;
+    return d3d9_resource_get_private_data(&texture->resource, guid, data, data_size);
 }
 
 static HRESULT WINAPI d3d9_texture_2d_FreePrivateData(IDirect3DTexture9 *iface, REFGUID guid)
 {
     struct d3d9_texture *texture = impl_from_IDirect3DTexture9(iface);
-    struct wined3d_resource *resource;
-    HRESULT hr;
-
     TRACE("iface %p, guid %s.\n", iface, debugstr_guid(guid));
 
-    wined3d_mutex_lock();
-    resource = wined3d_texture_get_resource(texture->wined3d_texture);
-    hr = wined3d_resource_free_private_data(resource, guid);
-    wined3d_mutex_unlock();
-
-    return hr;
+    return d3d9_resource_free_private_data(&texture->resource, guid);
 }
 
 static DWORD WINAPI d3d9_texture_2d_SetPriority(IDirect3DTexture9 *iface, DWORD priority)
@@ -472,7 +448,7 @@ static HRESULT WINAPI d3d9_texture_cube_QueryInterface(IDirect3DCubeTexture9 *if
 static ULONG WINAPI d3d9_texture_cube_AddRef(IDirect3DCubeTexture9 *iface)
 {
     struct d3d9_texture *texture = impl_from_IDirect3DCubeTexture9(iface);
-    ULONG ref = InterlockedIncrement(&texture->refcount);
+    ULONG ref = InterlockedIncrement(&texture->resource.refcount);
 
     TRACE("%p increasing refcount to %u.\n", iface, ref);
 
@@ -490,7 +466,7 @@ static ULONG WINAPI d3d9_texture_cube_AddRef(IDirect3DCubeTexture9 *iface)
 static ULONG WINAPI d3d9_texture_cube_Release(IDirect3DCubeTexture9 *iface)
 {
     struct d3d9_texture *texture = impl_from_IDirect3DCubeTexture9(iface);
-    ULONG ref = InterlockedDecrement(&texture->refcount);
+    ULONG ref = InterlockedDecrement(&texture->resource.refcount);
 
     TRACE("%p decreasing refcount to %u.\n", iface, ref);
 
@@ -528,52 +504,28 @@ static HRESULT WINAPI d3d9_texture_cube_SetPrivateData(IDirect3DCubeTexture9 *if
         REFGUID guid, const void *data, DWORD data_size, DWORD flags)
 {
     struct d3d9_texture *texture = impl_from_IDirect3DCubeTexture9(iface);
-    struct wined3d_resource *resource;
-    HRESULT hr;
-
     TRACE("iface %p, guid %s, data %p, data_size %u, flags %#x.\n",
             iface, debugstr_guid(guid), data, data_size, flags);
 
-    wined3d_mutex_lock();
-    resource = wined3d_texture_get_resource(texture->wined3d_texture);
-    hr = wined3d_resource_set_private_data(resource, guid, data, data_size, flags);
-    wined3d_mutex_unlock();
-
-    return hr;
+    return d3d9_resource_set_private_data(&texture->resource, guid, data, data_size, flags);
 }
 
 static HRESULT WINAPI d3d9_texture_cube_GetPrivateData(IDirect3DCubeTexture9 *iface,
         REFGUID guid, void *data, DWORD *data_size)
 {
     struct d3d9_texture *texture = impl_from_IDirect3DCubeTexture9(iface);
-    struct wined3d_resource *resource;
-    HRESULT hr;
-
     TRACE("iface %p, guid %s, data %p, data_size %p.\n",
             iface, debugstr_guid(guid), data, data_size);
 
-    wined3d_mutex_lock();
-    resource = wined3d_texture_get_resource(texture->wined3d_texture);
-    hr = wined3d_resource_get_private_data(resource, guid, data, data_size);
-    wined3d_mutex_unlock();
-
-    return hr;
+    return d3d9_resource_get_private_data(&texture->resource, guid, data, data_size);
 }
 
 static HRESULT WINAPI d3d9_texture_cube_FreePrivateData(IDirect3DCubeTexture9 *iface, REFGUID guid)
 {
     struct d3d9_texture *texture = impl_from_IDirect3DCubeTexture9(iface);
-    struct wined3d_resource *resource;
-    HRESULT hr;
-
     TRACE("iface %p, guid %s.\n", iface, debugstr_guid(guid));
 
-    wined3d_mutex_lock();
-    resource = wined3d_texture_get_resource(texture->wined3d_texture);
-    hr = wined3d_resource_free_private_data(resource, guid);
-    wined3d_mutex_unlock();
-
-    return hr;
+    return d3d9_resource_free_private_data(&texture->resource, guid);
 }
 
 static DWORD WINAPI d3d9_texture_cube_SetPriority(IDirect3DCubeTexture9 *iface, DWORD priority)
@@ -911,7 +863,7 @@ static HRESULT WINAPI d3d9_texture_3d_QueryInterface(IDirect3DVolumeTexture9 *if
 static ULONG WINAPI d3d9_texture_3d_AddRef(IDirect3DVolumeTexture9 *iface)
 {
     struct d3d9_texture *texture = impl_from_IDirect3DVolumeTexture9(iface);
-    ULONG ref = InterlockedIncrement(&texture->refcount);
+    ULONG ref = InterlockedIncrement(&texture->resource.refcount);
 
     TRACE("%p increasing refcount to %u.\n", iface, ref);
 
@@ -929,7 +881,7 @@ static ULONG WINAPI d3d9_texture_3d_AddRef(IDirect3DVolumeTexture9 *iface)
 static ULONG WINAPI d3d9_texture_3d_Release(IDirect3DVolumeTexture9 *iface)
 {
     struct d3d9_texture *texture = impl_from_IDirect3DVolumeTexture9(iface);
-    ULONG ref = InterlockedDecrement(&texture->refcount);
+    ULONG ref = InterlockedDecrement(&texture->resource.refcount);
 
     TRACE("%p decreasing refcount to %u.\n", iface, ref);
 
@@ -965,52 +917,28 @@ static HRESULT WINAPI d3d9_texture_3d_SetPrivateData(IDirect3DVolumeTexture9 *if
         REFGUID guid, const void *data, DWORD data_size, DWORD flags)
 {
     struct d3d9_texture *texture = impl_from_IDirect3DVolumeTexture9(iface);
-    struct wined3d_resource *resource;
-    HRESULT hr;
-
     TRACE("iface %p, guid %s, data %p, data_size %u, flags %#x.\n",
             iface, debugstr_guid(guid), data, data_size, flags);
 
-    wined3d_mutex_lock();
-    resource = wined3d_texture_get_resource(texture->wined3d_texture);
-    hr = wined3d_resource_set_private_data(resource, guid, data, data_size, flags);
-    wined3d_mutex_unlock();
-
-    return hr;
+    return d3d9_resource_set_private_data(&texture->resource, guid, data, data_size, flags);
 }
 
 static HRESULT WINAPI d3d9_texture_3d_GetPrivateData(IDirect3DVolumeTexture9 *iface,
         REFGUID guid, void *data, DWORD *data_size)
 {
     struct d3d9_texture *texture = impl_from_IDirect3DVolumeTexture9(iface);
-    struct wined3d_resource *resource;
-    HRESULT hr;
-
     TRACE("iface %p, guid %s, data %p, data_size %p.\n",
             iface, debugstr_guid(guid), data, data_size);
 
-    wined3d_mutex_lock();
-    resource = wined3d_texture_get_resource(texture->wined3d_texture);
-    hr = wined3d_resource_get_private_data(resource, guid, data, data_size);
-    wined3d_mutex_unlock();
-
-    return hr;
+    return d3d9_resource_get_private_data(&texture->resource, guid, data, data_size);
 }
 
 static HRESULT WINAPI d3d9_texture_3d_FreePrivateData(IDirect3DVolumeTexture9 *iface, REFGUID guid)
 {
     struct d3d9_texture *texture = impl_from_IDirect3DVolumeTexture9(iface);
-    struct wined3d_resource *resource;
-    HRESULT hr;
-
     TRACE("iface %p, guid %s.\n", iface, debugstr_guid(guid));
 
-    wined3d_mutex_lock();
-    resource = wined3d_texture_get_resource(texture->wined3d_texture);
-    hr = wined3d_resource_free_private_data(resource, guid);
-    wined3d_mutex_unlock();
-
-    return hr;
+    return d3d9_resource_free_private_data(&texture->resource, guid);
 }
 
 static DWORD WINAPI d3d9_texture_3d_SetPriority(IDirect3DVolumeTexture9 *iface, DWORD priority)
@@ -1298,7 +1226,9 @@ struct d3d9_texture *unsafe_impl_from_IDirect3DBaseTexture9(IDirect3DBaseTexture
 
 static void STDMETHODCALLTYPE d3d9_texture_wined3d_object_destroyed(void *parent)
 {
-    HeapFree(GetProcessHeap(), 0, parent);
+    struct d3d9_texture *texture = parent;
+    d3d9_resource_cleanup(&texture->resource);
+    HeapFree(GetProcessHeap(), 0, texture);
 }
 
 static const struct wined3d_parent_ops d3d9_texture_wined3d_parent_ops =
@@ -1314,7 +1244,7 @@ HRESULT texture_init(struct d3d9_texture *texture, struct d3d9_device *device,
     HRESULT hr;
 
     texture->IDirect3DBaseTexture9_iface.lpVtbl = (const IDirect3DBaseTexture9Vtbl *)&d3d9_texture_2d_vtbl;
-    texture->refcount = 1;
+    d3d9_resource_init(&texture->resource);
 
     desc.resource_type = WINED3D_RTYPE_TEXTURE;
     desc.format = wined3dformat_from_d3dformat(format);
@@ -1355,7 +1285,7 @@ HRESULT cubetexture_init(struct d3d9_texture *texture, struct d3d9_device *devic
     HRESULT hr;
 
     texture->IDirect3DBaseTexture9_iface.lpVtbl = (const IDirect3DBaseTexture9Vtbl *)&d3d9_texture_cube_vtbl;
-    texture->refcount = 1;
+    d3d9_resource_init(&texture->resource);
 
     desc.resource_type = WINED3D_RTYPE_CUBE_TEXTURE;
     desc.format = wined3dformat_from_d3dformat(format);
@@ -1395,7 +1325,7 @@ HRESULT volumetexture_init(struct d3d9_texture *texture, struct d3d9_device *dev
     HRESULT hr;
 
     texture->IDirect3DBaseTexture9_iface.lpVtbl = (const IDirect3DBaseTexture9Vtbl *)&d3d9_texture_3d_vtbl;
-    texture->refcount = 1;
+    d3d9_resource_init(&texture->resource);
 
     desc.resource_type = WINED3D_RTYPE_VOLUME_TEXTURE;
     desc.format = wined3dformat_from_d3dformat(format);
diff --git a/dlls/d3d9/volume.c b/dlls/d3d9/volume.c
index ec4c2b3..30a977c 100644
--- a/dlls/d3d9/volume.c
+++ b/dlls/d3d9/volume.c
@@ -60,7 +60,7 @@ static ULONG WINAPI d3d9_volume_AddRef(IDirect3DVolume9 *iface)
         return IUnknown_AddRef(volume->forwardReference);
     }
 
-    refcount = InterlockedIncrement(&volume->refcount);
+    refcount = InterlockedIncrement(&volume->resource.refcount);
     TRACE("%p increasing refcount to %u.\n", iface, refcount);
 
     if (refcount == 1)
@@ -86,7 +86,7 @@ static ULONG WINAPI d3d9_volume_Release(IDirect3DVolume9 *iface)
         return IUnknown_Release(volume->forwardReference);
     }
 
-    refcount = InterlockedDecrement(&volume->refcount);
+    refcount = InterlockedDecrement(&volume->resource.refcount);
     TRACE("%p decreasing refcount to %u.\n", iface, refcount);
 
     if (!refcount)
@@ -123,52 +123,28 @@ static HRESULT WINAPI d3d9_volume_SetPrivateData(IDirect3DVolume9 *iface, REFGUI
         const void *data, DWORD data_size, DWORD flags)
 {
     struct d3d9_volume *volume = impl_from_IDirect3DVolume9(iface);
-    struct wined3d_resource *resource;
-    HRESULT hr;
-
     TRACE("iface %p, guid %s, data %p, data_size %u, flags %#x.\n",
             iface, debugstr_guid(guid), data, data_size, flags);
 
-    wined3d_mutex_lock();
-    resource = wined3d_volume_get_resource(volume->wined3d_volume);
-    hr = wined3d_resource_set_private_data(resource, guid, data, data_size, flags);
-    wined3d_mutex_unlock();
-
-    return hr;
+    return d3d9_resource_set_private_data(&volume->resource, guid, data, data_size, flags);
 }
 
 static HRESULT WINAPI d3d9_volume_GetPrivateData(IDirect3DVolume9 *iface, REFGUID guid,
         void *data, DWORD *data_size)
 {
     struct d3d9_volume *volume = impl_from_IDirect3DVolume9(iface);
-    struct wined3d_resource *resource;
-    HRESULT hr;
-
     TRACE("iface %p, guid %s, data %p, data_size %p.\n",
             iface, debugstr_guid(guid), data, data_size);
 
-    wined3d_mutex_lock();
-    resource = wined3d_volume_get_resource(volume->wined3d_volume);
-    hr = wined3d_resource_get_private_data(resource, guid, data, data_size);
-    wined3d_mutex_unlock();
-
-    return hr;
+    return d3d9_resource_get_private_data(&volume->resource, guid, data, data_size);
 }
 
 static HRESULT WINAPI d3d9_volume_FreePrivateData(IDirect3DVolume9 *iface, REFGUID guid)
 {
     struct d3d9_volume *volume = impl_from_IDirect3DVolume9(iface);
-    struct wined3d_resource *resource;
-    HRESULT hr;
-
     TRACE("iface %p, guid %s.\n", iface, debugstr_guid(guid));
 
-    wined3d_mutex_lock();
-    resource = wined3d_volume_get_resource(volume->wined3d_volume);
-    hr = wined3d_resource_free_private_data(resource, guid);
-    wined3d_mutex_unlock();
-
-    return hr;
+    return d3d9_resource_free_private_data(&volume->resource, guid);
 }
 
 static HRESULT WINAPI d3d9_volume_GetContainer(IDirect3DVolume9 *iface, REFIID riid, void **container)
@@ -266,7 +242,9 @@ static const struct IDirect3DVolume9Vtbl d3d9_volume_vtbl =
 
 static void STDMETHODCALLTYPE volume_wined3d_object_destroyed(void *parent)
 {
-    HeapFree(GetProcessHeap(), 0, parent);
+    struct d3d9_volume *volume = parent;
+    d3d9_resource_cleanup(&volume->resource);
+    HeapFree(GetProcessHeap(), 0, volume);
 }
 
 static const struct wined3d_parent_ops d3d9_volume_wined3d_parent_ops =
@@ -278,7 +256,7 @@ void volume_init(struct d3d9_volume *volume, struct wined3d_volume *wined3d_volu
         const struct wined3d_parent_ops **parent_ops)
 {
     volume->IDirect3DVolume9_iface.lpVtbl = &d3d9_volume_vtbl;
-    volume->refcount = 1;
+    d3d9_resource_init(&volume->resource);
     wined3d_volume_incref(wined3d_volume);
     volume->wined3d_volume = wined3d_volume;
 
diff --git a/dlls/dbghelp/dwarf.c b/dlls/dbghelp/dwarf.c
index 159f9bb..e7c36b0 100644
--- a/dlls/dbghelp/dwarf.c
+++ b/dlls/dbghelp/dwarf.c
@@ -1440,6 +1440,9 @@ static struct symt* dwarf2_parse_udt_type(dwarf2_parse_context_t* ctx,
 
         switch (child->abbrev->tag)
         {
+        case DW_TAG_array_type:
+            dwarf2_parse_array_type(ctx, di);
+            break;
         case DW_TAG_member:
             /* FIXME: should I follow the sibling stuff ?? */
             dwarf2_parse_udt_member(ctx, child, (struct symt_udt*)di->symt);
@@ -1710,7 +1713,10 @@ static void dwarf2_parse_subprogram_label(dwarf2_subprogram_t* subpgm,
 
 static void dwarf2_parse_subprogram_block(dwarf2_subprogram_t* subpgm,
                                           struct symt_block* parent_block,
-					  dwarf2_debug_info_t* di);
+                      dwarf2_debug_info_t* di);
+
+static struct symt* dwarf2_parse_subroutine_type(dwarf2_parse_context_t* ctx,
+                                                 dwarf2_debug_info_t* di);
 
 static void dwarf2_parse_inlined_subroutine(dwarf2_subprogram_t* subpgm,
                                             struct symt_block* parent_block,
@@ -1801,6 +1807,12 @@ static void dwarf2_parse_subprogram_block(dwarf2_subprogram_t* subpgm,
         case DW_TAG_variable:
             dwarf2_parse_variable(subpgm, block, child);
             break;
+        case DW_TAG_pointer_type:
+            dwarf2_parse_pointer_type(subpgm->ctx, di);
+            break;
+        case DW_TAG_subroutine_type:
+            dwarf2_parse_subroutine_type(subpgm->ctx, di);
+            break;
         case DW_TAG_lexical_block:
             dwarf2_parse_subprogram_block(subpgm, block, child);
             break;
@@ -1930,6 +1942,9 @@ static struct symt* dwarf2_parse_subprogram(dwarf2_parse_context_t* ctx,
         case DW_TAG_inlined_subroutine:
             dwarf2_parse_inlined_subroutine(&subpgm, NULL, child);
             break;
+        case DW_TAG_pointer_type:
+            dwarf2_parse_pointer_type(subpgm.ctx, di);
+            break;
         case DW_TAG_subprogram:
             /* FIXME: likely a declaration (to be checked)
              * skip it for now
diff --git a/dlls/ddraw/surface.c b/dlls/ddraw/surface.c
index 5cfec01..ea0e968 100644
--- a/dlls/ddraw/surface.c
+++ b/dlls/ddraw/surface.c
@@ -6041,6 +6041,10 @@ HRESULT ddraw_surface_init(struct ddraw_surface *surface, struct ddraw *ddraw, s
     struct wined3d_resource_desc wined3d_desc;
     unsigned int version = texture->version;
     HRESULT hr;
+    UINT row_pitch, slice_pitch;
+    struct wined3d_resource *resource = wined3d_surface_get_resource(wined3d_surface);
+
+    wined3d_resource_get_pitch(resource, &row_pitch, &slice_pitch);
 
     surface->IDirectDrawSurface7_iface.lpVtbl = &ddraw_surface7_vtbl;
     surface->IDirectDrawSurface4_iface.lpVtbl = &ddraw_surface4_vtbl;
@@ -6071,7 +6075,7 @@ HRESULT ddraw_surface_init(struct ddraw_surface *surface, struct ddraw *ddraw, s
     }
 
     *desc = texture->surface_desc;
-    wined3d_resource_get_desc(wined3d_surface_get_resource(wined3d_surface), &wined3d_desc);
+    wined3d_resource_get_desc(resource, &wined3d_desc);
     desc->dwWidth = wined3d_desc.width;
     desc->dwHeight = wined3d_desc.height;
     surface->first_attached = surface;
@@ -6091,12 +6095,12 @@ HRESULT ddraw_surface_init(struct ddraw_surface *surface, struct ddraw *ddraw, s
     else if (!(desc->dwFlags & DDSD_LPSURFACE))
     {
         desc->dwFlags |= DDSD_PITCH;
-        desc->u1.lPitch = wined3d_surface_get_pitch(wined3d_surface);
+        desc->u1.lPitch = row_pitch;
     }
 
     if (desc->dwFlags & DDSD_LPSURFACE)
     {
-        if (desc->u1.lPitch < wined3d_surface_get_pitch(wined3d_surface) || desc->u1.lPitch & 3)
+        if (desc->u1.lPitch < row_pitch || desc->u1.lPitch & 3)
         {
             WARN("Invalid pitch %u specified.\n", desc->u1.lPitch);
             return DDERR_INVALIDPARAMS;
diff --git a/dlls/dplayx/dplayx_global.c b/dlls/dplayx/dplayx_global.c
index 55a7386..f68cad0 100644
--- a/dlls/dplayx/dplayx_global.c
+++ b/dlls/dplayx/dplayx_global.c
@@ -84,8 +84,9 @@ static LPVOID lpSharedStaticData = NULL;
 typedef struct
 {
   BOOL used;
-  DWORD data[dwBlockSize-sizeof(DWORD)];
+  BYTE data[dwBlockSize - sizeof(BOOL)];
 } DPLAYX_MEM_SLICE;
+C_ASSERT(sizeof(DPLAYX_MEM_SLICE) == dwBlockSize);
 
 static DPLAYX_MEM_SLICE* lpMemArea;
 
@@ -100,7 +101,7 @@ static void DPLAYX_PrivHeapFree( LPVOID addr )
     return;
   }
 
-  lpAddrStart = (char*)addr - sizeof(DWORD); /* Find block header */
+  lpAddrStart = CONTAINING_RECORD(addr, DPLAYX_MEM_SLICE, data); /* Find block header */
   dwBlockUsed =  ((BYTE*)lpAddrStart - (BYTE*)lpMemArea)/dwBlockSize;
 
   lpMemArea[ dwBlockUsed ].used = FALSE;
@@ -111,10 +112,10 @@ static LPVOID DPLAYX_PrivHeapAlloc( DWORD flags, DWORD size )
   LPVOID lpvArea = NULL;
   UINT   uBlockUsed;
 
-  if( size > (dwBlockSize - sizeof(DWORD)) )
+  if( size > (dwBlockSize - sizeof(BOOL)) )
   {
     FIXME( "Size exceeded. Request of 0x%08x\n", size );
-    size = dwBlockSize - sizeof(DWORD);
+    size = dwBlockSize - sizeof(BOOL);
   }
 
   /* Find blank area */
diff --git a/dlls/dxdiagn/provider.c b/dlls/dxdiagn/provider.c
index 76bbcf0..451270c 100644
--- a/dlls/dxdiagn/provider.c
+++ b/dlls/dxdiagn/provider.c
@@ -915,10 +915,15 @@ static HRESULT fill_display_information_d3d(IDxDiagContainerImpl_Container *node
         static const WCHAR id_fmtW[] = {'0','x','%','0','4','x',0};
         static const WCHAR subsysid_fmtW[] = {'0','x','%','0','8','x',0};
         static const WCHAR mem_fmt[] = {'%','.','1','f',' ','M','B',0};
+        static const WCHAR b3DAccelerationExists[] = {'b','3','D','A','c','c','e','l','e','r','a','t','i','o','n','E','x','i','s','t','s',0};
+        static const WCHAR b3DAccelerationEnabled[] = {'b','3','D','A','c','c','e','l','e','r','a','t','i','o','n','E','n','a','b','l','e','d',0};
+        static const WCHAR bDDAccelerationEnabled[] = {'b','D','D','A','c','c','e','l','e','r','a','t','i','o','n','E','n','a','b','l','e','d',0};
 
         D3DADAPTER_IDENTIFIER9 adapter_info;
         D3DDISPLAYMODE adapter_mode;
+        D3DCAPS9 device_caps;
         DWORD available_mem = 0;
+        BOOL hardware_accel;
 
         snprintfW(buffer, sizeof(buffer)/sizeof(WCHAR), adapterid_fmtW, index);
         display_adapter = allocate_information_node(buffer);
@@ -1043,6 +1048,21 @@ static HRESULT fill_display_information_d3d(IDxDiagContainerImpl_Container *node
         hr = add_bstr_property(display_adapter, szDisplayMemoryEnglish, buffer);
         if (FAILED(hr))
             goto cleanup;
+
+        hr = IDirect3D9_GetDeviceCaps(pDirect3D9, index, D3DDEVTYPE_HAL, &device_caps);
+        hardware_accel = SUCCEEDED(hr);
+
+        hr = add_bool_property(display_adapter, b3DAccelerationEnabled, hardware_accel);
+        if (FAILED(hr))
+            goto cleanup;
+
+        hr = add_bool_property(display_adapter, b3DAccelerationExists, hardware_accel);
+        if (FAILED(hr))
+            goto cleanup;
+
+        hr = add_bool_property(display_adapter, bDDAccelerationEnabled, hardware_accel);
+        if (FAILED(hr))
+            goto cleanup;
     }
 
     hr = S_OK;
diff --git a/dlls/dxdiagn/tests/container.c b/dlls/dxdiagn/tests/container.c
index 9959665..ce0fb77 100644
--- a/dlls/dxdiagn/tests/container.c
+++ b/dlls/dxdiagn/tests/container.c
@@ -938,6 +938,9 @@ static void test_DxDiag_DisplayDevices(void)
     static const WCHAR szRevisionId[] = {'s','z','R','e','v','i','s','i','o','n','I','d',0};
     static const WCHAR dwRefreshRate[] = {'d','w','R','e','f','r','e','s','h','R','a','t','e',0};
     static const WCHAR szManufacturer[] = {'s','z','M','a','n','u','f','a','c','t','u','r','e','r',0};
+    static const WCHAR b3DAccelerationExists[] = {'b','3','D','A','c','c','e','l','e','r','a','t','i','o','n','E','x','i','s','t','s',0};
+    static const WCHAR b3DAccelerationEnabled[] = {'b','3','D','A','c','c','e','l','e','r','a','t','i','o','n','E','n','a','b','l','e','d',0};
+    static const WCHAR bDDAccelerationEnabled[] = {'b','D','D','A','c','c','e','l','e','r','a','t','i','o','n','E','n','a','b','l','e','d',0};
 
     static const struct property_test property_tests[] =
     {
@@ -959,6 +962,9 @@ static void test_DxDiag_DisplayDevices(void)
         {szRevisionId, VT_BSTR},
         {dwRefreshRate, VT_UI4},
         {szManufacturer, VT_BSTR},
+        {b3DAccelerationExists, VT_BOOL},
+        {b3DAccelerationEnabled, VT_BOOL},
+        {bDDAccelerationEnabled, VT_BOOL},
     };
 
     IDxDiagContainer *display_cont = NULL;
diff --git a/dlls/dxva2/Makefile.in b/dlls/dxva2/Makefile.in
new file mode 100644
index 0000000..7b9ef6f
--- /dev/null
+++ b/dlls/dxva2/Makefile.in
@@ -0,0 +1,4 @@
+MODULE = dxva2.dll
+
+C_SRCS = \
+	main.c
diff --git a/dlls/dxva2/dxva2.spec b/dlls/dxva2/dxva2.spec
new file mode 100644
index 0000000..da94df3
--- /dev/null
+++ b/dlls/dxva2/dxva2.spec
@@ -0,0 +1,37 @@
+@ stub CapabilitiesRequestAndCapabilitiesReply
+@ stub DXVA2CreateDirect3DDeviceManager9
+@ stub DXVA2CreateVideoService
+@ stub DegaussMonitor
+@ stub DestroyPhysicalMonitor
+@ stub DestroyPhysicalMonitors
+@ stub GetCapabilitiesStringLength
+@ stub GetMonitorBrightness
+@ stub GetMonitorCapabilities
+@ stub GetMonitorColorTemperature
+@ stub GetMonitorContrast
+@ stub GetMonitorDisplayAreaPosition
+@ stub GetMonitorDisplayAreaSize
+@ stub GetMonitorRedGreenOrBlueDrive
+@ stub GetMonitorRedGreenOrBlueGain
+@ stub GetMonitorTechnologyType
+@ stub GetNumberOfPhysicalMonitorsFromHMONITOR
+@ stub GetNumberOfPhysicalMonitorsFromIDirect3DDevice9
+@ stub GetPhysicalMonitorsFromHMONITOR
+@ stub GetPhysicalMonitorsFromIDirect3DDevice9
+@ stub GetTimingReport
+@ stub GetVCPFeatureAndVCPFeatureReply
+@ stub OPMGetVideoOutputsFromHMONITOR
+@ stub OPMGetVideoOutputsFromIDirect3DDevice9Object
+@ stub RestoreMonitorFactoryColorDefaults
+@ stub RestoreMonitorFactoryDefaults
+@ stub SaveCurrentMonitorSettings
+@ stub SaveCurrentSettings
+@ stub SetMonitorBrightness
+@ stub SetMonitorColorTemperature
+@ stub SetMonitorContrast
+@ stub SetMonitorDisplayAreaPosition
+@ stub SetMonitorDisplayAreaSize
+@ stub SetMonitorRedGreenOrBlueDrive
+@ stub SetMonitorRedGreenOrBlueGain
+@ stub SetVCPFeature
+@ stub UABGetCertificate
diff --git a/dlls/dxva2/main.c b/dlls/dxva2/main.c
new file mode 100644
index 0000000..d16320f
--- /dev/null
+++ b/dlls/dxva2/main.c
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2014 Michael Müller for Pipelight
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include <stdarg.h>
+#include "windef.h"
+#include "winbase.h"
+
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(dxva2);
+
+BOOL WINAPI DllMain (HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
+{
+    TRACE("%p,%x,%p\n", hinstDLL, fdwReason, lpvReserved);
+
+    switch (fdwReason) {
+        case DLL_WINE_PREATTACH:
+            return FALSE;  /* prefer native version */
+        case DLL_PROCESS_ATTACH:
+            DisableThreadLibraryCalls(hinstDLL);
+            break;
+    }
+
+    return TRUE;
+}
diff --git a/dlls/gameux/tests/gamestatistics.c b/dlls/gameux/tests/gamestatistics.c
index 7d57b1f..f5dd2ab 100644
--- a/dlls/gameux/tests/gamestatistics.c
+++ b/dlls/gameux/tests/gamestatistics.c
@@ -130,15 +130,13 @@ static HRESULT _buildStatisticsFilePath(LPCGUID guidApplicationId, LPWSTR *lpSta
             'l','o','r','e','r','\\','G','a','m','e','S','t','a','t','i','s',
             't','i','c','s','\\',0};
     static const WCHAR sDotGamestats[] = {'.','g','a','m','e','s','t','a','t','s',0};
-    static const DWORD dwGuidLength = 49;
-
     HRESULT hr;
-    WCHAR sGuid[dwGuidLength], sPath[MAX_PATH] = {0};
+    WCHAR sGuid[49], sPath[MAX_PATH];
 
     hr = pSHGetFolderPathW(NULL, CSIDL_LOCAL_APPDATA, NULL, SHGFP_TYPE_CURRENT, sPath);
 
     if(SUCCEEDED(hr))
-        hr = (StringFromGUID2(guidApplicationId, sGuid, dwGuidLength)!=0 ? S_OK : E_FAIL);
+        hr = (StringFromGUID2(guidApplicationId, sGuid, sizeof(sGuid) / sizeof(sGuid[0])) != 0 ? S_OK : E_FAIL);
 
     if(SUCCEEDED(hr))
     {
diff --git a/dlls/gdi32/bidi.c b/dlls/gdi32/bidi.c
index 1d6be53..066eec3 100644
--- a/dlls/gdi32/bidi.c
+++ b/dlls/gdi32/bidi.c
@@ -596,10 +596,25 @@ BOOL BIDI_Reorder(
 
         if (lpGlyphs && doGlyphs)
         {
-            BYTE runOrder[maxItems];
-            int visOrder[maxItems];
+            BYTE *runOrder;
+            int *visOrder;
             SCRIPT_ITEM *curItem;
 
+            runOrder = HeapAlloc(GetProcessHeap(), 0, maxItems * sizeof(*runOrder));
+            visOrder = HeapAlloc(GetProcessHeap(), 0, maxItems * sizeof(*visOrder));
+            if (!runOrder || !visOrder)
+            {
+                WARN("Out of memory\n");
+                HeapFree(GetProcessHeap(), 0, runOrder);
+                HeapFree(GetProcessHeap(), 0, visOrder);
+                HeapFree(GetProcessHeap(), 0, chartype);
+                HeapFree(GetProcessHeap(), 0, levels);
+                HeapFree(GetProcessHeap(), 0, pItems);
+                HeapFree(GetProcessHeap(), 0, psva);
+                HeapFree(GetProcessHeap(), 0, pwLogClust);
+                return FALSE;
+            }
+
             for (j = 0; j < nItems; j++)
                 runOrder[j] = pItems[j].a.s.uBidiLevel;
 
@@ -621,6 +636,8 @@ BOOL BIDI_Reorder(
                     if (!run_glyphs)
                     {
                         WARN("Out of memory\n");
+                        HeapFree(GetProcessHeap(), 0, runOrder);
+                        HeapFree(GetProcessHeap(), 0, visOrder);
                         HeapFree(GetProcessHeap(), 0, chartype);
                         HeapFree(GetProcessHeap(), 0, levels);
                         HeapFree(GetProcessHeap(), 0, pItems);
@@ -655,6 +672,8 @@ BOOL BIDI_Reorder(
                     glyph_i += cOutGlyphs;
                 }
             }
+            HeapFree(GetProcessHeap(), 0, runOrder);
+            HeapFree(GetProcessHeap(), 0, visOrder);
         }
 
         done += i;
diff --git a/dlls/gdiplus/brush.c b/dlls/gdiplus/brush.c
index 2b49b64..38e8dc2 100644
--- a/dlls/gdiplus/brush.c
+++ b/dlls/gdiplus/brush.c
@@ -745,8 +745,6 @@ GpStatus WINGDIPAPI GdipCreateTexture2(GpImage *image, GpWrapMode wrapmode,
 
 /******************************************************************************
  * GdipCreateTextureIA [GDIPLUS.@]
- *
- * FIXME: imageattr ignored
  */
 GpStatus WINGDIPAPI GdipCreateTextureIA(GpImage *image,
     GDIPCONST GpImageAttributes *imageattr, REAL x, REAL y, REAL width,
@@ -844,6 +842,7 @@ GpStatus WINGDIPAPI GdipCreateTexture2I(GpImage *image, GpWrapMode wrapmode,
         imageattr->wrap = wrapmode;
 
         stat = GdipCreateTextureIA(image, imageattr, x, y, width, height, texture);
+        GdipDisposeImageAttributes(imageattr);
     }
 
     return stat;
diff --git a/dlls/gdiplus/graphics.c b/dlls/gdiplus/graphics.c
index e3bf98e..56d785e 100644
--- a/dlls/gdiplus/graphics.c
+++ b/dlls/gdiplus/graphics.c
@@ -2858,6 +2858,7 @@ GpStatus WINGDIPAPI GdipDrawImagePointsRect(GpGraphics *graphics, GpImage *image
         if (use_software)
         {
             RECT dst_area;
+            GpRectF graphics_bounds;
             GpRect src_area;
             int i, x, y, src_stride, dst_stride;
             GpMatrix dst_to_src;
@@ -2883,8 +2884,18 @@ GpStatus WINGDIPAPI GdipDrawImagePointsRect(GpGraphics *graphics, GpImage *image
                 if (dst_area.bottom < pti[i].y) dst_area.bottom = pti[i].y;
             }
 
+            stat = get_graphics_bounds(graphics, &graphics_bounds);
+            if (stat != Ok) return stat;
+
+            if (graphics_bounds.X > dst_area.left) dst_area.left = floorf(graphics_bounds.X);
+            if (graphics_bounds.Y > dst_area.top) dst_area.top = floorf(graphics_bounds.Y);
+            if (graphics_bounds.X + graphics_bounds.Width < dst_area.right) dst_area.right = ceilf(graphics_bounds.X + graphics_bounds.Width);
+            if (graphics_bounds.Y + graphics_bounds.Height < dst_area.bottom) dst_area.bottom = ceilf(graphics_bounds.Y + graphics_bounds.Height);
+
             TRACE("dst_area: %s\n", wine_dbgstr_rect(&dst_area));
 
+            if (IsRectEmpty(&dst_area)) return Ok;
+
             m11 = (ptf[1].X - ptf[0].X) / srcwidth;
             m21 = (ptf[2].X - ptf[0].X) / srcheight;
             mdx = ptf[0].X - m11 * srcx - m21 * srcy;
@@ -2930,8 +2941,7 @@ GpStatus WINGDIPAPI GdipDrawImagePointsRect(GpGraphics *graphics, GpImage *image
 
             if (stat != Ok)
             {
-                if (src_data != dst_data)
-                    GdipFree(src_data);
+                GdipFree(src_data);
                 GdipFree(dst_data);
                 return stat;
             }
diff --git a/dlls/gdiplus/image.c b/dlls/gdiplus/image.c
index f734274..20098ca 100644
--- a/dlls/gdiplus/image.c
+++ b/dlls/gdiplus/image.c
@@ -1252,6 +1252,28 @@ GpStatus WINGDIPAPI GdipCloneBitmapArea(REAL x, REAL y, REAL width, REAL height,
                               srcBitmap->stride,
                               srcBitmap->bits + srcBitmap->stride * area.Y + PIXELFORMATBPP(srcBitmap->format) * area.X / 8,
                               srcBitmap->format, srcBitmap->image.palette);
+
+        if (stat == Ok && srcBitmap->image.palette)
+        {
+            ColorPalette *src_palette, *dst_palette;
+
+            src_palette = srcBitmap->image.palette;
+
+            dst_palette = GdipAlloc(sizeof(UINT) * 2 + sizeof(ARGB) * src_palette->Count);
+
+            if (dst_palette)
+            {
+                dst_palette->Flags = src_palette->Flags;
+                dst_palette->Count = src_palette->Count;
+                memcpy(dst_palette->Entries, src_palette->Entries, sizeof(ARGB) * src_palette->Count);
+
+                GdipFree((*dstBitmap)->image.palette);
+                (*dstBitmap)->image.palette = dst_palette;
+            }
+            else
+                stat = OutOfMemory;
+        }
+
         if (stat != Ok)
             GdipDisposeImage((GpImage*)*dstBitmap);
     }
diff --git a/dlls/kernel32/kernel32.spec b/dlls/kernel32/kernel32.spec
index 3126628..b24a9ee 100644
--- a/dlls/kernel32/kernel32.spec
+++ b/dlls/kernel32/kernel32.spec
@@ -1191,6 +1191,7 @@
 @ stub SetVolumeMountPointA
 @ stub SetVolumeMountPointW
 @ stdcall SetWaitableTimer(long ptr long ptr ptr long)
+@ stdcall SetWaitableTimerEx(long ptr long ptr ptr ptr long)
 @ stdcall SetupComm(long long long)
 @ stub ShowConsoleCursor
 @ stdcall SignalObjectAndWait(long long long long)
diff --git a/dlls/kernel32/sync.c b/dlls/kernel32/sync.c
index 0f44240..6c452a4 100644
--- a/dlls/kernel32/sync.c
+++ b/dlls/kernel32/sync.c
@@ -1177,6 +1177,16 @@ BOOL WINAPI SetWaitableTimer( HANDLE handle, const LARGE_INTEGER *when, LONG per
     return TRUE;
 }
 
+/***********************************************************************
+ *           SetWaitableTimerEx    (KERNEL32.@)
+ */
+BOOL WINAPI SetWaitableTimerEx( HANDLE handle, const LARGE_INTEGER *when, LONG period,
+                              PTIMERAPCROUTINE callback, LPVOID arg, REASON_CONTEXT *context, ULONG tolerabledelay )
+{
+    FIXME("(%p, %p, %d, %p, %p, %p, %d) semi-stub\n",
+          handle, when, period, callback, arg, context, tolerabledelay);
+    return SetWaitableTimer(handle, when, period, callback, arg, FALSE);
+}
 
 /***********************************************************************
  *           CancelWaitableTimer    (KERNEL32.@)
diff --git a/dlls/kernel32/tests/Makefile.in b/dlls/kernel32/tests/Makefile.in
index 1951d83..2f2ac5f 100644
--- a/dlls/kernel32/tests/Makefile.in
+++ b/dlls/kernel32/tests/Makefile.in
@@ -3,7 +3,6 @@ IMPORTS   = user32 advapi32
 
 C_SRCS = \
 	actctx.c \
-	alloc.c \
 	atom.c \
 	change.c \
 	codepage.c \
diff --git a/dlls/kernel32/tests/alloc.c b/dlls/kernel32/tests/alloc.c
deleted file mode 100644
index 05d262e..0000000
--- a/dlls/kernel32/tests/alloc.c
+++ /dev/null
@@ -1,403 +0,0 @@
-/*
- * Unit test suite for memory allocation functions.
- *
- * Copyright 2002 Geoffrey Hausheer
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-#include <stdarg.h>
-
-#include "wine/test.h"
-#include "windef.h"
-#include "winbase.h"
-#include "winerror.h"
-
-
- /* The following functions don't have tests, because either I don't know how
-   to test them, or they are WinNT only, or require multiple threads.
-   Since the last two issues shouldn't really stop the tests from being
-   written, assume for now that it is all due to the first case
-       HeapCompact
-       HeapLock
-       HeapQueryInformation
-       HeapSetInformation
-       HeapUnlock
-       HeapValidate
-       HeapWalk
-*/
-/* In addition, these features aren't being tested
-       HEAP_NO_SERIALIZE
-       HEAP_GENERATE_EXCEPTIONS
-       STATUS_ACCESS_VIOLATION (error code from HeapAlloc)
-*/
-
-static void test_Heap(void)
-{
-    SYSTEM_INFO sysInfo;
-    ULONG memchunk;
-    HANDLE heap;
-    LPVOID mem1,mem1a,mem3;
-    UCHAR *mem2,*mem2a;
-    UINT i;
-    BOOL error;
-    DWORD dwSize;
-
-/* Retrieve the page size for this system */
-    sysInfo.dwPageSize=0;
-    GetSystemInfo(&sysInfo);
-    ok(sysInfo.dwPageSize>0,"GetSystemInfo should return a valid page size\n");
-
-/* Create a Heap with a minimum and maximum size */
-/* Note that Windows and Wine seem to behave a bit differently with respect
-   to memory allocation.  In Windows, you can't access all the memory
-   specified in the heap (due to overhead), so choosing a reasonable maximum
-   size for the heap was done mostly by trial-and-error on Win2k.  It may need
-   more tweaking for otherWindows variants.
-*/
-    memchunk=10*sysInfo.dwPageSize;
-    heap=HeapCreate(0,2*memchunk,5*memchunk);
-
-/* Check that HeapCreate allocated the right amount of ram */
-    mem1=HeapAlloc(heap,0,5*memchunk+1);
-    ok(mem1==NULL,"HeapCreate allocated more Ram than it should have\n");
-    HeapFree(heap,0,mem1);
-
-/* Check that a normal alloc works */
-    mem1=HeapAlloc(heap,0,memchunk);
-    ok(mem1!=NULL,"HeapAlloc failed\n");
-    if(mem1) {
-      ok(HeapSize(heap,0,mem1)>=memchunk, "HeapAlloc should return a big enough memory block\n");
-    }
-
-/* Check that a 'zeroing' alloc works */
-    mem2=HeapAlloc(heap,HEAP_ZERO_MEMORY,memchunk);
-    ok(mem2!=NULL,"HeapAlloc failed\n");
-    if(mem2) {
-      ok(HeapSize(heap,0,mem2)>=memchunk,"HeapAlloc should return a big enough memory block\n");
-      error=FALSE;
-      for(i=0;i<memchunk;i++) {
-        if(mem2[i]!=0) {
-          error=TRUE;
-        }
-      }
-      ok(!error,"HeapAlloc should have zeroed out its allocated memory\n");
-    }
-
-/* Check that HeapAlloc returns NULL when requested way too much memory */
-    mem3=HeapAlloc(heap,0,5*memchunk);
-    ok(mem3==NULL,"HeapAlloc should return NULL\n");
-    if(mem3) {
-      ok(HeapFree(heap,0,mem3),"HeapFree didn't pass successfully\n");
-    }
-
-/* Check that HeapRealloc works */
-    mem2a=HeapReAlloc(heap,HEAP_ZERO_MEMORY,mem2,memchunk+5*sysInfo.dwPageSize);
-    ok(mem2a!=NULL,"HeapReAlloc failed\n");
-    if(mem2a) {
-      ok(HeapSize(heap,0,mem2a)>=memchunk+5*sysInfo.dwPageSize,"HeapReAlloc failed\n");
-      error=FALSE;
-      for(i=0;i<5*sysInfo.dwPageSize;i++) {
-        if(mem2a[memchunk+i]!=0) {
-          error=TRUE;
-        }
-      }
-      ok(!error,"HeapReAlloc should have zeroed out its allocated memory\n");
-    }
-
-/* Check that HeapRealloc honours HEAP_REALLOC_IN_PLACE_ONLY */
-    error=FALSE;
-    mem1a=HeapReAlloc(heap,HEAP_REALLOC_IN_PLACE_ONLY,mem1,memchunk+sysInfo.dwPageSize);
-    if(mem1a!=NULL) {
-      if(mem1a!=mem1) {
-        error=TRUE;
-      }
-    }
-    ok(mem1a==NULL || !error,"HeapReAlloc didn't honour HEAP_REALLOC_IN_PLACE_ONLY\n");
-
-/* Check that HeapFree works correctly */
-   if(mem1a) {
-     ok(HeapFree(heap,0,mem1a),"HeapFree failed\n");
-   } else {
-     ok(HeapFree(heap,0,mem1),"HeapFree failed\n");
-   }
-   if(mem2a) {
-     ok(HeapFree(heap,0,mem2a),"HeapFree failed\n");
-   } else {
-     ok(HeapFree(heap,0,mem2),"HeapFree failed\n");
-   }
-
-   /* 0-length buffer */
-   mem1 = HeapAlloc(heap, 0, 0);
-   ok(mem1 != NULL, "Reserved memory\n");
-
-   dwSize = HeapSize(heap, 0, mem1);
-   /* should work with 0-length buffer */
-   ok(dwSize < 0xFFFFFFFF, "The size of the 0-length buffer\n");
-   ok(HeapFree(heap, 0, mem1), "Freed the 0-length buffer\n");
-
-/* Check that HeapDestry works */
-   ok(HeapDestroy(heap),"HeapDestroy failed\n");
-}
-
-/* The following functions don't have tests, because either I don't know how
-   to test them, or they are WinNT only, or require multiple threads.
-   Since the last two issues shouldn't really stop the tests from being
-   written, assume for now that it is all due to the first case
-       GlobalFlags
-       GlobalMemoryStatus
-       GlobalMemoryStatusEx
-*/
-/* In addition, these features aren't being tested
-       GMEM_DISCARDABLE
-       GMEM_NOCOMPACT
-*/
-static void test_Global(void)
-{
-    ULONG memchunk;
-    HGLOBAL mem1,mem2,mem2a,mem2b;
-    UCHAR *mem2ptr;
-    UINT i;
-    BOOL error;
-    memchunk=100000;
-
-    SetLastError(NO_ERROR);
-/* Check that a normal alloc works */
-    mem1=GlobalAlloc(0,memchunk);
-    ok(mem1!=NULL,"GlobalAlloc failed\n");
-    if(mem1) {
-      ok(GlobalSize(mem1)>=memchunk, "GlobalAlloc should return a big enough memory block\n");
-    }
-
-/* Check that a 'zeroing' alloc works */
-    mem2=GlobalAlloc(GMEM_ZEROINIT,memchunk);
-    ok(mem2!=NULL,"GlobalAlloc failed: error=%d\n",GetLastError());
-    if(mem2) {
-      ok(GlobalSize(mem2)>=memchunk,"GlobalAlloc should return a big enough memory block\n");
-      mem2ptr=GlobalLock(mem2);
-      ok(mem2ptr==mem2,"GlobalLock should have returned the same memory as was allocated\n");
-      if(mem2ptr) {
-        error=FALSE;
-        for(i=0;i<memchunk;i++) {
-          if(mem2ptr[i]!=0) {
-            error=TRUE;
-          }
-        }
-        ok(!error,"GlobalAlloc should have zeroed out its allocated memory\n");
-      }
-   }
-/* Check that GlobalReAlloc works */
-/* Check that we can change GMEM_FIXED to GMEM_MOVEABLE */
-    mem2a=GlobalReAlloc(mem2,0,GMEM_MODIFY | GMEM_MOVEABLE);
-    if(mem2a!=NULL) {
-      mem2=mem2a;
-      mem2ptr=GlobalLock(mem2a);
-      ok(mem2ptr!=NULL && !GlobalUnlock(mem2a)&&GetLastError()==NO_ERROR,
-         "Converting from FIXED to MOVEABLE didn't REALLY work\n");
-    }
-
-/* Check that ReAllocing memory works as expected */
-    mem2a=GlobalReAlloc(mem2,2*memchunk,GMEM_MOVEABLE | GMEM_ZEROINIT);
-    ok(mem2a!=NULL,"GlobalReAlloc failed\n");
-    if(mem2a) {
-      ok(GlobalSize(mem2a)>=2*memchunk,"GlobalReAlloc failed\n");
-      mem2ptr=GlobalLock(mem2a);
-      ok(mem2ptr!=NULL,"GlobalLock Failed\n");
-      if(mem2ptr) {
-        error=FALSE;
-        for(i=0;i<memchunk;i++) {
-          if(mem2ptr[memchunk+i]!=0) {
-            error=TRUE;
-          }
-        }
-        ok(!error,"GlobalReAlloc should have zeroed out its allocated memory\n");
-
-/* Check that GlobalHandle works */
-        mem2b=GlobalHandle(mem2ptr);
-        ok(mem2b==mem2a,"GlobalHandle didn't return the correct memory handle\n");
-
-/* Check that we can't discard locked memory */
-        mem2b=GlobalDiscard(mem2a);
-        if(mem2b==NULL) {
-          ok(!GlobalUnlock(mem2a) && GetLastError()==NO_ERROR,"GlobalUnlock Failed\n");
-        }
-      }
-    }
-    if(mem1) {
-      ok(GlobalFree(mem1)==NULL,"GlobalFree failed\n");
-    }
-    if(mem2a) {
-      ok(GlobalFree(mem2a)==NULL,"GlobalFree failed\n");
-    } else {
-      ok(GlobalFree(mem2)==NULL,"GlobalFree failed\n");
-    }
-}
-
-
-/* The following functions don't have tests, because either I don't know how
-   to test them, or they are WinNT only, or require multiple threads.
-   Since the last two issues shouldn't really stop the tests from being
-   written, assume for now that it is all due to the first case
-       LocalDiscard
-       LocalFlags
-*/
-/* In addition, these features aren't being tested
-       LMEM_DISCARDABLE
-       LMEM_NOCOMPACT
-*/
-static void test_Local(void)
-{
-    ULONG memchunk;
-    HLOCAL mem1,mem2,mem2a,mem2b;
-    UCHAR *mem2ptr;
-    UINT i;
-    BOOL error;
-    memchunk=100000;
-
-/* Check that a normal alloc works */
-    mem1=LocalAlloc(0,memchunk);
-    ok(mem1!=NULL,"LocalAlloc failed: error=%d\n",GetLastError());
-    if(mem1) {
-      ok(LocalSize(mem1)>=memchunk, "LocalAlloc should return a big enough memory block\n");
-    }
-
-/* Check that a 'zeroing' and lock alloc works */
-    mem2=LocalAlloc(LMEM_ZEROINIT|LMEM_MOVEABLE,memchunk);
-    ok(mem2!=NULL,"LocalAlloc failed: error=%d\n",GetLastError());
-    if(mem2) {
-      ok(LocalSize(mem2)>=memchunk,"LocalAlloc should return a big enough memory block\n");
-      mem2ptr=LocalLock(mem2);
-      ok(mem2ptr!=NULL,"LocalLock: error=%d\n",GetLastError());
-      if(mem2ptr) {
-        error=FALSE;
-        for(i=0;i<memchunk;i++) {
-          if(mem2ptr[i]!=0) {
-            error=TRUE;
-          }
-        }
-        ok(!error,"LocalAlloc should have zeroed out its allocated memory\n");
-        SetLastError(0);
-        error=LocalUnlock(mem2);
-        ok(!error && GetLastError()==NO_ERROR,
-           "LocalUnlock Failed: rc=%d err=%d\n",error,GetLastError());
-      }
-    }
-   mem2a=LocalFree(mem2);
-   ok(mem2a==NULL, "LocalFree failed: %p\n",mem2a);
-
-/* Reallocate mem2 as moveable memory */
-   mem2=LocalAlloc(LMEM_MOVEABLE | LMEM_ZEROINIT,memchunk);
-   ok(mem2!=NULL, "LocalAlloc failed to create moveable memory, error=%d\n",GetLastError());
-
-/* Check that ReAllocing memory works as expected */
-    mem2a=LocalReAlloc(mem2,2*memchunk,LMEM_MOVEABLE | LMEM_ZEROINIT);
-    ok(mem2a!=NULL,"LocalReAlloc failed, error=%d\n",GetLastError());
-    if(mem2a) {
-      ok(LocalSize(mem2a)>=2*memchunk,"LocalReAlloc failed\n");
-      mem2ptr=LocalLock(mem2a);
-      ok(mem2ptr!=NULL,"LocalLock Failed\n");
-      if(mem2ptr) {
-        error=FALSE;
-        for(i=0;i<memchunk;i++) {
-          if(mem2ptr[memchunk+i]!=0) {
-            error=TRUE;
-          }
-        }
-        ok(!error,"LocalReAlloc should have zeroed out its allocated memory\n");
-/* Check that LocalHandle works */
-        mem2b=LocalHandle(mem2ptr);
-        ok(mem2b==mem2a,"LocalHandle didn't return the correct memory handle\n");
-/* Check that we can't discard locked memory */
-        mem2b=LocalDiscard(mem2a);
-        ok(mem2b==NULL,"Discarded memory we shouldn't have\n");
-        SetLastError(NO_ERROR);
-        ok(!LocalUnlock(mem2a) && GetLastError()==NO_ERROR, "LocalUnlock Failed\n");
-      }
-    }
-    if(mem1) {
-      ok(LocalFree(mem1)==NULL,"LocalFree failed\n");
-    }
-    if(mem2a) {
-      ok(LocalFree(mem2a)==NULL,"LocalFree failed\n");
-    } else {
-      ok(LocalFree(mem2)==NULL,"LocalFree failed\n");
-    }
-}
-
-/* The Virtual* routines are not tested as thoroughly,
-   since I don't really understand how to use them correctly :)
-   The following routines are not tested at all
-      VirtualAllocEx
-      VirtualFreeEx
-      VirtualLock
-      VirtualProtect
-      VirtualProtectEx
-      VirtualQuery
-      VirtualQueryEx
-      VirtualUnlock
-    And the only features (flags) being tested are
-      MEM_COMMIT
-      MEM_RELEASE
-      PAGE_READWRITE
-    Testing the rest requires using exceptions, which I really don't
-    understand well
-*/
-static void test_Virtual(void)
-{
-    SYSTEM_INFO sysInfo;
-    ULONG memchunk;
-    UCHAR *mem1;
-    UINT i;
-    BOOL error;
-
-/* Retrieve the page size for this system */
-    sysInfo.dwPageSize=0;
-    GetSystemInfo(&sysInfo);
-    ok(sysInfo.dwPageSize>0,"GetSystemInfo should return a valid page size\n");
-
-/* Choose a reasonable allocation size */
-    memchunk=10*sysInfo.dwPageSize;
-
-/* Check that a normal alloc works */
-    mem1=VirtualAlloc(NULL,memchunk,MEM_COMMIT,PAGE_READWRITE);
-    ok(mem1!=NULL,"VirtualAlloc failed\n");
-    if(mem1) {
-/* check that memory is initialized to 0 */
-      error=FALSE;
-      for(i=0;i<memchunk;i++) {
-        if(mem1[i]!=0) {
-          error=TRUE;
-        }
-      }
-      ok(!error,"VirtualAlloc did not initialize memory to '0's\n");
-/* Check that we can read/write to memory */
-      error=FALSE;
-      for(i=0;i<memchunk;i+=100) {
-        mem1[i]='a';
-        if(mem1[i]!='a') {
-          error=TRUE;
-        }
-      }
-      ok(!error,"Virtual memory was not writable\n");
-    }
-    ok(VirtualFree(mem1,0,MEM_RELEASE),"VirtualFree failed\n");
-}
-START_TEST(alloc)
-{
-    test_Heap();
-    test_Global();
-    test_Local();
-    test_Virtual();
-}
diff --git a/dlls/kernel32/tests/heap.c b/dlls/kernel32/tests/heap.c
index 111e1f7..a36c373 100644
--- a/dlls/kernel32/tests/heap.c
+++ b/dlls/kernel32/tests/heap.c
@@ -1,6 +1,7 @@
 /*
  * Unit test suite for heap functions
  *
+ * Copyright 2002 Geoffrey Hausheer
  * Copyright 2003 Dimitrie O. Paun
  * Copyright 2006 Detlef Riekenberg
  *
@@ -480,6 +481,278 @@ static void test_heap(void)
 
 }
 
+
+static void test_HeapCreate(void)
+{
+    SYSTEM_INFO sysInfo;
+    ULONG memchunk;
+    HANDLE heap;
+    LPVOID mem1,mem1a,mem3;
+    UCHAR *mem2,*mem2a;
+    UINT i;
+    BOOL error;
+    DWORD dwSize;
+
+    /* Retrieve the page size for this system */
+    GetSystemInfo(&sysInfo);
+    ok(sysInfo.dwPageSize>0,"GetSystemInfo should return a valid page size\n");
+
+    /* Create a Heap with a minimum and maximum size */
+    /* Note that Windows and Wine seem to behave a bit differently with respect
+       to memory allocation.  In Windows, you can't access all the memory
+       specified in the heap (due to overhead), so choosing a reasonable maximum
+       size for the heap was done mostly by trial-and-error on Win2k.  It may need
+       more tweaking for otherWindows variants.
+    */
+    memchunk=10*sysInfo.dwPageSize;
+    heap=HeapCreate(0,2*memchunk,5*memchunk);
+    ok( !((ULONG_PTR)heap & 0xffff), "heap %p not 64K aligned\n", heap );
+
+    /* Check that HeapCreate allocated the right amount of ram */
+    mem1=HeapAlloc(heap,0,5*memchunk+1);
+    ok(mem1==NULL,"HeapCreate allocated more Ram than it should have\n");
+    HeapFree(heap,0,mem1);
+
+    /* Check that a normal alloc works */
+    mem1=HeapAlloc(heap,0,memchunk);
+    ok(mem1!=NULL,"HeapAlloc failed\n");
+    if(mem1) {
+      ok(HeapSize(heap,0,mem1)>=memchunk, "HeapAlloc should return a big enough memory block\n");
+    }
+
+    /* Check that a 'zeroing' alloc works */
+    mem2=HeapAlloc(heap,HEAP_ZERO_MEMORY,memchunk);
+    ok(mem2!=NULL,"HeapAlloc failed\n");
+    if(mem2) {
+      ok(HeapSize(heap,0,mem2)>=memchunk,"HeapAlloc should return a big enough memory block\n");
+      error=FALSE;
+      for(i=0;i<memchunk;i++) {
+        if(mem2[i]!=0) {
+          error=TRUE;
+        }
+      }
+      ok(!error,"HeapAlloc should have zeroed out its allocated memory\n");
+    }
+
+    /* Check that HeapAlloc returns NULL when requested way too much memory */
+    mem3=HeapAlloc(heap,0,5*memchunk);
+    ok(mem3==NULL,"HeapAlloc should return NULL\n");
+    if(mem3) {
+      ok(HeapFree(heap,0,mem3),"HeapFree didn't pass successfully\n");
+    }
+
+    /* Check that HeapRealloc works */
+    mem2a=HeapReAlloc(heap,HEAP_ZERO_MEMORY,mem2,memchunk+5*sysInfo.dwPageSize);
+    ok(mem2a!=NULL,"HeapReAlloc failed\n");
+    if(mem2a) {
+      ok(HeapSize(heap,0,mem2a)>=memchunk+5*sysInfo.dwPageSize,"HeapReAlloc failed\n");
+      error=FALSE;
+      for(i=0;i<5*sysInfo.dwPageSize;i++) {
+        if(mem2a[memchunk+i]!=0) {
+          error=TRUE;
+        }
+      }
+      ok(!error,"HeapReAlloc should have zeroed out its allocated memory\n");
+    }
+
+    /* Check that HeapRealloc honours HEAP_REALLOC_IN_PLACE_ONLY */
+    error=FALSE;
+    mem1a=HeapReAlloc(heap,HEAP_REALLOC_IN_PLACE_ONLY,mem1,memchunk+sysInfo.dwPageSize);
+    if(mem1a!=NULL) {
+      if(mem1a!=mem1) {
+        error=TRUE;
+      }
+    }
+    ok(mem1a==NULL || !error,"HeapReAlloc didn't honour HEAP_REALLOC_IN_PLACE_ONLY\n");
+
+    /* Check that HeapFree works correctly */
+   if(mem1a) {
+     ok(HeapFree(heap,0,mem1a),"HeapFree failed\n");
+   } else {
+     ok(HeapFree(heap,0,mem1),"HeapFree failed\n");
+   }
+   if(mem2a) {
+     ok(HeapFree(heap,0,mem2a),"HeapFree failed\n");
+   } else {
+     ok(HeapFree(heap,0,mem2),"HeapFree failed\n");
+   }
+
+   /* 0-length buffer */
+   mem1 = HeapAlloc(heap, 0, 0);
+   ok(mem1 != NULL, "Reserved memory\n");
+
+   dwSize = HeapSize(heap, 0, mem1);
+   /* should work with 0-length buffer */
+   ok(dwSize < 0xFFFFFFFF, "The size of the 0-length buffer\n");
+   ok(HeapFree(heap, 0, mem1), "Freed the 0-length buffer\n");
+
+   /* Check that HeapDestroy works */
+   ok(HeapDestroy(heap),"HeapDestroy failed\n");
+}
+
+
+static void test_GlobalAlloc(void)
+{
+    ULONG memchunk;
+    HGLOBAL mem1,mem2,mem2a,mem2b;
+    UCHAR *mem2ptr;
+    UINT i;
+    BOOL error;
+    memchunk=100000;
+
+    SetLastError(NO_ERROR);
+    /* Check that a normal alloc works */
+    mem1=GlobalAlloc(0,memchunk);
+    ok(mem1!=NULL,"GlobalAlloc failed\n");
+    if(mem1) {
+      ok(GlobalSize(mem1)>=memchunk, "GlobalAlloc should return a big enough memory block\n");
+    }
+
+    /* Check that a 'zeroing' alloc works */
+    mem2=GlobalAlloc(GMEM_ZEROINIT,memchunk);
+    ok(mem2!=NULL,"GlobalAlloc failed: error=%d\n",GetLastError());
+    if(mem2) {
+      ok(GlobalSize(mem2)>=memchunk,"GlobalAlloc should return a big enough memory block\n");
+      mem2ptr=GlobalLock(mem2);
+      ok(mem2ptr==mem2,"GlobalLock should have returned the same memory as was allocated\n");
+      if(mem2ptr) {
+        error=FALSE;
+        for(i=0;i<memchunk;i++) {
+          if(mem2ptr[i]!=0) {
+            error=TRUE;
+          }
+        }
+        ok(!error,"GlobalAlloc should have zeroed out its allocated memory\n");
+      }
+   }
+    /* Check that GlobalReAlloc works */
+    /* Check that we can change GMEM_FIXED to GMEM_MOVEABLE */
+    mem2a=GlobalReAlloc(mem2,0,GMEM_MODIFY | GMEM_MOVEABLE);
+    if(mem2a!=NULL) {
+      mem2=mem2a;
+      mem2ptr=GlobalLock(mem2a);
+      ok(mem2ptr!=NULL && !GlobalUnlock(mem2a)&&GetLastError()==NO_ERROR,
+         "Converting from FIXED to MOVEABLE didn't REALLY work\n");
+    }
+
+    /* Check that ReAllocing memory works as expected */
+    mem2a=GlobalReAlloc(mem2,2*memchunk,GMEM_MOVEABLE | GMEM_ZEROINIT);
+    ok(mem2a!=NULL,"GlobalReAlloc failed\n");
+    if(mem2a) {
+      ok(GlobalSize(mem2a)>=2*memchunk,"GlobalReAlloc failed\n");
+      mem2ptr=GlobalLock(mem2a);
+      ok(mem2ptr!=NULL,"GlobalLock Failed\n");
+      if(mem2ptr) {
+        error=FALSE;
+        for(i=0;i<memchunk;i++) {
+          if(mem2ptr[memchunk+i]!=0) {
+            error=TRUE;
+          }
+        }
+        ok(!error,"GlobalReAlloc should have zeroed out its allocated memory\n");
+
+        /* Check that GlobalHandle works */
+        mem2b=GlobalHandle(mem2ptr);
+        ok(mem2b==mem2a,"GlobalHandle didn't return the correct memory handle %p/%p for %p\n",
+           mem2a, mem2b, mem2ptr);
+        /* Check that we can't discard locked memory */
+        mem2b=GlobalDiscard(mem2a);
+        if(mem2b==NULL) {
+          ok(!GlobalUnlock(mem2a) && GetLastError()==NO_ERROR,"GlobalUnlock Failed\n");
+        }
+      }
+    }
+    if(mem1) {
+      ok(GlobalFree(mem1)==NULL,"GlobalFree failed\n");
+    }
+    if(mem2a) {
+      ok(GlobalFree(mem2a)==NULL,"GlobalFree failed\n");
+    } else {
+      ok(GlobalFree(mem2)==NULL,"GlobalFree failed\n");
+    }
+}
+
+
+static void test_LocalAlloc(void)
+{
+    ULONG memchunk;
+    HLOCAL mem1,mem2,mem2a,mem2b;
+    UCHAR *mem2ptr;
+    UINT i;
+    BOOL error;
+    memchunk=100000;
+
+    /* Check that a normal alloc works */
+    mem1=LocalAlloc(0,memchunk);
+    ok(mem1!=NULL,"LocalAlloc failed: error=%d\n",GetLastError());
+    if(mem1) {
+      ok(LocalSize(mem1)>=memchunk, "LocalAlloc should return a big enough memory block\n");
+    }
+
+    /* Check that a 'zeroing' and lock alloc works */
+    mem2=LocalAlloc(LMEM_ZEROINIT|LMEM_MOVEABLE,memchunk);
+    ok(mem2!=NULL,"LocalAlloc failed: error=%d\n",GetLastError());
+    if(mem2) {
+      ok(LocalSize(mem2)>=memchunk,"LocalAlloc should return a big enough memory block\n");
+      mem2ptr=LocalLock(mem2);
+      ok(mem2ptr!=NULL,"LocalLock: error=%d\n",GetLastError());
+      if(mem2ptr) {
+        error=FALSE;
+        for(i=0;i<memchunk;i++) {
+          if(mem2ptr[i]!=0) {
+            error=TRUE;
+          }
+        }
+        ok(!error,"LocalAlloc should have zeroed out its allocated memory\n");
+        SetLastError(0);
+        error=LocalUnlock(mem2);
+        ok(!error && GetLastError()==NO_ERROR,
+           "LocalUnlock Failed: rc=%d err=%d\n",error,GetLastError());
+      }
+    }
+   mem2a=LocalFree(mem2);
+   ok(mem2a==NULL, "LocalFree failed: %p\n",mem2a);
+
+   /* Reallocate mem2 as moveable memory */
+   mem2=LocalAlloc(LMEM_MOVEABLE | LMEM_ZEROINIT,memchunk);
+   ok(mem2!=NULL, "LocalAlloc failed to create moveable memory, error=%d\n",GetLastError());
+
+   /* Check that ReAllocing memory works as expected */
+    mem2a=LocalReAlloc(mem2,2*memchunk,LMEM_MOVEABLE | LMEM_ZEROINIT);
+    ok(mem2a!=NULL,"LocalReAlloc failed, error=%d\n",GetLastError());
+    if(mem2a) {
+      ok(LocalSize(mem2a)>=2*memchunk,"LocalReAlloc failed\n");
+      mem2ptr=LocalLock(mem2a);
+      ok(mem2ptr!=NULL,"LocalLock Failed\n");
+      if(mem2ptr) {
+        error=FALSE;
+        for(i=0;i<memchunk;i++) {
+          if(mem2ptr[memchunk+i]!=0) {
+            error=TRUE;
+          }
+        }
+        ok(!error,"LocalReAlloc should have zeroed out its allocated memory\n");
+        /* Check that LocalHandle works */
+        mem2b=LocalHandle(mem2ptr);
+        ok(mem2b==mem2a,"LocalHandle didn't return the correct memory handle %p/%p for %p\n",
+           mem2a, mem2b, mem2ptr);
+        /* Check that we can't discard locked memory */
+        mem2b=LocalDiscard(mem2a);
+        ok(mem2b==NULL,"Discarded memory we shouldn't have\n");
+        SetLastError(NO_ERROR);
+        ok(!LocalUnlock(mem2a) && GetLastError()==NO_ERROR, "LocalUnlock Failed\n");
+      }
+    }
+    if(mem1) {
+      ok(LocalFree(mem1)==NULL,"LocalFree failed\n");
+    }
+    if(mem2a) {
+      ok(LocalFree(mem2a)==NULL,"LocalFree failed\n");
+    } else {
+      ok(LocalFree(mem2)==NULL,"LocalFree failed\n");
+    }
+}
+
 static void test_obsolete_flags(void)
 {
     static struct {
@@ -888,6 +1161,9 @@ START_TEST(heap)
 
     test_heap();
     test_obsolete_flags();
+    test_HeapCreate();
+    test_GlobalAlloc();
+    test_LocalAlloc();
 
     /* Test both short and very long blocks */
     test_sized_HeapAlloc(1);
diff --git a/dlls/mgmtapi/mgmtapi.spec b/dlls/mgmtapi/mgmtapi.spec
index 9166cd4..a052d73 100644
--- a/dlls/mgmtapi/mgmtapi.spec
+++ b/dlls/mgmtapi/mgmtapi.spec
@@ -4,6 +4,6 @@
 @ stub SnmpMgrGetTrapEx
 @ stub SnmpMgrOidToStr
 @ stub SnmpMgrOpen
-@ stub SnmpMgrrequest
+@ stub SnmpMgrRequest
 @ stub SnmpMgrStrToOid
 @ stub SnmpMgrTrapListen
diff --git a/dlls/mshtml/htmlbody.c b/dlls/mshtml/htmlbody.c
index 6c2bb7a..7117087 100644
--- a/dlls/mshtml/htmlbody.c
+++ b/dlls/mshtml/htmlbody.c
@@ -124,7 +124,7 @@ static int loose_hex_to_rgb(const WCHAR *hex)
         | comp_value(hex+2*dpc, dpc);
 }
 
-static HRESULT nscolor_to_str(LPCWSTR color, BSTR *ret)
+HRESULT nscolor_to_str(LPCWSTR color, BSTR *ret)
 {
     unsigned int i;
     int rgb = -1;
@@ -155,7 +155,7 @@ static HRESULT nscolor_to_str(LPCWSTR color, BSTR *ret)
     return S_OK;
 }
 
-static BOOL variant_to_nscolor(const VARIANT *v, nsAString *nsstr)
+BOOL variant_to_nscolor(const VARIANT *v, nsAString *nsstr)
 {
     switch(V_VT(v)) {
     case VT_BSTR:
diff --git a/dlls/mshtml/htmlstyle.c b/dlls/mshtml/htmlstyle.c
index c85e4db..d2d2fc8 100644
--- a/dlls/mshtml/htmlstyle.c
+++ b/dlls/mshtml/htmlstyle.c
@@ -126,6 +126,8 @@ static const WCHAR attrLetterSpacing[] =
     {'l','e','t','t','e','r','-','s','p','a','c','i','n','g',0};
 static const WCHAR attrLineHeight[] =
     {'l','i','n','e','-','h','e','i','g','h','t',0};
+static const WCHAR attrListStyleType[] =
+    {'l','i','s','t','-','s','t','y','l','e','-','t','y','p','e',0};
 static const WCHAR attrMargin[] =
     {'m','a','r','g','i','n',0};
 static const WCHAR attrMarginBottom[] =
@@ -241,6 +243,7 @@ static const style_tbl_entry_t style_tbl[] = {
     {attrLeft,                 DISPID_IHTMLSTYLE_LEFT},
     {attrLetterSpacing,        DISPID_IHTMLSTYLE_LETTERSPACING},
     {attrLineHeight,           DISPID_IHTMLSTYLE_LINEHEIGHT},
+    {attrListStyleType,        DISPID_IHTMLSTYLE_LISTSTYLETYPE},
     {attrMargin,               DISPID_IHTMLSTYLE_MARGIN},
     {attrMarginBottom,         DISPID_IHTMLSTYLE_MARGINBOTTOM},
     {attrMarginLeft,           DISPID_IHTMLSTYLE_MARGINLEFT},
@@ -2168,15 +2171,19 @@ static HRESULT WINAPI HTMLStyle_get_visibility(IHTMLStyle *iface, BSTR *p)
 static HRESULT WINAPI HTMLStyle_put_listStyleType(IHTMLStyle *iface, BSTR v)
 {
     HTMLStyle *This = impl_from_IHTMLStyle(iface);
-    FIXME("(%p)->(%s)\n", This, debugstr_w(v));
-    return E_NOTIMPL;
+
+    TRACE("(%p)->(%s)\n", This, debugstr_w(v));
+
+    return set_style_attr(This, STYLEID_LISTSTYLETYPE, v, 0);
 }
 
 static HRESULT WINAPI HTMLStyle_get_listStyleType(IHTMLStyle *iface, BSTR *p)
 {
     HTMLStyle *This = impl_from_IHTMLStyle(iface);
-    FIXME("(%p)->(%p)\n", This, p);
-    return E_NOTIMPL;
+
+    TRACE("(%p)->(%p)\n", This, p);
+
+    return get_style_attr(This, STYLEID_LISTSTYLETYPE, p);
 }
 
 static HRESULT WINAPI HTMLStyle_put_listStylePosition(IHTMLStyle *iface, BSTR v)
diff --git a/dlls/mshtml/htmlstyle.h b/dlls/mshtml/htmlstyle.h
index 9294015..030d8a1 100644
--- a/dlls/mshtml/htmlstyle.h
+++ b/dlls/mshtml/htmlstyle.h
@@ -78,6 +78,7 @@ typedef enum {
     STYLEID_LEFT,
     STYLEID_LETTER_SPACING,
     STYLEID_LINE_HEIGHT,
+    STYLEID_LISTSTYLETYPE,
     STYLEID_MARGIN,
     STYLEID_MARGIN_BOTTOM,
     STYLEID_MARGIN_LEFT,
diff --git a/dlls/mshtml/htmltablerow.c b/dlls/mshtml/htmltablerow.c
index f93a606..f3a4970 100644
--- a/dlls/mshtml/htmltablerow.c
+++ b/dlls/mshtml/htmltablerow.c
@@ -170,15 +170,48 @@ static HRESULT WINAPI HTMLTableRow_get_vAlign(IHTMLTableRow *iface, BSTR *p)
 static HRESULT WINAPI HTMLTableRow_put_bgColor(IHTMLTableRow *iface, VARIANT v)
 {
     HTMLTableRow *This = impl_from_IHTMLTableRow(iface);
-    FIXME("(%p)->(%s)\n", This, debugstr_variant(&v));
-    return E_NOTIMPL;
+    nsAString val;
+    nsresult nsres;
+
+    TRACE("(%p)->(%s)\n", This, debugstr_variant(&v));
+
+    nsAString_InitDepend(&val, V_BSTR(&v));
+    variant_to_nscolor(&v, &val);
+    nsres = nsIDOMHTMLTableRowElement_SetBgColor(This->nsrow, &val);
+    nsAString_Finish(&val);
+
+    if (NS_FAILED(nsres)){
+        ERR("Set BgColor(%s) failed!\n", debugstr_variant(&v));
+        return E_FAIL;
+    }
+
+    return S_OK;
 }
 
 static HRESULT WINAPI HTMLTableRow_get_bgColor(IHTMLTableRow *iface, VARIANT *p)
 {
     HTMLTableRow *This = impl_from_IHTMLTableRow(iface);
-    FIXME("(%p)->(%p)\n", This, p);
-    return E_NOTIMPL;
+    nsAString strColor;
+    nsresult nsres;
+    HRESULT hres;
+    const PRUnichar *color;
+
+    TRACE("(%p)->(%p)\n", This, p);
+
+    nsAString_Init(&strColor, NULL);
+    nsres = nsIDOMHTMLTableRowElement_GetBgColor(This->nsrow, &strColor);
+    nsAString_Finish(&strColor);
+
+    if(NS_SUCCEEDED(nsres)) {
+       nsAString_GetData(&strColor, &color);
+       V_VT(p) = VT_BSTR;
+       hres = nscolor_to_str(color, &V_BSTR(p));
+    }else {
+       ERR("SetBgColor failed: %08x\n", nsres);
+       hres = E_FAIL;
+    }
+
+    return hres;
 }
 
 static HRESULT WINAPI HTMLTableRow_put_borderColor(IHTMLTableRow *iface, VARIANT v)
diff --git a/dlls/mshtml/mshtml_private.h b/dlls/mshtml/mshtml_private.h
index 882f859..c40d773 100644
--- a/dlls/mshtml/mshtml_private.h
+++ b/dlls/mshtml/mshtml_private.h
@@ -862,6 +862,10 @@ HRESULT create_element(HTMLDocumentNode*,const WCHAR*,HTMLElement**) DECLSPEC_HI
 
 HRESULT HTMLDOMTextNode_Create(HTMLDocumentNode*,nsIDOMNode*,HTMLDOMNode**) DECLSPEC_HIDDEN;
 
+BOOL variant_to_nscolor(const VARIANT *v, nsAString *nsstr) DECLSPEC_HIDDEN;
+HRESULT nscolor_to_str(LPCWSTR color, BSTR *ret) DECLSPEC_HIDDEN;
+
+
 struct HTMLAttributeCollection {
     DispatchEx dispex;
     IHTMLAttributeCollection IHTMLAttributeCollection_iface;
diff --git a/dlls/mshtml/script.c b/dlls/mshtml/script.c
index 8a74554..4d49587 100644
--- a/dlls/mshtml/script.c
+++ b/dlls/mshtml/script.c
@@ -816,11 +816,13 @@ static BOOL get_guid_from_type(LPCWSTR type, GUID *guid)
 {
     const WCHAR text_javascriptW[] =
         {'t','e','x','t','/','j','a','v','a','s','c','r','i','p','t',0};
+    const WCHAR text_jscriptW[] =
+        {'t','e','x','t','/','j','s','c','r','i','p','t',0};
     const WCHAR text_vbscriptW[] =
         {'t','e','x','t','/','v','b','s','c','r','i','p','t',0};
 
     /* FIXME: Handle more types */
-    if(!strcmpiW(type, text_javascriptW)) {
+    if(!strcmpiW(type, text_javascriptW) || !strcmpiW(type, text_jscriptW)) {
         *guid = CLSID_JScript;
     }else if(!strcmpiW(type, text_vbscriptW)) {
         *guid = CLSID_VBScript;
diff --git a/dlls/mshtml/tests/dom.c b/dlls/mshtml/tests/dom.c
index 2cb0087..76c283a 100644
--- a/dlls/mshtml/tests/dom.c
+++ b/dlls/mshtml/tests/dom.c
@@ -5578,6 +5578,7 @@ static void test_tr_elem(IHTMLElement *elem)
     HRESULT hres;
     BSTR bstr;
     LONG lval;
+    VARIANT vbg, vDefaultbg;
 
     static const elem_type_t cell_types[] = {ET_TD,ET_TD};
 
@@ -5628,6 +5629,40 @@ static void test_tr_elem(IHTMLElement *elem)
     ok(hres == S_OK, "get_sectionRowIndex failed: %08x\n", hres);
     ok(lval == 1, "get_sectionRowIndex returned %d\n", lval);
 
+    hres = IHTMLTableRow_get_bgColor(row, &vDefaultbg);
+    ok(hres == S_OK, "get_bgColor failed: %08x\n", hres);
+    ok(V_VT(&vDefaultbg) == VT_BSTR, "bstr != NULL\n");
+    ok(!V_BSTR(&vDefaultbg), "V_BSTR(bgColor) = %s\n", wine_dbgstr_w(V_BSTR(&vDefaultbg)));
+
+    V_VT(&vbg) = VT_BSTR;
+    V_BSTR(&vbg) = a2bstr("red");
+    hres = IHTMLTableRow_put_bgColor(row, vbg);
+    ok(hres == S_OK, "put_bgColor failed: %08x\n", hres);
+    VariantClear(&vbg);
+
+    hres = IHTMLTableRow_get_bgColor(row, &vbg);
+    ok(hres == S_OK, "get_bgColor failed: %08x\n", hres);
+    ok(V_VT(&vDefaultbg) == VT_BSTR, "V_VT(&vDefaultbg) != VT_BSTR\n");
+    ok(!strcmp_wa(V_BSTR(&vbg), "#ff0000"), "Unexpected bgcolor %s\n", wine_dbgstr_w(V_BSTR(&vbg)));
+    VariantClear(&vbg);
+
+    V_VT(&vbg) = VT_I4;
+    V_I4(&vbg) = 0xff0000;
+    hres = IHTMLTableRow_put_bgColor(row, vbg);
+    ok(hres == S_OK, "put_bgColor failed: %08x\n", hres);
+    VariantClear(&vbg);
+
+    hres = IHTMLTableRow_get_bgColor(row, &vbg);
+    ok(hres == S_OK, "get_bgColor failed: %08x\n", hres);
+    ok(V_VT(&vDefaultbg) == VT_BSTR, "V_VT(&vDefaultbg) != VT_BSTR\n");
+    ok(!strcmp_wa(V_BSTR(&vbg), "#ff0000"), "Unexpected bgcolor %s\n", wine_dbgstr_w(V_BSTR(&vbg)));
+    VariantClear(&vbg);
+
+    /* Restore Originial */
+    hres = IHTMLTableRow_put_bgColor(row, vDefaultbg);
+    ok(hres == S_OK, "put_bgColor failed: %08x\n", hres);
+    VariantClear(&vDefaultbg);
+
     IHTMLTableRow_Release(row);
 }
 
diff --git a/dlls/mshtml/tests/style.c b/dlls/mshtml/tests/style.c
index 2df585a..3c68f61 100644
--- a/dlls/mshtml/tests/style.c
+++ b/dlls/mshtml/tests/style.c
@@ -2092,6 +2092,22 @@ static void test_body_style(IHTMLStyle *style)
     ok(!strcmp_wa(str, "nowrap"), "whiteSpace = %s\n", wine_dbgstr_w(str));
     SysFreeString(str);
 
+    /* listStyleType */
+    hres = IHTMLStyle_get_listStyleType(style, &str);
+    ok(hres == S_OK, "get_listStyleType failed: %08x\n", hres);
+    ok(!str, "listStyleType = %s\n", wine_dbgstr_w(str));
+
+    str = a2bstr("square");
+    hres = IHTMLStyle_put_listStyleType(style, str);
+    ok(hres == S_OK, "put_listStyleType failed: %08x\n", hres);
+    SysFreeString(str);
+
+    str = NULL;
+    hres = IHTMLStyle_get_listStyleType(style, &str);
+    ok(hres == S_OK, "get_listStyleType failed: %08x\n", hres);
+    ok(!strcmp_wa(str, "square"), "listStyleType = %s\n", wine_dbgstr_w(str));
+    SysFreeString(str);
+
     hres = IHTMLStyle_QueryInterface(style, &IID_IHTMLStyle2, (void**)&style2);
     ok(hres == S_OK, "Could not get IHTMLStyle2 iface: %08x\n", hres);
     if(SUCCEEDED(hres)) {
diff --git a/dlls/msi/custom.c b/dlls/msi/custom.c
index 63bec19..002d861 100644
--- a/dlls/msi/custom.c
+++ b/dlls/msi/custom.c
@@ -1003,7 +1003,7 @@ static UINT HANDLE_CustomType5_6( MSIPACKAGE *package, const WCHAR *source, cons
         'S','E','L','E','C','T',' ','*',' ','F','R','O','M',' ',
         '`','B','i' ,'n','a','r','y','`',' ','W','H','E','R','E',' ',
         '`','N','a','m','e','`',' ','=',' ','\'','%','s','\'',0};
-    MSIRECORD *row = 0;
+    MSIRECORD *row = NULL;
     msi_custom_action_info *info;
     CHAR *buffer = NULL;
     WCHAR *bufferw = NULL;
@@ -1017,10 +1017,14 @@ static UINT HANDLE_CustomType5_6( MSIPACKAGE *package, const WCHAR *source, cons
         return ERROR_FUNCTION_FAILED;
 
     r = MSI_RecordReadStream(row, 2, NULL, &sz);
-    if (r != ERROR_SUCCESS) return r;
+    if (r != ERROR_SUCCESS) goto done;
 
     buffer = msi_alloc( sz + 1 );
-    if (!buffer) return ERROR_FUNCTION_FAILED;
+    if (!buffer)
+    {
+       r = ERROR_FUNCTION_FAILED;
+       goto done;
+    }
 
     r = MSI_RecordReadStream(row, 2, buffer, &sz);
     if (r != ERROR_SUCCESS)
@@ -1040,6 +1044,7 @@ static UINT HANDLE_CustomType5_6( MSIPACKAGE *package, const WCHAR *source, cons
 done:
     msi_free(bufferw);
     msi_free(buffer);
+    msiobj_release(&row->hdr);
     return r;
 }
 
diff --git a/dlls/msi/format.c b/dlls/msi/format.c
index 756c4d1..3c815d9 100644
--- a/dlls/msi/format.c
+++ b/dlls/msi/format.c
@@ -370,7 +370,11 @@ static LPWSTR build_default_format(const MSIRECORD* record)
         {
             max_len = len;
             buf = msi_realloc(buf, (max_len + 1) * sizeof(WCHAR));
-            if (!buf) return NULL;
+            if (!buf)
+            {
+                msi_free(rc);
+                return NULL;
+            }
         }
 
         if (str)
diff --git a/dlls/msi/table.c b/dlls/msi/table.c
index f67981c..8012369 100644
--- a/dlls/msi/table.c
+++ b/dlls/msi/table.c
@@ -1970,7 +1970,10 @@ static UINT TABLE_remove_column(struct tagMSIVIEW *view, LPCWSTR table, UINT num
 
     r = TABLE_CreateView(tv->db, szColumns, &columns);
     if (r != ERROR_SUCCESS)
+    {
+        msiobj_release(&rec->hdr);
         return r;
+    }
 
     r = msi_table_find_row((MSITABLEVIEW *)columns, rec, &row, NULL);
     if (r != ERROR_SUCCESS)
@@ -2092,7 +2095,10 @@ static UINT TABLE_drop(struct tagMSIVIEW *view)
 
     r = TABLE_CreateView(tv->db, szTables, &tables);
     if (r != ERROR_SUCCESS)
+    {
+        msiobj_release(&rec->hdr);
         return r;
+    }
 
     r = msi_table_find_row((MSITABLEVIEW *)tables, rec, &row, NULL);
     if (r != ERROR_SUCCESS)
diff --git a/dlls/msvcp100/msvcp100.spec b/dlls/msvcp100/msvcp100.spec
index e949b98..1dcbded 100644
--- a/dlls/msvcp100/msvcp100.spec
+++ b/dlls/msvcp100/msvcp100.spec
@@ -1214,7 +1214,7 @@
 @ cdecl -arch=win64 ?_Putgrouped@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@PEBD_K_W@Z(ptr ptr ptr str long long) num_put_wchar__Putgrouped
 @ stub -arch=win32 ?_Raise_handler@std@@3P6AXABVexception@stdext@@@ZA
 @ stub -arch=win64 ?_Raise_handler@std@@3P6AXAEBVexception@stdext@@@ZEA
-@ stub ?_Random_device@tr1@std@@YAIXZ
+@ cdecl ?_Random_device@tr1@std@@YAIXZ() _Random_device
 @ cdecl -arch=win32 ?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z(ptr ptr long ptr long long) num_put_char__Rep
 @ cdecl -arch=win64 ?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@D_K@Z(ptr ptr ptr long long) num_put_char__Rep
 @ cdecl -arch=win32 ?_Rep@?$num_put@GV?$ostreambuf_iterator@GU?$char_traits@G@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@GU?$char_traits@G@std@@@2@V32@GI@Z(ptr ptr long ptr long long) num_put_wchar__Rep
diff --git a/dlls/msvcp110/msvcp110.spec b/dlls/msvcp110/msvcp110.spec
index 3bdff79..0527936 100644
--- a/dlls/msvcp110/msvcp110.spec
+++ b/dlls/msvcp110/msvcp110.spec
@@ -1710,7 +1710,7 @@
 @ cdecl -arch=win64 ?_Put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@PEB_W_K@Z(ptr ptr ptr wstr long) num_put_wchar__Put
 @ stub -arch=win32 ?_Raise_handler@std@@3P6AXABVexception@stdext@@@ZA
 @ stub -arch=win64 ?_Raise_handler@std@@3P6AXAEBVexception@stdext@@@ZEA
-@ stub ?_Random_device@std@@YAIXZ
+@ cdecl ?_Random_device@std@@YAIXZ() _Random_device
 @ stub -arch=win32 ?_Read_dir@sys@tr2@std@@YAPADPADPAXAAW4file_type@123@@Z
 @ stub -arch=win64 ?_Read_dir@sys@tr2@std@@YAPEADPEADPEAXAEAW4file_type@123@@Z
 @ stub -arch=win32 ?_Read_dir@sys@tr2@std@@YAPA_WPA_WPAXAAW4file_type@123@@Z
diff --git a/dlls/msvcp90/misc.c b/dlls/msvcp90/misc.c
index f2ae32f..1c3bd2f 100644
--- a/dlls/msvcp90/misc.c
+++ b/dlls/msvcp90/misc.c
@@ -360,3 +360,17 @@ LONGLONG __cdecl _Xtime_get_ticks(void)
     GetSystemTimeAsFileTime(&ft);
     return ((LONGLONG)ft.dwHighDateTime<<32) + ft.dwLowDateTime - TICKS_1601_TO_1970;
 }
+
+#if _MSVCP_VER >= 90
+unsigned int __cdecl _Random_device(void)
+{
+    unsigned int ret;
+
+    TRACE("\n");
+
+    /* TODO: throw correct exception in case of failure */
+    if(rand_s(&ret))
+        throw_exception(EXCEPTION, "random number generator failed\n");
+    return ret;
+}
+#endif
diff --git a/dlls/msvcp90/msvcp90.spec b/dlls/msvcp90/msvcp90.spec
index a5116fa..fe02bbb 100644
--- a/dlls/msvcp90/msvcp90.spec
+++ b/dlls/msvcp90/msvcp90.spec
@@ -3062,7 +3062,7 @@
 @ stub -arch=win64 ?_Putmfld@?$money_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@_NAEAVios_base@2@_W1V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z
 @ stub -arch=win32 ?_Raise_handler@std@@3P6AXABVexception@stdext@@@ZA
 @ stub -arch=win64 ?_Raise_handler@std@@3P6AXAEBVexception@stdext@@@ZEA
-@ stub ?_Random_device@tr1@std@@YAIXZ
+@ cdecl ?_Random_device@tr1@std@@YAIXZ() _Random_device
 @ thiscall -arch=win32 ?_Read_s@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PADIH@Z(ptr ptr long long) basic_istream_char__Read_s
 @ cdecl -arch=win64 ?_Read_s@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@PEAD_K_J@Z(ptr ptr long long) basic_istream_char__Read_s
 @ thiscall -arch=win32 ?_Read_s@?$basic_istream@GU?$char_traits@G@std@@@std@@QAEAAV12@PAGIH@Z(ptr ptr long long) basic_istream_wchar__Read_s
diff --git a/dlls/msvcrt/tests/locale.c b/dlls/msvcrt/tests/locale.c
index 6ef07ec..dfb2146 100644
--- a/dlls/msvcrt/tests/locale.c
+++ b/dlls/msvcrt/tests/locale.c
@@ -49,9 +49,6 @@ static void test_setlocale(void)
     ret = setlocale(20, "C");
     ok(ret == NULL, "ret = %s\n", ret);
 
-    ret = setlocale(LC_ALL, "");
-    ok(ret != NULL, "ret == NULL\n");
-
     ret = setlocale(LC_ALL, "C");
     ok(!strcmp(ret, "C"), "ret = %s\n", ret);
 
diff --git a/dlls/msxml3/main.c b/dlls/msxml3/main.c
index 5967ac0..d67e4e0 100644
--- a/dlls/msxml3/main.c
+++ b/dlls/msxml3/main.c
@@ -63,9 +63,9 @@ HINSTANCE MSXML_hInstance = NULL;
 
 void wineXmlCallbackLog(char const* caller, xmlErrorLevel lvl, char const* msg, va_list ap)
 {
-    static const int max_size = 200;
     enum __wine_debug_class dbcl;
-    char buff[max_size];
+    char buff[200];
+    const int max_size = sizeof(buff) / sizeof(buff[0]);
     int len;
 
     switch (lvl)
diff --git a/dlls/netcfgx/Makefile.in b/dlls/netcfgx/Makefile.in
index 29277db..7e5e1fc 100644
--- a/dlls/netcfgx/Makefile.in
+++ b/dlls/netcfgx/Makefile.in
@@ -1,6 +1,8 @@
 MODULE    = netcfgx.dll
+IMPORTS   = uuid
 
 C_SRCS = \
-	main.c
+	main.c \
+	netcfg.c
 
 IDL_SRCS = netcfgx_classes.idl
diff --git a/dlls/netcfgx/main.c b/dlls/netcfgx/main.c
index dd3394c..0a3102a 100644
--- a/dlls/netcfgx/main.c
+++ b/dlls/netcfgx/main.c
@@ -19,16 +19,107 @@
  */
 #include <stdarg.h>
 
+#define COBJMACROS
+
 #include "windef.h"
 #include "winbase.h"
 #include "ole2.h"
 #include "rpcproxy.h"
 #include "wine/debug.h"
 
+#include "netcfgx.h"
+#include "netcfg_private.h"
+
 WINE_DEFAULT_DEBUG_CHANNEL(netcfgx);
 
 static HINSTANCE NETCFGX_hInstance;
 
+typedef HRESULT (*ClassFactoryCreateInstanceFunc)(IUnknown **);
+
+typedef struct netcfgcf
+{
+    IClassFactory    IClassFactory_iface;
+    ClassFactoryCreateInstanceFunc fnCreateInstance;
+} netcfgcf;
+
+static inline netcfgcf *impl_from_IClassFactory( IClassFactory *iface )
+{
+    return CONTAINING_RECORD(iface, netcfgcf, IClassFactory_iface);
+}
+
+static HRESULT WINAPI netcfgcf_QueryInterface(IClassFactory *iface, REFIID riid, LPVOID *ppobj )
+{
+    TRACE("%s %p\n", debugstr_guid(riid), ppobj);
+
+    if (IsEqualGUID(riid, &IID_IUnknown) ||
+        IsEqualGUID(riid, &IID_IClassFactory))
+    {
+        IClassFactory_AddRef( iface );
+        *ppobj = iface;
+        return S_OK;
+    }
+
+    ERR("interface %s not implemented\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI netcfgcf_AddRef(IClassFactory *iface )
+{
+    TRACE("%p\n", iface);
+
+    return 2;
+}
+
+static ULONG WINAPI netcfgcf_Release(IClassFactory *iface )
+{
+    TRACE("%p\n", iface);
+
+    return 1;
+}
+
+static HRESULT WINAPI netcfgcf_CreateInstance(IClassFactory *iface,LPUNKNOWN pOuter,
+                            REFIID riid, LPVOID *ppobj )
+{
+    netcfgcf *This = impl_from_IClassFactory( iface );
+    HRESULT hr;
+    IUnknown *punk;
+
+    TRACE("%p %s %p\n", pOuter, debugstr_guid(riid), ppobj );
+
+    *ppobj = NULL;
+
+    if (pOuter)
+        return CLASS_E_NOAGGREGATION;
+
+    hr = This->fnCreateInstance( &punk );
+    if (SUCCEEDED(hr))
+    {
+        hr = IUnknown_QueryInterface( punk, riid, ppobj );
+
+        IUnknown_Release( punk );
+    }
+    else
+    {
+        WARN("Cannot create an instance object. 0x%08x\n", hr);
+    }
+    return hr;
+}
+
+static HRESULT WINAPI netcfgcf_LockServer(IClassFactory *iface, BOOL dolock)
+{
+    FIXME("(%p)->(%d),stub!\n",iface,dolock);
+    return S_OK;
+}
+
+static const struct IClassFactoryVtbl netcfgcf_vtbl =
+{
+    netcfgcf_QueryInterface,
+    netcfgcf_AddRef,
+    netcfgcf_Release,
+    netcfgcf_CreateInstance,
+    netcfgcf_LockServer
+};
+
 BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
 {
     TRACE("(0x%p, %d, %p)\n", hinstDLL, fdwReason, lpvReserved);
@@ -49,11 +140,23 @@ BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
     return TRUE;
 }
 
+static netcfgcf netconfigcf = { {&netcfgcf_vtbl}, INetCfg_CreateInstance };
+
 HRESULT WINAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
 {
-    FIXME("(%s, %s, %p): stub\n", debugstr_guid(rclsid), debugstr_guid(riid), ppv);
+    IClassFactory *cf = NULL;
+
+    TRACE("(%s, %s, %p)\n", debugstr_guid(rclsid), debugstr_guid(riid), ppv);
+
+    if(IsEqualCLSID(rclsid, &CLSID_CNetCfg))
+    {
+        cf = &netconfigcf.IClassFactory_iface;
+    }
+
+    if(!cf)
+        return CLASS_E_CLASSNOTAVAILABLE;
 
-    return CLASS_E_CLASSNOTAVAILABLE;
+    return IClassFactory_QueryInterface(cf, riid, ppv);
 }
 
 HRESULT WINAPI DllRegisterServer(void)
diff --git a/dlls/netcfgx/netcfg.c b/dlls/netcfgx/netcfg.c
new file mode 100644
index 0000000..43db0ef
--- /dev/null
+++ b/dlls/netcfgx/netcfg.c
@@ -0,0 +1,239 @@
+/*
+ * Copyright 2014 Alistair Leslie-Hughes
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+#include <stdio.h>
+#include <stdarg.h>
+#include <assert.h>
+
+#define COBJMACROS
+
+#include "netcfgx.h"
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL( netcfgx );
+
+
+typedef struct NetConfiguration
+{
+    INetCfg INetCfg_iface;
+    INetCfgLock INetCfgLock_iface;
+
+    LONG ref;
+} NetConfiguration;
+
+static inline NetConfiguration *impl_from_INetCfg(INetCfg *iface)
+{
+    return CONTAINING_RECORD(iface, NetConfiguration, INetCfg_iface);
+}
+
+static inline NetConfiguration *impl_from_INetCfgLock(INetCfgLock *iface)
+{
+    return CONTAINING_RECORD(iface, NetConfiguration, INetCfgLock_iface);
+}
+
+static HRESULT WINAPI netcfg_QueryInterface(INetCfg *iface, REFIID riid, void **ppvObject)
+{
+    NetConfiguration *This = impl_from_INetCfg(iface);
+    TRACE("%p %s %p\n", This, debugstr_guid(riid), ppvObject);
+
+    if (IsEqualGUID(riid, &IID_INetCfg) ||
+        IsEqualGUID(riid, &IID_IUnknown))
+    {
+        *ppvObject = &This->INetCfg_iface;
+    }
+    else if(IsEqualGUID(riid, &IID_INetCfgLock))
+    {
+        *ppvObject = &This->INetCfgLock_iface;
+    }
+    else
+    {
+        FIXME("Unsupported interface %s\n", debugstr_guid(riid));
+        return E_NOINTERFACE;
+    }
+
+    IUnknown_AddRef((IUnknown*)*ppvObject);
+
+    return S_OK;
+}
+
+static ULONG WINAPI netcfg_AddRef(INetCfg *iface)
+{
+    NetConfiguration *This = impl_from_INetCfg(iface);
+    ULONG ref = InterlockedIncrement(&This->ref);
+
+    TRACE("%p ref=%u\n", This, ref);
+
+    return ref;
+}
+
+static ULONG WINAPI netcfg_Release(INetCfg *iface)
+{
+    NetConfiguration *This = impl_from_INetCfg(iface);
+    ULONG ref = InterlockedDecrement(&This->ref);
+
+    TRACE("%p ref=%u\n", This, ref);
+
+    if (ref == 0)
+    {
+        HeapFree(GetProcessHeap(), 0, This);
+    }
+
+    return ref;
+}
+
+static HRESULT WINAPI netcfg_Initialize(INetCfg *iface, PVOID pvReserved)
+{
+    NetConfiguration *This = impl_from_INetCfg(iface);
+    FIXME("%p %p\n", This, pvReserved);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI netcfg_Uninitialize(INetCfg *iface)
+{
+    NetConfiguration *This = impl_from_INetCfg(iface);
+    FIXME("%p\n", This);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI netcfg_Apply(INetCfg *iface)
+{
+    NetConfiguration *This = impl_from_INetCfg(iface);
+    FIXME("%p\n", This);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI netcfg_Cancel(INetCfg *iface)
+{
+    NetConfiguration *This = impl_from_INetCfg(iface);
+    FIXME("%p\n", This);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI netcfg_EnumComponents(INetCfg *iface, const GUID *pguidClass, IEnumNetCfgComponent **ppenumComponent)
+{
+    NetConfiguration *This = impl_from_INetCfg(iface);
+    FIXME("%p %s %p\n", This, debugstr_guid(pguidClass), ppenumComponent);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI netcfg_FindComponent(INetCfg *iface, LPCWSTR pszwInfId, INetCfgComponent **pComponent)
+{
+    NetConfiguration *This = impl_from_INetCfg(iface);
+    FIXME("%p %s %p\n", This, debugstr_w(pszwInfId), pComponent);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI netcfg_QueryNetCfgClass(INetCfg *iface, const GUID *pguidClass, REFIID riid, void **ppvObject)
+{
+    NetConfiguration *This = impl_from_INetCfg(iface);
+    FIXME("%p %s %p\n", This, debugstr_guid(pguidClass), ppvObject);
+
+    return E_NOTIMPL;
+}
+
+static const struct INetCfgVtbl NetCfgVtbl =
+{
+    netcfg_QueryInterface,
+    netcfg_AddRef,
+    netcfg_Release,
+    netcfg_Initialize,
+    netcfg_Uninitialize,
+    netcfg_Apply,
+    netcfg_Cancel,
+    netcfg_EnumComponents,
+    netcfg_FindComponent,
+    netcfg_QueryNetCfgClass
+};
+
+
+static HRESULT WINAPI netcfglock_QueryInterface(INetCfgLock *iface, REFIID riid,void **ppvObject)
+{
+    NetConfiguration *This = impl_from_INetCfgLock(iface);
+
+    return netcfg_QueryInterface(&This->INetCfg_iface, riid, ppvObject);
+}
+
+static ULONG WINAPI netcfglock_AddRef(INetCfgLock *iface)
+{
+    NetConfiguration *This = impl_from_INetCfgLock(iface);
+
+    return netcfg_AddRef(&This->INetCfg_iface);
+}
+
+static ULONG WINAPI netcfglock_Release(INetCfgLock *iface)
+{
+    NetConfiguration *This = impl_from_INetCfgLock(iface);
+    return netcfg_Release(&This->INetCfg_iface);
+}
+
+static HRESULT WINAPI netcfglock_AcquireWriteLock(INetCfgLock *iface, DWORD cmsTimeout,
+                                 LPCWSTR pszwClientDescription, LPWSTR *ppszwClientDescription)
+{
+    NetConfiguration *This = impl_from_INetCfgLock(iface);
+    FIXME("%p %d %s %p\n", This, cmsTimeout, debugstr_w(pszwClientDescription), ppszwClientDescription);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI netcfglock_ReleaseWriteLock(INetCfgLock *iface)
+{
+    NetConfiguration *This = impl_from_INetCfgLock(iface);
+    FIXME("%p\n", This);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI netcfglock_IsWriteLocked(INetCfgLock *iface, LPWSTR *ppszwClientDescription)
+{
+    NetConfiguration *This = impl_from_INetCfgLock(iface);
+    FIXME("%p %p\n", This, ppszwClientDescription);
+
+    return E_NOTIMPL;
+}
+
+static const struct INetCfgLockVtbl NetCfgLockVtbl =
+{
+    netcfglock_QueryInterface,
+    netcfglock_AddRef,
+    netcfglock_Release,
+    netcfglock_AcquireWriteLock,
+    netcfglock_ReleaseWriteLock,
+    netcfglock_IsWriteLocked
+};
+
+HRESULT INetCfg_CreateInstance(IUnknown **ppUnk)
+{
+    NetConfiguration *This;
+
+    This = HeapAlloc(GetProcessHeap(), 0, sizeof(NetConfiguration));
+    if (!This)
+        return E_OUTOFMEMORY;
+
+    This->INetCfg_iface.lpVtbl = &NetCfgVtbl;
+    This->INetCfgLock_iface.lpVtbl = &NetCfgLockVtbl;
+    This->ref = 1;
+
+    *ppUnk = (IUnknown*)This;
+
+    return S_OK;
+}
diff --git a/dlls/netcfgx/netcfg_private.h b/dlls/netcfgx/netcfg_private.h
new file mode 100644
index 0000000..14c5111
--- /dev/null
+++ b/dlls/netcfgx/netcfg_private.h
@@ -0,0 +1,23 @@
+/*
+ * Copyright 2014 Alistair Leslie-Hughes
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+#ifndef __NETCFG_PRIVATE_H__
+#define __NETCFG_PRIVATE_H__
+
+extern HRESULT INetCfg_CreateInstance(IUnknown **ppUnk) DECLSPEC_HIDDEN;
+
+#endif
diff --git a/dlls/netcfgx/tests/Makefile.in b/dlls/netcfgx/tests/Makefile.in
new file mode 100644
index 0000000..699af30
--- /dev/null
+++ b/dlls/netcfgx/tests/Makefile.in
@@ -0,0 +1,5 @@
+TESTDLL   = netcfgx.dll
+IMPORTS   = uuid ole32
+
+C_SRCS = \
+	netcfgx.c
diff --git a/dlls/netcfgx/tests/netcfgx.c b/dlls/netcfgx/tests/netcfgx.c
new file mode 100644
index 0000000..2a9f0eb
--- /dev/null
+++ b/dlls/netcfgx/tests/netcfgx.c
@@ -0,0 +1,93 @@
+/*
+ * Copyright 2014 Alistair Leslie-Hughes
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+#define WIN32_LEAN_AND_MEAN
+#include <stdio.h>
+
+#define COBJMACROS
+
+#include "netcfgx.h"
+#include "wine/test.h"
+
+void create_configuration(void)
+{
+    static const WCHAR tcpipW[] = {'M','S','_','T','C','P','I','P',0};
+    static const WCHAR myclient[] = {'M','Y',' ','C','L','I','E','N','T',0};
+    HRESULT hr;
+    INetCfg *config = NULL;
+    INetCfgLock *netlock = NULL;
+    INetCfgComponent *component = NULL;
+    LPWSTR client = NULL;
+
+    hr = CoCreateInstance( &CLSID_CNetCfg, NULL, CLSCTX_ALL, &IID_INetCfg, (LPVOID*)&config);
+    ok(hr == S_OK, "Failed to create object\n");
+    if(SUCCEEDED(hr))
+    {
+        hr = INetCfg_QueryInterface(config, &IID_INetCfgLock, (LPVOID*)&netlock);
+        ok(hr == S_OK, "got 0x%08x\n", hr);
+
+        hr = INetCfgLock_AcquireWriteLock(netlock, 5000, myclient, &client);
+        ok(hr == S_OK ||
+           hr == E_ACCESSDENIED /* Not run as admin */, "got 0x%08x\n", hr);
+        if(hr == S_OK)
+        {
+            trace("Lock value: %s\n", wine_dbgstr_w(client));
+            CoTaskMemFree(client);
+        }
+        else if(hr == E_ACCESSDENIED)
+            trace("Not run with Admin permissions\n");
+
+        hr = INetCfg_Initialize(config, NULL);
+        ok(hr == S_OK, "got 0x%08x\n", hr);
+
+        /* AcquireWriteLock needs to be run before Initialize */
+        hr = INetCfgLock_AcquireWriteLock(netlock, 5000, myclient, &client);
+        todo_wine ok(hr == NETCFG_E_ALREADY_INITIALIZED || hr == E_ACCESSDENIED, "got 0x%08x\n", hr);
+
+        hr =  INetCfg_FindComponent(config, tcpipW, &component);
+        todo_wine ok(hr == S_OK, "got 0x%08x\n", hr);
+        if(hr == S_OK)
+        {
+            INetCfgComponent_Release(component);
+        }
+
+        hr = INetCfg_Apply(config);
+        todo_wine ok(hr == S_OK || hr == NETCFG_E_NO_WRITE_LOCK, "got 0x%08x\n", hr);
+
+        hr = INetCfg_Uninitialize(config);
+        ok(hr == S_OK, "got 0x%08x\n", hr);
+
+        hr = INetCfgLock_ReleaseWriteLock(netlock);
+        ok(hr == S_OK, "got 0x%08x\n", hr);
+
+        INetCfg_Release(config);
+    }
+}
+
+START_TEST(netcfgx)
+{
+    HRESULT hr;
+
+    hr = CoInitialize(0);
+    ok( hr == S_OK, "failed to init com\n");
+    if (hr != S_OK)
+        return;
+
+    create_configuration();
+
+    CoUninitialize();
+}
diff --git a/dlls/ntdll/heap.c b/dlls/ntdll/heap.c
index ac78889..3bb7a11 100644
--- a/dlls/ntdll/heap.c
+++ b/dlls/ntdll/heap.c
@@ -879,7 +879,7 @@ static SUBHEAP *HEAP_CreateSubHeap( HEAP *heap, LPVOID address, DWORD flags,
         commitSize = min( totalSize, (commitSize + COMMIT_MASK) & ~COMMIT_MASK );
 
         /* allocate the memory block */
-        if (NtAllocateVirtualMemory( NtCurrentProcess(), &address, 5, &totalSize,
+        if (NtAllocateVirtualMemory( NtCurrentProcess(), &address, 0, &totalSize,
                                      MEM_RESERVE, get_protection_type( flags ) ))
         {
             WARN("Could not allocate %08lx bytes\n", totalSize );
diff --git a/dlls/ole32/filemoniker.c b/dlls/ole32/filemoniker.c
index af161fe..06c4798 100644
--- a/dlls/ole32/filemoniker.c
+++ b/dlls/ole32/filemoniker.c
@@ -935,11 +935,12 @@ static HRESULT WINAPI
 FileMonikerImpl_CommonPrefixWith(IMoniker* iface,IMoniker* pmkOther,IMoniker** ppmkPrefix)
 {
 
-    LPOLESTR pathThis,pathOther,*stringTable1,*stringTable2,commonPath;
-    IBindCtx *pbind;
+    LPOLESTR pathThis = NULL, pathOther = NULL,*stringTable1,*stringTable2,commonPath = NULL;
+    IBindCtx *bindctx;
     DWORD mkSys;
     ULONG nb1,nb2,i,sameIdx;
     BOOL machineNameCase = FALSE;
+    HRESULT ret;
 
     if (ppmkPrefix==NULL)
         return E_POINTER;
@@ -951,81 +952,81 @@ FileMonikerImpl_CommonPrefixWith(IMoniker* iface,IMoniker* pmkOther,IMoniker** p
 
     /* check if we have the same type of moniker */
     IMoniker_IsSystemMoniker(pmkOther,&mkSys);
+    if (mkSys != MKSYS_FILEMONIKER)
+        return MonikerCommonPrefixWith(iface, pmkOther, ppmkPrefix);
 
-    if(mkSys==MKSYS_FILEMONIKER){
-        HRESULT ret;
-
-        ret = CreateBindCtx(0,&pbind);
-        if (FAILED(ret))
-            return ret;
-
-        /* create a string based on common part of the two paths */
-
-        ret = IMoniker_GetDisplayName(iface,pbind,NULL,&pathThis);
-        if (FAILED(ret))
-            return ret;
-        ret = IMoniker_GetDisplayName(pmkOther,pbind,NULL,&pathOther);
-        if (FAILED(ret))
-            return ret;
-
-        nb1=FileMonikerImpl_DecomposePath(pathThis,&stringTable1);
-        if (FAILED(nb1))
-            return nb1;
-        nb2=FileMonikerImpl_DecomposePath(pathOther,&stringTable2);
-        if (FAILED(nb2))
-        {
-            free_stringtable(stringTable1);
-            return nb2;
-        }
-
-        if (nb1==0 || nb2==0)
-        {
-            free_stringtable(stringTable1);
-            free_stringtable(stringTable2);
-            return MK_E_NOPREFIX;
-        }
-
-        commonPath=HeapAlloc(GetProcessHeap(),0,sizeof(WCHAR)*(min(lstrlenW(pathThis),lstrlenW(pathOther))+1));
-        if (!commonPath)
-            return E_OUTOFMEMORY;
+    ret = CreateBindCtx(0, &bindctx);
+    if (FAILED(ret))
+        return ret;
 
-        *commonPath=0;
+    /* create a string based on common part of the two paths */
+    ret = IMoniker_GetDisplayName(iface, bindctx, NULL, &pathThis);
+    if (FAILED(ret))
+        goto failed;
 
-        for(sameIdx=0; ( (stringTable1[sameIdx]!=NULL) &&
-                         (stringTable2[sameIdx]!=NULL) &&
-                         (lstrcmpiW(stringTable1[sameIdx],stringTable2[sameIdx])==0)); sameIdx++);
+    ret = IMoniker_GetDisplayName(pmkOther, bindctx, NULL, &pathOther);
+    if (FAILED(ret))
+        goto failed;
 
-        if (sameIdx > 1 && *stringTable1[0]=='\\' && *stringTable2[1]=='\\'){
+    nb1 = FileMonikerImpl_DecomposePath(pathThis, &stringTable1);
+    if (FAILED(nb1)) {
+        ret = nb1;
+        goto failed;
+    }
 
-            machineNameCase = TRUE;
+    nb2 = FileMonikerImpl_DecomposePath(pathOther, &stringTable2);
+    if (FAILED(nb2)) {
+        ret = nb2;
+        goto failed;
+    }
 
-            for(i=2;i<sameIdx;i++)
+    if (nb1 == 0 || nb2 == 0) {
+        ret = MK_E_NOPREFIX;
+        goto failed;
+    }
 
-                if( (*stringTable1[i]=='\\') && (i+1 < sameIdx) && (*stringTable1[i+1]=='\\') ){
-                    machineNameCase = FALSE;
-                    break;
-            }
-        }
+    commonPath = CoTaskMemAlloc(sizeof(WCHAR)*(min(lstrlenW(pathThis),lstrlenW(pathOther))+1));
+    if (!commonPath) {
+        ret = E_OUTOFMEMORY;
+        goto failed;
+    }
 
-        if (machineNameCase && *stringTable1[sameIdx-1]=='\\')
-            sameIdx--;
+    *commonPath = 0;
+    for(sameIdx=0; ( (stringTable1[sameIdx]!=NULL) &&
+                     (stringTable2[sameIdx]!=NULL) &&
+                     (lstrcmpiW(stringTable1[sameIdx],stringTable2[sameIdx])==0)); sameIdx++);
 
-        if (machineNameCase && (sameIdx<=3) && (nb1 > 3 || nb2 > 3) )
-            ret = MK_E_NOPREFIX;
-        else
-        {
-            for(i=0;i<sameIdx;i++)
-                strcatW(commonPath,stringTable1[i]);
+    if (sameIdx > 1 && *stringTable1[0]=='\\' && *stringTable2[1]=='\\'){
+        machineNameCase = TRUE;
 
-            free_stringtable(stringTable1);
-            free_stringtable(stringTable2);
-            ret = CreateFileMoniker(commonPath,ppmkPrefix);
+    for(i=2;i<sameIdx;i++)
+        if( (*stringTable1[i]=='\\') && (i+1 < sameIdx) && (*stringTable1[i+1]=='\\') ){
+            machineNameCase = FALSE;
+            break;
         }
-        HeapFree(GetProcessHeap(),0,commonPath);
-        return ret;
     }
+
+    if (machineNameCase && *stringTable1[sameIdx-1]=='\\')
+        sameIdx--;
+
+    if (machineNameCase && (sameIdx<=3) && (nb1 > 3 || nb2 > 3) )
+        ret = MK_E_NOPREFIX;
     else
-        return MonikerCommonPrefixWith(iface,pmkOther,ppmkPrefix);
+    {
+        for (i = 0; i < sameIdx; i++)
+            strcatW(commonPath,stringTable1[i]);
+        ret = CreateFileMoniker(commonPath, ppmkPrefix);
+    }
+
+failed:
+    IBindCtx_Release(bindctx);
+    CoTaskMemFree(pathThis);
+    CoTaskMemFree(pathOther);
+    CoTaskMemFree(commonPath);
+    free_stringtable(stringTable1);
+    free_stringtable(stringTable2);
+
+    return ret;
 }
 
 /******************************************************************************
@@ -1105,8 +1106,7 @@ lend:
         CoTaskMemFree(strgtable);
     }
 
-    if (word)
-        CoTaskMemFree(word);
+    CoTaskMemFree(word);
 
     return ret;
 }
diff --git a/dlls/ole32/moniker.c b/dlls/ole32/moniker.c
index 970cc84..d694df9 100644
--- a/dlls/ole32/moniker.c
+++ b/dlls/ole32/moniker.c
@@ -1248,8 +1248,10 @@ HRESULT WINAPI GetClassFile(LPCOLESTR filePathName,CLSID *pclsid)
     absFile=pathDec[nbElm-1];
 
     /* failed if the path represents a directory and not an absolute file name*/
-    if (!lstrcmpW(absFile, bkslashW))
+    if (!lstrcmpW(absFile, bkslashW)) {
+        CoTaskMemFree(pathDec);
         return MK_E_INVALIDEXTENSION;
+    }
 
     /* get the extension of the file */
     extension = NULL;
@@ -1257,8 +1259,10 @@ HRESULT WINAPI GetClassFile(LPCOLESTR filePathName,CLSID *pclsid)
     for(i = length-1; (i >= 0) && *(extension = &absFile[i]) != '.'; i--)
         /* nothing */;
 
-    if (!extension || !lstrcmpW(extension, dotW))
+    if (!extension || !lstrcmpW(extension, dotW)) {
+        CoTaskMemFree(pathDec);
         return MK_E_INVALIDEXTENSION;
+    }
 
     res=RegQueryValueW(HKEY_CLASSES_ROOT, extension, NULL, &sizeProgId);
 
diff --git a/dlls/oleaut32/tests/safearray.c b/dlls/oleaut32/tests/safearray.c
index cc6a62c..2be8b06 100644
--- a/dlls/oleaut32/tests/safearray.c
+++ b/dlls/oleaut32/tests/safearray.c
@@ -1080,8 +1080,6 @@ static void test_SafeArrayGetPutElement(void)
     return; /* Some early versions can't handle > 3 dims */
 
   ok(sa->cbElements == sizeof(value), "int size mismatch\n");
-  if (sa->cbElements != sizeof(value))
-    return;
 
   /* Failure cases */
   for (x = 0; x < NUM_DIMENSIONS; x++)
@@ -1233,8 +1231,6 @@ static void test_SafeArrayGetPutElement_BSTR(void)
     return;
 
   ok(sa->cbElements == sizeof(BSTR), "BSTR size mismatch\n");
-  if (sa->cbElements != sizeof(BSTR))
-    return;
 
   indices[0] = sab.lLbound;
   value = SysAllocString(szTest);
@@ -1297,8 +1293,6 @@ static void test_SafeArrayGetPutElement_IUnknown(void)
     return;
 
   ok(sa->cbElements == sizeof(LPUNKNOWN), "LPUNKNOWN size mismatch\n");
-  if (sa->cbElements != sizeof(LPUNKNOWN))
-    return;
 
   indices[0] = sab.lLbound;
   xtunk.ref = 1;
@@ -1331,8 +1325,6 @@ static void test_SafeArrayRedim_IUnknown(void)
     return;
 
   ok(sa->cbElements == sizeof(LPUNKNOWN), "LPUNKNOWN size mismatch\n");
-  if (sa->cbElements != sizeof(LPUNKNOWN))
-    return;
 
   indices[0] = 2;
   xtunk.ref = 1;
@@ -1363,8 +1355,6 @@ static void test_SafeArrayGetPutElement_VARIANT(void)
     return;
 
   ok(sa->cbElements == sizeof(VARIANT), "VARIANT size mismatch\n");
-  if (sa->cbElements != sizeof(VARIANT))
-    return;
 
   indices[0] = sab.lLbound;
   V_VT(&value) = VT_I4;
@@ -1418,8 +1408,6 @@ static void test_SafeArrayCopyData(void)
     return;
 
   ok(sa->cbElements == sizeof(int), "int size mismatch\n");
-  if (sa->cbElements != sizeof(int))
-    return;
 
   /* Fill the source array with some data; it doesn't matter what */
   for (dimension = 0; dimension < size; dimension++)
diff --git a/dlls/oleaut32/tests/vartest.c b/dlls/oleaut32/tests/vartest.c
index d28b5c1..bfbc0b2 100644
--- a/dlls/oleaut32/tests/vartest.c
+++ b/dlls/oleaut32/tests/vartest.c
@@ -6000,11 +6000,11 @@ static void test_VarAnd(void)
     VARTYPE i;
     HRESULT hres;
 
+    CHECKPTR(VarAnd);
+
     true_str = SysAllocString(szTrue);
     false_str = SysAllocString(szFalse);
 
-    CHECKPTR(VarAnd);
-
     /* Test all possible flag/vt combinations & the resulting vt type */
     for (i = 0; i < sizeof(ExtraFlags)/sizeof(ExtraFlags[0]); i++)
     {
@@ -7479,11 +7479,11 @@ static void test_VarDiv(void)
     HRESULT hres;
     double r;
 
+    CHECKPTR(VarDiv);
+
     num1_str = SysAllocString(str1);
     num2_str = SysAllocString(str2);
 
-    CHECKPTR(VarDiv);
-
     /* Test all possible flag/vt combinations & the resulting vt type */
     for (i = 0; i < sizeof(ExtraFlags)/sizeof(ExtraFlags[0]); i++)
     {
diff --git a/dlls/oleaut32/tests/vartype.c b/dlls/oleaut32/tests/vartype.c
index 61ad45e..ea5065f 100644
--- a/dlls/oleaut32/tests/vartype.c
+++ b/dlls/oleaut32/tests/vartype.c
@@ -739,11 +739,15 @@ static void test_VarI1FromR4(void)
 
   CHECKPTR(VarI1FromR4);
   CONVERT(VarI1FromR4, -129.0f); EXPECT_OVERFLOW;
+  CONVERT(VarI1FromR4, -128.51f); EXPECT_OVERFLOW;
+  CONVERT(VarI1FromR4, -128.5f); EXPECT(-128);
   CONVERT(VarI1FromR4, -128.0f); EXPECT(-128);
   CONVERT(VarI1FromR4, -1.0f);   EXPECT(-1);
   CONVERT(VarI1FromR4, 0.0f);    EXPECT(0);
   CONVERT(VarI1FromR4, 1.0f);    EXPECT(1);
   CONVERT(VarI1FromR4, 127.0f);  EXPECT(127);
+  CONVERT(VarI1FromR4, 127.49f);  EXPECT(127);
+  CONVERT(VarI1FromR4, 127.5f);  EXPECT_OVERFLOW;
   CONVERT(VarI1FromR4, 128.0f);  EXPECT_OVERFLOW;
 
   CONVERT(VarI1FromR4, -1.5f); EXPECT(-2);
@@ -762,11 +766,15 @@ static void test_VarI1FromR8(void)
 
   CHECKPTR(VarI1FromR8);
   CONVERT(VarI1FromR8, -129.0); EXPECT_OVERFLOW;
+  CONVERT(VarI1FromR8, -128.51); EXPECT_OVERFLOW;
+  CONVERT(VarI1FromR8, -128.5); EXPECT(-128);
   CONVERT(VarI1FromR8, -128.0); EXPECT(-128);
   CONVERT(VarI1FromR8, -1.0);   EXPECT(-1);
   CONVERT(VarI1FromR8, 0.0);    EXPECT(0);
   CONVERT(VarI1FromR8, 1.0);    EXPECT(1);
   CONVERT(VarI1FromR8, 127.0);  EXPECT(127);
+  CONVERT(VarI1FromR8, 127.49);  EXPECT(127);
+  CONVERT(VarI1FromR8, 127.5);  EXPECT_OVERFLOW;
   CONVERT(VarI1FromR8, 128.0);  EXPECT_OVERFLOW;
 
   CONVERT(VarI1FromR8, -1.5); EXPECT(-2);
@@ -983,9 +991,13 @@ static void test_VarUI1FromR4(void)
 
   CHECKPTR(VarUI1FromR4);
   CONVERT(VarUI1FromR4, -1.0f);  EXPECT_OVERFLOW;
+  CONVERT(VarUI1FromR4, -0.51f);  EXPECT_OVERFLOW;
+  CONVERT(VarUI1FromR4, -0.5f);   EXPECT(0);
   CONVERT(VarUI1FromR4, 0.0f);   EXPECT(0);
   CONVERT(VarUI1FromR4, 1.0f);   EXPECT(1);
   CONVERT(VarUI1FromR4, 255.0f); EXPECT(255);
+  CONVERT(VarUI1FromR4, 255.49f); EXPECT(255);
+  CONVERT(VarUI1FromR4, 255.5f); EXPECT_OVERFLOW;
   CONVERT(VarUI1FromR4, 256.0f); EXPECT_OVERFLOW;
 
   /* Rounding */
@@ -1005,9 +1017,13 @@ static void test_VarUI1FromR8(void)
 
   CHECKPTR(VarUI1FromR8);
   CONVERT(VarUI1FromR8, -1.0);  EXPECT_OVERFLOW;
+  CONVERT(VarUI1FromR8, -0.51);  EXPECT_OVERFLOW;
+  CONVERT(VarUI1FromR8, -0.5);   EXPECT(0);
   CONVERT(VarUI1FromR8, 0.0);   EXPECT(0);
   CONVERT(VarUI1FromR8, 1.0);   EXPECT(1);
   CONVERT(VarUI1FromR8, 255.0); EXPECT(255);
+  CONVERT(VarUI1FromR8, 255.49); EXPECT(255);
+  CONVERT(VarUI1FromR8, 255.5); EXPECT_OVERFLOW;
   CONVERT(VarUI1FromR8, 256.0); EXPECT_OVERFLOW;
 
   /* Rounding */
@@ -1281,11 +1297,15 @@ static void test_VarI2FromR4(void)
 
   CHECKPTR(VarI2FromR4);
   CONVERT(VarI2FromR4, -32769.0f); EXPECT_OVERFLOW;
+  CONVERT(VarI2FromR4, -32768.51f); EXPECT_OVERFLOW;
+  CONVERT(VarI2FromR4, -32768.5f); EXPECT(-32768);
   CONVERT(VarI2FromR4, -32768.0f); EXPECT(-32768);
   CONVERT(VarI2FromR4, -1.0f);     EXPECT(-1);
   CONVERT(VarI2FromR4, 0.0f);      EXPECT(0);
   CONVERT(VarI2FromR4, 1.0f);      EXPECT(1);
   CONVERT(VarI2FromR4, 32767.0f);  EXPECT(32767);
+  CONVERT(VarI2FromR4, 32767.49f);  EXPECT(32767);
+  CONVERT(VarI2FromR4, 32767.5f);  EXPECT_OVERFLOW;
   CONVERT(VarI2FromR4, 32768.0f);  EXPECT_OVERFLOW;
 
   /* Rounding */
@@ -1305,11 +1325,15 @@ static void test_VarI2FromR8(void)
 
   CHECKPTR(VarI2FromR8);
   CONVERT(VarI2FromR8, -32769.0); EXPECT_OVERFLOW;
+  CONVERT(VarI2FromR8, -32768.51); EXPECT_OVERFLOW;
+  CONVERT(VarI2FromR8, -32768.5); EXPECT(-32768);
   CONVERT(VarI2FromR8, -32768.0); EXPECT(-32768);
   CONVERT(VarI2FromR8, -1.0);     EXPECT(-1);
   CONVERT(VarI2FromR8, 0.0);      EXPECT(0);
   CONVERT(VarI2FromR8, 1.0);      EXPECT(1);
   CONVERT(VarI2FromR8, 32767.0);  EXPECT(32767);
+  CONVERT(VarI2FromR8, 32767.49);  EXPECT(32767);
+  CONVERT(VarI2FromR8, 32767.5);  EXPECT_OVERFLOW;
   CONVERT(VarI2FromR8, 32768.0);  EXPECT_OVERFLOW;
 
   /* Rounding */
@@ -1529,9 +1553,13 @@ static void test_VarUI2FromR4(void)
 
   CHECKPTR(VarUI2FromR4);
   CONVERT(VarUI2FromR4, -1.0f);    EXPECT_OVERFLOW;
+  CONVERT(VarUI2FromR4, -0.51f);    EXPECT_OVERFLOW;
+  CONVERT(VarUI2FromR4, -0.5f);     EXPECT(0);
   CONVERT(VarUI2FromR4, 0.0f);     EXPECT(0);
   CONVERT(VarUI2FromR4, 1.0f);     EXPECT(1);
   CONVERT(VarUI2FromR4, 65535.0f); EXPECT(65535);
+  CONVERT(VarUI2FromR4, 65535.49f); EXPECT(65535);
+  CONVERT(VarUI2FromR4, 65535.5f); EXPECT_OVERFLOW;
   CONVERT(VarUI2FromR4, 65536.0f); EXPECT_OVERFLOW;
 
   /* Rounding */
@@ -1551,9 +1579,13 @@ static void test_VarUI2FromR8(void)
 
   CHECKPTR(VarUI2FromR8);
   CONVERT(VarUI2FromR8, -1.0);    EXPECT_OVERFLOW;
+  CONVERT(VarUI2FromR8, -0.51);    EXPECT_OVERFLOW;
+  CONVERT(VarUI2FromR8, -0.5);     EXPECT(0);
   CONVERT(VarUI2FromR8, 0.0);     EXPECT(0);
   CONVERT(VarUI2FromR8, 1.0);     EXPECT(1);
   CONVERT(VarUI2FromR8, 65535.0); EXPECT(65535);
+  CONVERT(VarUI2FromR8, 65535.49); EXPECT(65535);
+  CONVERT(VarUI2FromR8, 65535.5); EXPECT_OVERFLOW;
   CONVERT(VarUI2FromR8, 65536.0); EXPECT_OVERFLOW;
 
   /* Rounding */
@@ -1792,11 +1824,15 @@ static void test_VarI4FromR8(void)
 
   CHECKPTR(VarI4FromR8);
   CONVERT(VarI4FromR8, -2147483649.0); EXPECT_OVERFLOW;
+  CONVERT(VarI4FromR8, -2147483648.51); EXPECT_OVERFLOW;
+  CONVERT(VarI4FromR8, -2147483648.5); EXPECT(-2147483647 - 1);
   CONVERT(VarI4FromR8, -2147483648.0); EXPECT(-2147483647 - 1);
   CONVERT(VarI4FromR8, -1.0);          EXPECT(-1);
   CONVERT(VarI4FromR8, 0.0);           EXPECT(0);
   CONVERT(VarI4FromR8, 1.0);           EXPECT(1);
   CONVERT(VarI4FromR8, 2147483647.0);  EXPECT(2147483647);
+  CONVERT(VarI4FromR8, 2147483647.49);  EXPECT(2147483647);
+  CONVERT(VarI4FromR8, 2147483647.5);  EXPECT_OVERFLOW;
   CONVERT(VarI4FromR8, 2147483648.0);  EXPECT_OVERFLOW;
 
   CONVERT(VarI4FromR8, -1.5); EXPECT(-2);
@@ -2017,6 +2053,8 @@ static void test_VarUI4FromR4(void)
   CHECKPTR(VarUI4FromR4);
   /* We can't test max values as they are not exactly representable in a float */
   CONVERT(VarUI4FromR4, -1.0f); EXPECT_OVERFLOW;
+  CONVERT(VarUI4FromR4, -0.51f); EXPECT_OVERFLOW;
+  CONVERT(VarUI4FromR4, -0.5f);  EXPECT(0);
   CONVERT(VarUI4FromR4, 0.0f);  EXPECT(0);
   CONVERT(VarUI4FromR4, 1.0f);  EXPECT(1);
 
@@ -2037,9 +2075,13 @@ static void test_VarUI4FromR8(void)
 
   CHECKPTR(VarUI4FromR8);
   CONVERT(VarUI4FromR8, -1.0);         EXPECT_OVERFLOW;
+  CONVERT(VarUI4FromR4, -0.51f);       EXPECT_OVERFLOW;
+  CONVERT(VarUI4FromR4, -0.5f);        EXPECT(0);
   CONVERT(VarUI4FromR8, 0.0);          EXPECT(0);
   CONVERT(VarUI4FromR8, 1.0);          EXPECT(1);
   CONVERT(VarUI4FromR8, 4294967295.0); EXPECT(4294967295ul);
+  CONVERT(VarUI4FromR8, 4294967295.49); EXPECT(4294967295ul);
+  CONVERT(VarUI4FromR8, 4294967295.5); EXPECT_OVERFLOW;
   CONVERT(VarUI4FromR8, 4294967296.0); EXPECT_OVERFLOW;
 
   CONVERT(VarUI4FromR8, -1.5); EXPECT_OVERFLOW;
diff --git a/dlls/oleaut32/vartype.c b/dlls/oleaut32/vartype.c
index 43902c5..4d067e0 100644
--- a/dlls/oleaut32/vartype.c
+++ b/dlls/oleaut32/vartype.c
@@ -362,7 +362,7 @@ HRESULT WINAPI VarI1FromR4(FLOAT fltIn, signed char* pcOut)
  */
 HRESULT WINAPI VarI1FromR8(double dblIn, signed char* pcOut)
 {
-  if (dblIn < (double)I1_MIN || dblIn > (double)I1_MAX)
+  if (dblIn < I1_MIN - 0.5 || dblIn >= I1_MAX + 0.5)
     return DISP_E_OVERFLOW;
   VARIANT_DutchRound(CHAR, dblIn, *pcOut);
   return S_OK;
@@ -652,7 +652,7 @@ HRESULT WINAPI VarUI1FromR4(FLOAT fltIn, BYTE* pbOut)
  */
 HRESULT WINAPI VarUI1FromR8(double dblIn, BYTE* pbOut)
 {
-  if (dblIn < -0.5 || dblIn > (double)UI1_MAX)
+  if (dblIn < -0.5 || dblIn >= UI1_MAX + 0.5)
     return DISP_E_OVERFLOW;
   VARIANT_DutchRound(BYTE, dblIn, *pbOut);
   return S_OK;
@@ -958,7 +958,7 @@ HRESULT WINAPI VarI2FromR4(FLOAT fltIn, SHORT* psOut)
  */
 HRESULT WINAPI VarI2FromR8(double dblIn, SHORT* psOut)
 {
-  if (dblIn < (double)I2_MIN || dblIn > (double)I2_MAX)
+  if (dblIn < I2_MIN - 0.5 || dblIn >= I2_MAX + 0.5)
     return DISP_E_OVERFLOW;
   VARIANT_DutchRound(SHORT, dblIn, *psOut);
   return S_OK;
@@ -1270,7 +1270,7 @@ HRESULT WINAPI VarUI2FromR4(FLOAT fltIn, USHORT* pusOut)
  */
 HRESULT WINAPI VarUI2FromR8(double dblIn, USHORT* pusOut)
 {
-  if (dblIn < -0.5 || dblIn > (double)UI2_MAX)
+  if (dblIn < -0.5 || dblIn >= UI2_MAX + 0.5)
     return DISP_E_OVERFLOW;
   VARIANT_DutchRound(USHORT, dblIn, *pusOut);
   return S_OK;
@@ -1550,7 +1550,7 @@ HRESULT WINAPI VarI4FromR4(FLOAT fltIn, LONG *piOut)
  */
 HRESULT WINAPI VarI4FromR8(double dblIn, LONG *piOut)
 {
-  if (dblIn < (double)I4_MIN || dblIn > (double)I4_MAX)
+  if (dblIn < I4_MIN - 0.5 || dblIn >= I4_MAX + 0.5)
     return DISP_E_OVERFLOW;
   VARIANT_DutchRound(LONG, dblIn, *piOut);
   return S_OK;
@@ -1859,7 +1859,7 @@ HRESULT WINAPI VarUI4FromR4(FLOAT fltIn, ULONG *pulOut)
  */
 HRESULT WINAPI VarUI4FromR8(double dblIn, ULONG *pulOut)
 {
-  if (dblIn < -0.5 || dblIn > (double)UI4_MAX)
+  if (dblIn < -0.5 || dblIn >= UI4_MAX + 0.5)
     return DISP_E_OVERFLOW;
   VARIANT_DutchRound(ULONG, dblIn, *pulOut);
   return S_OK;
diff --git a/dlls/qcap/tests/qcap.c b/dlls/qcap/tests/qcap.c
index 9479e5d..4ad4d7c 100644
--- a/dlls/qcap/tests/qcap.c
+++ b/dlls/qcap/tests/qcap.c
@@ -1779,11 +1779,13 @@ static void test_AviMux(char *arg)
     props.cbAlign = 0xdeadbee3;
     props.cbPrefix = 0xdeadbee4;
     hr = IMemInputPin_GetAllocatorRequirements(memin, &props);
-    ok(hr == S_OK, "GetAllocatorRequirments returned %x\n", hr);
-    ok(props.cBuffers == 0xdeadbee1, "cBuffers = %d\n", props.cBuffers);
-    ok(props.cbBuffer == 0xdeadbee2, "cbBuffer = %d\n", props.cbBuffer);
-    ok(props.cbAlign == 1, "cbAlign = %d\n", props.cbAlign);
-    ok(props.cbPrefix == 8, "cbPrefix = %d\n", props.cbPrefix);
+    ok(hr==S_OK || broken(hr==E_INVALIDARG), "GetAllocatorRequirments returned %x\n", hr);
+    if(hr == S_OK) {
+        ok(props.cBuffers == 0xdeadbee1, "cBuffers = %d\n", props.cBuffers);
+        ok(props.cbBuffer == 0xdeadbee2, "cbBuffer = %d\n", props.cbBuffer);
+        ok(props.cbAlign == 1, "cbAlign = %d\n", props.cbAlign);
+        ok(props.cbPrefix == 8, "cbPrefix = %d\n", props.cbPrefix);
+    }
 
     hr = IMemInputPin_GetAllocator(memin, &memalloc);
     ok(hr == S_OK, "GetAllocator returned %x\n", hr);
@@ -1830,7 +1832,6 @@ static void test_AviMux(char *arg)
     hr = IBaseFilter_Run(avimux, 0);
     ok(hr == S_OK, "Run returned %x\n", hr);
     CHECK_CALLED(MediaSeeking_GetPositions);
-    CHECK_CALLED(MemInputPin_QueryInterface_IStream);
 
     hr = IBaseFilter_GetState(avimux, 0, &state);
     ok(hr == S_OK, "GetState returned %x\n", hr);
@@ -1911,6 +1912,7 @@ static void test_AviMux(char *arg)
 
     hr = IBaseFilter_Stop(avimux);
     ok(hr == S_OK, "Stop returned %x\n", hr);
+    CHECK_CALLED(MemInputPin_QueryInterface_IStream);
 
     hr = IBaseFilter_GetState(avimux, 0, &state);
     ok(hr == S_OK, "GetState returned %x\n", hr);
diff --git a/dlls/riched20/richole.c b/dlls/riched20/richole.c
index 6805873..6f2d579 100644
--- a/dlls/riched20/richole.c
+++ b/dlls/riched20/richole.c
@@ -515,6 +515,9 @@ ITextDocument_fnGetSelection(ITextDocument* me, ITextSelection** ppSel)
 {
     IRichEditOleImpl *This = impl_from_ITextDocument(me);
     TRACE("(%p)\n", me);
+
+    if(!ppSel)
+      return E_INVALIDARG;
     *ppSel = &This->txtSel->ITextSelection_iface;
     ITextSelection_AddRef(*ppSel);
     return S_OK;
@@ -1514,7 +1517,7 @@ LRESULT CreateIRichEditOle(ME_TextEditor *editor, LPVOID *ppObj)
         return 0;
     }
     reo->clientSite = CreateOleClientSite(reo);
-    if (!reo->txtSel)
+    if (!reo->clientSite)
     {
         ITextSelection_Release(&reo->txtSel->ITextSelection_iface);
         heap_free(reo);
diff --git a/dlls/riched20/tests/richole.c b/dlls/riched20/tests/richole.c
index 5bfb999..5a3ffbe 100644
--- a/dlls/riched20/tests/richole.c
+++ b/dlls/riched20/tests/richole.c
@@ -117,6 +117,9 @@ static void test_Interfaces(void)
   ok(hres == S_OK, "IRichEditOle_QueryInterface\n");
   ok(txtDoc != NULL, "IRichEditOle_QueryInterface\n");
 
+  hres = ITextDocument_GetSelection(txtDoc, NULL);
+  ok(hres == E_INVALIDARG, "ITextDocument_GetSelection: 0x%x\n", hres);
+
   ITextDocument_GetSelection(txtDoc, &txtSel);
 
   punk = NULL;
diff --git a/dlls/schedsvc/schedsvc.c b/dlls/schedsvc/schedsvc.c
index 988430d..5c7d359 100644
--- a/dlls/schedsvc/schedsvc.c
+++ b/dlls/schedsvc/schedsvc.c
@@ -29,6 +29,8 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(schedsvc);
 
+static const char bom_utf8[] = { 0xef,0xbb,0xbf };
+
 HRESULT __cdecl SchRpcHighestVersion(DWORD *version)
 {
     TRACE("%p\n", version);
@@ -105,7 +107,6 @@ static HRESULT create_directory(const WCHAR *path)
 
 static HRESULT write_xml_utf8(const WCHAR *name, DWORD disposition, const WCHAR *xmlW)
 {
-    static const char bom_utf8[] = { 0xef,0xbb,0xbf };
     static const char comment[] = "<!-- Task definition created by Wine -->\n";
     HANDLE hfile;
     DWORD size;
@@ -220,8 +221,6 @@ HRESULT __cdecl SchRpcRegisterTask(const WCHAR *path, const WCHAR *xml, DWORD fl
 
 static int detect_encoding(const void *buffer, DWORD size)
 {
-    static const char bom_utf8[] = { 0xef,0xbb,0xbf };
-
     if (size >= sizeof(bom_utf8) && !memcmp(buffer, bom_utf8, sizeof(bom_utf8)))
         return CP_UTF8;
     else
@@ -270,6 +269,9 @@ static HRESULT read_xml(const WCHAR *name, WCHAR **xml)
         return S_OK;
     }
 
+    if (cp == CP_UTF8 && size >= sizeof(bom_utf8) && !memcmp(src, bom_utf8, sizeof(bom_utf8)))
+        src += sizeof(bom_utf8);
+
     size = MultiByteToWideChar(cp, 0, src, -1, NULL, 0);
     *xml = heap_alloc(size * sizeof(WCHAR));
     if (!*xml) return E_OUTOFMEMORY;
diff --git a/dlls/scrrun/filesystem.c b/dlls/scrrun/filesystem.c
index c6dbb76..33344e4 100644
--- a/dlls/scrrun/filesystem.c
+++ b/dlls/scrrun/filesystem.c
@@ -2456,11 +2456,18 @@ static HRESULT WINAPI file_Move(IFile *iface, BSTR Destination)
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI file_OpenAsTextStream(IFile *iface, IOMode IOMode, Tristate Format, ITextStream **ppts)
+static HRESULT WINAPI file_OpenAsTextStream(IFile *iface, IOMode mode, Tristate format, ITextStream **stream)
 {
     struct file *This = impl_from_IFile(iface);
-    FIXME("(%p)->(%x %x %p)\n", This, IOMode, Format, ppts);
-    return E_NOTIMPL;
+
+    TRACE("(%p)->(%d %d %p)\n", This, mode, format, stream);
+
+    if (format == TristateUseDefault) {
+        FIXME("default format not handled, defaulting to unicode\n");
+        format = TristateTrue;
+    }
+
+    return create_textstream(This->path, OPEN_EXISTING, mode, format == TristateTrue, stream);
 }
 
 static const IFileVtbl file_vtbl = {
@@ -3182,8 +3189,10 @@ static inline HRESULT copy_file(const WCHAR *source, DWORD source_len,
         return CTL_E_FILENOTFOUND;
 
     src_len = get_parent_folder_name(source, source_len);
-    if(src_len+1 >= MAX_PATH)
+    if(src_len+1 >= MAX_PATH) {
+        FindClose(f);
         return E_FAIL;
+    }
     if(src_len) {
         memcpy(src_path, source, src_len*sizeof(WCHAR));
         src_path[src_len++] = '\\';
@@ -3326,10 +3335,9 @@ static HRESULT copy_folder(const WCHAR *source, DWORD source_len, const WCHAR *d
                     FindClose(f);
                     return CTL_E_FILEALREADYEXISTS;
                 }
-            }else {
-                FindClose(f);
-                return create_error(GetLastError());
             }
+
+            FindClose(f);
             return create_error(GetLastError());
         }
         copied = TRUE;
diff --git a/dlls/setupapi/fakedll.c b/dlls/setupapi/fakedll.c
index 3528e79..8e3dffb 100644
--- a/dlls/setupapi/fakedll.c
+++ b/dlls/setupapi/fakedll.c
@@ -275,8 +275,14 @@ static BOOL build_fake_dll( HANDLE file, const WCHAR *name )
 
     nt = info.nt = (IMAGE_NT_HEADERS *)(buffer + lfanew);
     /* some fields are copied from the source dll */
-#ifdef _WIN64
+#if defined __x86_64__
     nt->FileHeader.Machine = IMAGE_FILE_MACHINE_AMD64;
+#elif defined __aarch64__
+    nt->FileHeader.Machine = IMAGE_FILE_MACHINE_ARM64;
+#elif defined __arm__
+    nt->FileHeader.Machine = IMAGE_FILE_MACHINE_ARMNT;
+#elif defined __powerpc__
+    nt->FileHeader.Machine = IMAGE_FILE_MACHINE_POWERPC;
 #else
     nt->FileHeader.Machine = IMAGE_FILE_MACHINE_I386;
 #endif
diff --git a/dlls/setupapi/misc.c b/dlls/setupapi/misc.c
index 22e55d9..6bdb404 100644
--- a/dlls/setupapi/misc.c
+++ b/dlls/setupapi/misc.c
@@ -1412,7 +1412,8 @@ DWORD WINAPI SetupGetFileCompressionInfoW( PCWSTR source, PWSTR *name, PDWORD so
         return ERROR_INVALID_PARAMETER;
 
     ret = SetupGetFileCompressionInfoExW( source, NULL, 0, &required, NULL, NULL, NULL );
-    if (!(actual_name = MyMalloc( required ))) return ERROR_NOT_ENOUGH_MEMORY;
+    if (!(actual_name = MyMalloc( required * sizeof(WCHAR) )))
+        return ERROR_NOT_ENOUGH_MEMORY;
 
     ret = SetupGetFileCompressionInfoExW( source, actual_name, required, &required,
                                           source_size, target_size, type );
diff --git a/dlls/shell32/shell32.spec b/dlls/shell32/shell32.spec
index c5405d4..d73dcbb 100644
--- a/dlls/shell32/shell32.spec
+++ b/dlls/shell32/shell32.spec
@@ -347,7 +347,7 @@
 @ stdcall SHCreateShellItemArrayFromShellItem(ptr ptr ptr)
 @ stdcall SHEmptyRecycleBinA(long str long)
 @ stdcall SHEmptyRecycleBinW(long wstr long)
-@ stub SHExtractIconsW
+@ stdcall SHExtractIconsW(wstr long long long ptr ptr long long) user32.PrivateExtractIconsW
 @ stdcall SHFileOperation(ptr) SHFileOperationA
 @ stdcall SHFileOperationA(ptr)
 @ stdcall SHFileOperationW(ptr)
diff --git a/dlls/shell32/shellpath.c b/dlls/shell32/shellpath.c
index afa2543..2dfed75 100644
--- a/dlls/shell32/shellpath.c
+++ b/dlls/shell32/shellpath.c
@@ -2265,8 +2265,8 @@ HRESULT WINAPI SHGetFolderPathAndSubDirW(
     if (FAILED(hr)) goto end;
 
     if(pszSubPath) {
-        /* make sure the new path does not exceed th bufferlength
-         * rememebr to backslash and the termination */
+        /* make sure the new path does not exceed the buffer length
+         * and remember to backslash and terminate it */
         if(MAX_PATH < (lstrlenW(szBuildPath) + lstrlenW(pszSubPath) + 2)) {
             hr = HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE);
             goto end;
diff --git a/dlls/shell32/shfldr_unixfs.c b/dlls/shell32/shfldr_unixfs.c
index 10b2879..8f93e7f 100644
--- a/dlls/shell32/shfldr_unixfs.c
+++ b/dlls/shell32/shfldr_unixfs.c
@@ -170,9 +170,6 @@ WINE_DEFAULT_DEBUG_CHANNEL(shell);
 
 #if !defined(__MINGW32__) && !defined(_MSC_VER)
 
-#define ADJUST_THIS(c,m,p) ((c*)(((long)p)-(long)&(((c*)0)->lp##m##Vtbl)))
-#define STATIC_CAST(i,p) ((i*)&p->lp##i##Vtbl)
-
 #define LEN_SHITEMID_FIXED_PART ((USHORT) \
     ( sizeof(USHORT)      /* SHITEMID's cb field. */ \
     + sizeof(PIDLTYPE)    /* PIDLDATA's type field. */ \
@@ -971,14 +968,12 @@ static HRESULT WINAPI ShellFolder2_ParseDisplayName(IShellFolder2* iface, HWND h
     return result;
 }
 
-static IUnknown *UnixSubFolderIterator_Constructor(UnixFolder *pUnixFolder, SHCONTF fFilter);
+static IEnumIDList *UnixSubFolderIterator_Constructor(UnixFolder *pUnixFolder, SHCONTF fFilter);
 
 static HRESULT WINAPI ShellFolder2_EnumObjects(IShellFolder2* iface, HWND hwndOwner,
     SHCONTF grfFlags, IEnumIDList** ppEnumIDList)
 {
     UnixFolder *This = impl_from_IShellFolder2(iface);
-    IUnknown *newIterator;
-    HRESULT hr;
 
     TRACE("(%p)->(%p 0x%08x %p)\n", This, hwndOwner, grfFlags, ppEnumIDList);
 
@@ -987,11 +982,8 @@ static HRESULT WINAPI ShellFolder2_EnumObjects(IShellFolder2* iface, HWND hwndOw
         return E_UNEXPECTED;
     }
 
-    newIterator = UnixSubFolderIterator_Constructor(This, grfFlags);
-    hr = IUnknown_QueryInterface(newIterator, &IID_IEnumIDList, (void**)ppEnumIDList);
-    IUnknown_Release(newIterator);
-
-    return hr;
+    *ppEnumIDList = UnixSubFolderIterator_Constructor(This, grfFlags);
+    return S_OK;
 }
 
 static HRESULT CreateUnixFolder(IUnknown *pUnkOuter, REFIID riid, LPVOID *ppv, const CLSID *pCLSID);
@@ -2373,13 +2365,18 @@ HRESULT WINAPI MyDocuments_Constructor(IUnknown *pUnkOuter, REFIID riid, LPVOID
 /* UnixSubFolderIterator object layout and typedef.
  */
 typedef struct _UnixSubFolderIterator {
-    const IEnumIDListVtbl *lpIEnumIDListVtbl;
-    LONG m_cRef;
+    IEnumIDList IEnumIDList_iface;
+    LONG ref;
     SHCONTF m_fFilter;
     DIR *m_dirFolder;
     char m_szFolder[FILENAME_MAX];
 } UnixSubFolderIterator;
 
+static inline UnixSubFolderIterator *impl_from_IEnumIDList(IEnumIDList *iface)
+{
+    return CONTAINING_RECORD(iface, UnixSubFolderIterator, IEnumIDList_iface);
+}
+
 static void UnixSubFolderIterator_Destroy(UnixSubFolderIterator *iterator) {
     TRACE("(iterator=%p)\n", iterator);
 
@@ -2405,35 +2402,34 @@ static HRESULT WINAPI UnixSubFolderIterator_IEnumIDList_QueryInterface(IEnumIDLi
     IEnumIDList_AddRef(iface);
     return S_OK;
 }
-                            
+
 static ULONG WINAPI UnixSubFolderIterator_IEnumIDList_AddRef(IEnumIDList* iface)
 {
-    UnixSubFolderIterator *This = ADJUST_THIS(UnixSubFolderIterator, IEnumIDList, iface);
+    UnixSubFolderIterator *This = impl_from_IEnumIDList(iface);
+    ULONG ref = InterlockedIncrement(&This->ref);
 
-    TRACE("(iface=%p)\n", iface);
-   
-    return InterlockedIncrement(&This->m_cRef);
+    TRACE("(%p) ref=%d\n", This, ref);
+
+    return ref;
 }
 
 static ULONG WINAPI UnixSubFolderIterator_IEnumIDList_Release(IEnumIDList* iface)
 {
-    UnixSubFolderIterator *This = ADJUST_THIS(UnixSubFolderIterator, IEnumIDList, iface);
-    ULONG cRef;
-    
-    TRACE("(iface=%p)\n", iface);
+    UnixSubFolderIterator *This = impl_from_IEnumIDList(iface);
+    ULONG ref = InterlockedDecrement(&This->ref);
 
-    cRef = InterlockedDecrement(&This->m_cRef);
-    
-    if (!cRef) 
+    TRACE("(%p) ref=%d\n", This, ref);
+
+    if (!ref)
         UnixSubFolderIterator_Destroy(This);
 
-    return cRef;
+    return ref;
 }
 
 static HRESULT WINAPI UnixSubFolderIterator_IEnumIDList_Next(IEnumIDList* iface, ULONG celt, 
     LPITEMIDLIST* rgelt, ULONG* pceltFetched)
 {
-    UnixSubFolderIterator *This = ADJUST_THIS(UnixSubFolderIterator, IEnumIDList, iface);
+    UnixSubFolderIterator *This = impl_from_IEnumIDList(iface);
     ULONG i = 0;
 
     /* This->m_dirFolder will be NULL if the user doesn't have access rights for the dir. */
@@ -2492,8 +2488,8 @@ static HRESULT WINAPI UnixSubFolderIterator_IEnumIDList_Skip(IEnumIDList* iface,
 
 static HRESULT WINAPI UnixSubFolderIterator_IEnumIDList_Reset(IEnumIDList* iface)
 {
-    UnixSubFolderIterator *This = ADJUST_THIS(UnixSubFolderIterator, IEnumIDList, iface);
-        
+    UnixSubFolderIterator *This = impl_from_IEnumIDList(iface);
+
     TRACE("(iface=%p)\n", iface);
 
     if (This->m_dirFolder)
@@ -2521,21 +2517,20 @@ static const IEnumIDListVtbl UnixSubFolderIterator_IEnumIDList_Vtbl = {
     UnixSubFolderIterator_IEnumIDList_Clone
 };
 
-static IUnknown *UnixSubFolderIterator_Constructor(UnixFolder *pUnixFolder, SHCONTF fFilter) {
+static IEnumIDList *UnixSubFolderIterator_Constructor(UnixFolder *pUnixFolder, SHCONTF fFilter)
+{
     UnixSubFolderIterator *iterator;
 
     TRACE("(pUnixFolder=%p)\n", pUnixFolder);
-    
-    iterator = SHAlloc((ULONG)sizeof(UnixSubFolderIterator));
-    iterator->lpIEnumIDListVtbl = &UnixSubFolderIterator_IEnumIDList_Vtbl;
-    iterator->m_cRef = 0;
+
+    iterator = SHAlloc(sizeof(*iterator));
+    iterator->IEnumIDList_iface.lpVtbl = &UnixSubFolderIterator_IEnumIDList_Vtbl;
+    iterator->ref = 1;
     iterator->m_fFilter = fFilter;
     iterator->m_dirFolder = opendir(pUnixFolder->m_pszPath);
     lstrcpyA(iterator->m_szFolder, pUnixFolder->m_pszPath);
 
-    UnixSubFolderIterator_IEnumIDList_AddRef((IEnumIDList*)iterator);
-    
-    return (IUnknown*)iterator;
+    return &iterator->IEnumIDList_iface;
 }
 
 #else /* __MINGW32__ || _MSC_VER */
diff --git a/dlls/shell32/shlview_cmenu.c b/dlls/shell32/shlview_cmenu.c
index 0705948..8170011 100644
--- a/dlls/shell32/shlview_cmenu.c
+++ b/dlls/shell32/shlview_cmenu.c
@@ -285,9 +285,10 @@ static BOOL CALLBACK Properties_AddPropSheetCallback(HPROPSHEETPAGE hpage, LPARA
 	return TRUE;
 }
 
+#define MAX_PROP_PAGES 99
+
 static void DoOpenProperties(ContextMenu *This, HWND hwnd)
 {
-	static const UINT MAX_PROP_PAGES = 99;
 	static const WCHAR wszFolder[] = {'F','o','l','d','e','r', 0};
 	static const WCHAR wszFiletypeAll[] = {'*',0};
 	LPSHELLFOLDER lpDesktopSF;
diff --git a/dlls/shell32/tests/shelllink.c b/dlls/shell32/tests/shelllink.c
index c62f575..0b2b7be 100644
--- a/dlls/shell32/tests/shelllink.c
+++ b/dlls/shell32/tests/shelllink.c
@@ -42,6 +42,7 @@ static HRESULT (WINAPI *pSHDefExtractIconA)(LPCSTR, int, UINT, HICON*, HICON*, U
 static HRESULT (WINAPI *pSHGetStockIconInfo)(SHSTOCKICONID, UINT, SHSTOCKICONINFO *);
 static DWORD (WINAPI *pGetLongPathNameA)(LPCSTR, LPSTR, DWORD);
 static DWORD (WINAPI *pGetShortPathNameA)(LPCSTR, LPSTR, DWORD);
+static UINT (WINAPI *pSHExtractIconsW)(LPCWSTR, int, int, int, HICON *, UINT *, UINT, UINT);
 
 static const GUID _IID_IShellLinkDataList = {
     0x45e2b4ae, 0xb1c3, 0x11d0,
@@ -1095,6 +1096,63 @@ static void test_SHGetStockIconInfo(void)
     ok(hr == E_INVALIDARG, "NULL: got 0x%x\n", hr);
 }
 
+static void test_SHExtractIcons(void)
+{
+    static const WCHAR notepadW[] = {'n','o','t','e','p','a','d','.','e','x','e',0};
+    static const WCHAR shell32W[] = {'s','h','e','l','l','3','2','.','d','l','l',0};
+    static const WCHAR emptyW[] = {0};
+    UINT ret, ret2;
+    HICON icons[256];
+    UINT ids[256], i;
+
+    if (!pSHExtractIconsW)
+    {
+        win_skip("SHExtractIconsW not available\n");
+        return;
+    }
+
+    ret = pSHExtractIconsW(emptyW, 0, 16, 16, icons, ids, 1, 0);
+    ok(ret == ~0u, "got %u\n", ret);
+
+    ret = pSHExtractIconsW(notepadW, 0, 16, 16, NULL, NULL, 1, 0);
+    ok(ret == 1 || broken(ret == 2) /* win2k */, "got %u\n", ret);
+
+    icons[0] = (HICON)0xdeadbeef;
+    ret = pSHExtractIconsW(notepadW, 0, 16, 16, icons, NULL, 1, 0);
+    ok(ret == 1, "got %u\n", ret);
+    ok(icons[0] != (HICON)0xdeadbeef, "icon not set\n");
+    DestroyIcon(icons[0]);
+
+    icons[0] = (HICON)0xdeadbeef;
+    ids[0] = 0xdeadbeef;
+    ret = pSHExtractIconsW(notepadW, 0, 16, 16, icons, ids, 1, 0);
+    ok(ret == 1, "got %u\n", ret);
+    ok(icons[0] != (HICON)0xdeadbeef, "icon not set\n");
+    ok(ids[0] != 0xdeadbeef, "id not set\n");
+    DestroyIcon(icons[0]);
+
+    ret = pSHExtractIconsW(shell32W, 0, 16, 16, NULL, NULL, 0, 0);
+    ret2 = pSHExtractIconsW(shell32W, 4, MAKELONG(32,16), MAKELONG(32,16), NULL, NULL, 256, 0);
+    ok(ret && ret == ret2,
+       "icon count should be independent of requested icon sizes and base icon index\n");
+
+    ret = pSHExtractIconsW(shell32W, 0, 16, 16, icons, ids, 0, 0);
+    ok(ret == ~0u || !ret /* < vista */, "got %u\n", ret);
+
+    ret = pSHExtractIconsW(shell32W, 0, 16, 16, icons, ids, 3, 0);
+    ok(ret == 3, "got %u\n", ret);
+    for (i = 0; i < ret; i++) DestroyIcon(icons[i]);
+
+    /* count must be a multiple of two when getting two sizes */
+    ret = pSHExtractIconsW(shell32W, 0, MAKELONG(16,32), MAKELONG(16,32), icons, ids, 3, 0);
+    ok(!ret /* vista */ || ret == 4, "got %u\n", ret);
+    for (i = 0; i < ret; i++) DestroyIcon(icons[i]);
+
+    ret = pSHExtractIconsW(shell32W, 0, MAKELONG(16,32), MAKELONG(16,32), icons, ids, 4, 0);
+    ok(ret == 4, "got %u\n", ret);
+    for (i = 0; i < ret; i++) DestroyIcon(icons[i]);
+}
+
 START_TEST(shelllink)
 {
     HRESULT r;
@@ -1108,6 +1166,7 @@ START_TEST(shelllink)
     pSHGetStockIconInfo = (void *)GetProcAddress(hmod, "SHGetStockIconInfo");
     pGetLongPathNameA = (void *)GetProcAddress(hkernel32, "GetLongPathNameA");
     pGetShortPathNameA = (void *)GetProcAddress(hkernel32, "GetShortPathNameA");
+    pSHExtractIconsW = (void *)GetProcAddress(hmod, "SHExtractIconsW");
 
     r = CoInitialize(NULL);
     ok(r == S_OK, "CoInitialize failed (0x%08x)\n", r);
@@ -1120,6 +1179,7 @@ START_TEST(shelllink)
     test_shdefextracticon();
     test_GetIconLocation();
     test_SHGetStockIconInfo();
+    test_SHExtractIcons();
 
     CoUninitialize();
 }
diff --git a/dlls/user32/focus.c b/dlls/user32/focus.c
index bd2e572..c47a82d 100644
--- a/dlls/user32/focus.c
+++ b/dlls/user32/focus.c
@@ -277,6 +277,7 @@ HWND WINAPI SetFocus( HWND hwnd )
             HWND parent;
             LONG style = GetWindowLongW( hwndTop, GWL_STYLE );
             if (style & (WS_MINIMIZE | WS_DISABLED)) return 0;
+            if (!(style & WS_CHILD)) break;
             parent = GetAncestor( hwndTop, GA_PARENT );
             if (!parent || parent == GetDesktopWindow())
             {
diff --git a/dlls/user32/tests/resource.c b/dlls/user32/tests/resource.c
index 2313595..9cb7380 100644
--- a/dlls/user32/tests/resource.c
+++ b/dlls/user32/tests/resource.c
@@ -333,11 +333,30 @@ static void test_accel2(void)
 static void test_PrivateExtractIcons(void) {
     const CHAR szShell32Dll[] = "shell32.dll";
     HICON ahIcon[256];
-    UINT aIconId[256];
-    UINT cIcons, cIcons2;
+    UINT i, aIconId[256], cIcons, cIcons2;
 
     if (!pPrivateExtractIconsA) return;
-    
+
+    cIcons = pPrivateExtractIconsA("", 0, 16, 16, ahIcon, aIconId, 1, 0);
+    ok(cIcons == ~0u, "got %u\n", cIcons);
+
+    cIcons = pPrivateExtractIconsA("notepad.exe", 0, 16, 16, NULL, NULL, 1, 0);
+    ok(cIcons == 1 || broken(cIcons == 2) /* win2k */, "got %u\n", cIcons);
+
+    ahIcon[0] = (HICON)0xdeadbeef;
+    cIcons = pPrivateExtractIconsA("notepad.exe", 0, 16, 16, ahIcon, NULL, 1, 0);
+    ok(cIcons == 1, "got %u\n", cIcons);
+    ok(ahIcon[0] != (HICON)0xdeadbeef, "icon not set\n");
+    DestroyIcon(ahIcon[0]);
+
+    ahIcon[0] = (HICON)0xdeadbeef;
+    aIconId[0] = 0xdeadbeef;
+    cIcons = pPrivateExtractIconsA("notepad.exe", 0, 16, 16, ahIcon, aIconId, 1, 0);
+    ok(cIcons == 1, "got %u\n", cIcons);
+    ok(ahIcon[0] != (HICON)0xdeadbeef, "icon not set\n");
+    ok(aIconId[0] != 0xdeadbeef, "id not set\n");
+    DestroyIcon(ahIcon[0]);
+
     cIcons = pPrivateExtractIconsA(szShell32Dll, 0, 16, 16, NULL, NULL, 0, 0);
     cIcons2 = pPrivateExtractIconsA(szShell32Dll, 4, MAKELONG(32,16), MAKELONG(32,16), 
                                    NULL, NULL, 256, 0);
@@ -350,14 +369,18 @@ static void test_PrivateExtractIcons(void) {
 
     cIcons = pPrivateExtractIconsA(szShell32Dll, 0, 16, 16, ahIcon, aIconId, 3, 0);
     ok(cIcons == 3, "Three icons requested got cIcons=%d\n", cIcons);
+    for (i = 0; i < cIcons; i++) DestroyIcon(ahIcon[i]);
 
     /* count must be a multiple of two when getting two sizes */
     cIcons = pPrivateExtractIconsA(szShell32Dll, 0, MAKELONG(16,32), MAKELONG(16,32),
                                    ahIcon, aIconId, 3, 0);
     ok(cIcons == 0 /* vista */ || cIcons == 4, "Three icons requested got cIcons=%d\n", cIcons);
+    for (i = 0; i < cIcons; i++) DestroyIcon(ahIcon[i]);
+
     cIcons = pPrivateExtractIconsA(szShell32Dll, 0, MAKELONG(16,32), MAKELONG(16,32),
                                    ahIcon, aIconId, 4, 0);
     ok(cIcons == 4, "Four icons requested got cIcons=%d\n", cIcons);
+    for (i = 0; i < cIcons; i++) DestroyIcon(ahIcon[i]);
 }
 
 static void test_LoadImage(void)
diff --git a/dlls/user32/tests/uitools.c b/dlls/user32/tests/uitools.c
index c3f5508..5f10b00 100644
--- a/dlls/user32/tests/uitools.c
+++ b/dlls/user32/tests/uitools.c
@@ -63,7 +63,57 @@ static void test_FillRect(void)
     ReleaseDC(0, hdc);
 }
 
+static void test_SubtractRect(void)
+{
+    RECT rect1;
+    RECT rect2;
+    RECT rectr;
+    BOOL result;
+
+    /* source rectangles don't intersect */
+    SetRect(&rect1, 50, 50, 150, 100);
+    SetRect(&rect2, 250, 200, 1500, 1000);
+    result = SubtractRect(&rectr, &rect1, &rect2);
+    ok(result, "SubtractRect returned FALSE but subtraction should not be empty\n");
+    ok(result && rectr.left == 50 && rectr.top == 50 && rectr.right ==150
+        && rectr.bottom == 100, "wrong rect subtraction of SubtractRect "
+        "(dest rect={%d, %d, %d, %d})\n", rectr.left, rectr.top, rectr.right, rectr.bottom);
+
+    /* source rect 2 partially overlaps rect 1 */
+    SetRect(&rect1, 2431, 626, 3427, 1608);
+    SetRect(&rect2, 2499, 626, 3427, 1608);
+    result = SubtractRect(&rectr, &rect1, &rect2);
+    ok(result, "SubtractRect returned FALSE but subtraction should not be empty\n");
+    ok(result && rectr.left == 2431 && rectr.top == 626 && rectr.right == 2499
+        && rectr.bottom == 1608, "wrong rect subtraction of SubtractRect "
+        "(dest rect={%d, %d, %d, %d})\n", rectr.left, rectr.top, rectr.right, rectr.bottom);
+
+    /* source rect 2 partially overlaps rect 1 - dest is src rect 2 */
+    SetRect(&rect1, 2431, 626, 3427, 1608);
+    SetRect(&rect2, 2499, 626, 3427, 1608);
+    result = SubtractRect(&rect2, &rect1, &rect2);
+    ok(result, "SubtractRect returned FALSE but subtraction should not be empty\n");
+    ok(result && rectr.left == 2431 && rectr.top == 626 && rectr.right == 2499
+        && rectr.bottom == 1608, "wrong rect subtraction of SubtractRect "
+        "(dest rect={%d, %d, %d, %d})\n", rectr.left, rectr.top, rectr.right, rectr.bottom);
+
+    /* source rect 2 completely overlaps rect 1 */
+    SetRect(&rect1, 250, 250, 400, 500);
+    SetRect(&rect2, 50, 50, 1500, 1000);
+    result = SubtractRect(&rectr, &rect1, &rect2);
+    ok(!result, "SubtractRect returned TRUE but subtraction should be empty "
+        "(dest rect={%d, %d, %d, %d})\n", rectr.left, rectr.top, rectr.right, rectr.bottom);
+
+    /* source rect 2 completely overlaps rect 1 - dest is src rect 2 */
+    SetRect(&rect1, 250, 250, 400, 500);
+    SetRect(&rect2, 50, 50, 1500, 1000);
+    result = SubtractRect(&rect2, &rect1, &rect2);
+    ok(!result, "SubtractRect returned TRUE but subtraction should be empty "
+        "(dest rect={%d, %d, %d, %d})\n", rect2.left, rect2.top, rect2.right, rect2.bottom);
+}
+
 START_TEST(uitools)
 {
     test_FillRect();
+    test_SubtractRect();
 }
diff --git a/dlls/user32/tests/win.c b/dlls/user32/tests/win.c
index 69f3270..5206642 100644
--- a/dlls/user32/tests/win.c
+++ b/dlls/user32/tests/win.c
@@ -2794,6 +2794,7 @@ static void test_SetForegroundWindow(HWND hwnd)
     BOOL ret;
     HWND hwnd2;
     MSG msg;
+    LONG style;
 
     flush_events( TRUE );
     ShowWindow(hwnd, SW_HIDE);
@@ -2889,6 +2890,19 @@ static void test_SetForegroundWindow(HWND hwnd)
     todo_wine ok(GetActiveWindow() == hwnd2, "Expected active window %p, got %p.\n", hwnd2, GetActiveWindow());
     todo_wine ok(GetFocus() == hwnd2, "Expected focus window %p, got %p.\n", hwnd2, GetFocus());
 
+    SetForegroundWindow(hwnd);
+    check_wnd_state(hwnd, hwnd, hwnd, 0);
+    style = GetWindowLongA(hwnd2, GWL_STYLE) | WS_CHILD;
+    ok(SetWindowLongA(hwnd2, GWL_STYLE, style), "SetWindowLong failed\n");
+    ok(SetForegroundWindow(hwnd2), "SetForegroundWindow failed\n");
+    check_wnd_state(hwnd2, hwnd2, hwnd2, 0);
+
+    SetForegroundWindow(hwnd);
+    check_wnd_state(hwnd, hwnd, hwnd, 0);
+    ok(SetWindowLongA(hwnd2, GWL_STYLE, style & (~WS_POPUP)), "SetWindowLong failed\n");
+    ok(!SetForegroundWindow(hwnd2), "SetForegroundWindow failed\n");
+    check_wnd_state(hwnd, hwnd, hwnd, 0);
+
     SetEvent(thread_params.test_finished);
     WaitForSingleObject(thread, INFINITE);
     CloseHandle(thread_params.test_finished);
@@ -3720,21 +3734,34 @@ static void test_SetParent(void)
     ret = SetParent(popup, child1);
     ok(ret == desktop, "expected %p, got %p\n", desktop, ret);
     check_parents(popup, child1, child1, 0, 0, parent, popup);
-todo_wine
     check_active_state(popup, 0, popup);
 
     SetActiveWindow(parent);
+    SetFocus(popup);
+    check_active_state(popup, 0, popup);
+
+    EnableWindow(child1, FALSE);
+    check_active_state(popup, 0, popup);
+    SetFocus(parent);
+    check_active_state(parent, 0, parent);
+    SetFocus(popup);
+    check_active_state(popup, 0, popup);
+    EnableWindow(child1, TRUE);
+
+    ShowWindow(child1, SW_MINIMIZE);
+    SetFocus(parent);
+    check_active_state(parent, 0, parent);
+    SetFocus(popup);
+    check_active_state(popup, 0, popup);
+    ShowWindow(child1, SW_HIDE);
+
+    SetActiveWindow(parent);
     SetFocus(parent);
     check_active_state(parent, 0, parent);
 
     bret = SetForegroundWindow(popup);
-todo_wine {
-    ok(bret || broken(!bret), "SetForegroundWindow() failed\n");
-    if (!bret)
-        check_active_state(popup, 0, popup);
-    else
-        check_active_state(popup, popup, popup);
-    }
+    ok(bret, "SetForegroundWindow() failed\n");
+    check_active_state(popup, popup, popup);
 
     ok(DestroyWindow(parent), "DestroyWindow() failed\n");
 
@@ -7507,6 +7534,32 @@ START_TEST(win)
 
     if (!RegisterWindowClasses()) assert(0);
 
+    hwndMain = CreateWindowExA(/*WS_EX_TOOLWINDOW*/ 0, "MainWindowClass", "Main window",
+                               WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX |
+                               WS_MAXIMIZEBOX | WS_POPUP | WS_VISIBLE,
+                               100, 100, 200, 200,
+                               0, 0, GetModuleHandleA(NULL), NULL);
+    assert( hwndMain );
+
+    if(!SetForegroundWindow(hwndMain)) {
+        /* workaround for foreground lock timeout */
+        INPUT input[2];
+        UINT events_no;
+
+        memset(input, 0, sizeof(input));
+        input[0].type = INPUT_MOUSE;
+        input[0].mi.dx = 101;
+        input[0].mi.dy = 101;
+        input[0].mi.dwFlags = MOUSEEVENTF_LEFTDOWN;
+        input[0].type = INPUT_MOUSE;
+        input[0].mi.dx = 101;
+        input[0].mi.dy = 101;
+        input[0].mi.dwFlags = MOUSEEVENTF_LEFTUP;
+        events_no = SendInput(2, input, sizeof(input[0]));
+        ok(events_no == 2, "SendInput returned %d\n", events_no);
+        ok(SetForegroundWindow(hwndMain), "SetForegroundWindow failed\n");
+    }
+
     SetLastError(0xdeafbeef);
     GetWindowLongPtrW(GetDesktopWindow(), GWLP_WNDPROC);
     is_win9x = (GetLastError() == ERROR_CALL_NOT_IMPLEMENTED);
@@ -7518,17 +7571,11 @@ START_TEST(win)
     test_FindWindowEx();
     test_SetParent();
 
-    hwndMain = CreateWindowExA(/*WS_EX_TOOLWINDOW*/ 0, "MainWindowClass", "Main window",
-                               WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX |
-                               WS_MAXIMIZEBOX | WS_POPUP,
-                               100, 100, 200, 200,
-                               0, 0, GetModuleHandleA(NULL), NULL);
     hwndMain2 = CreateWindowExA(/*WS_EX_TOOLWINDOW*/ 0, "MainWindowClass", "Main window 2",
                                 WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX |
                                 WS_MAXIMIZEBOX | WS_POPUP,
                                 100, 100, 200, 200,
                                 0, 0, GetModuleHandleA(NULL), NULL);
-    assert( hwndMain );
     assert( hwndMain2 );
 
     our_pid = GetWindowThreadProcessId(hwndMain, NULL);
diff --git a/dlls/user32/uitools.c b/dlls/user32/uitools.c
index c11a1d3..1afb1c89 100644
--- a/dlls/user32/uitools.c
+++ b/dlls/user32/uitools.c
@@ -1421,14 +1421,14 @@ BOOL WINAPI SubtractRect( LPRECT dest, const RECT *src1, const RECT *src2 )
         SetRectEmpty( dest );
         return FALSE;
     }
-    *dest = *src1;
     if (IntersectRect( &tmp, src1, src2 ))
     {
-        if (EqualRect( &tmp, dest ))
+        if (EqualRect( &tmp, src1 ))
         {
             SetRectEmpty( dest );
             return FALSE;
         }
+        *dest = *src1;
         if ((tmp.top == dest->top) && (tmp.bottom == dest->bottom))
         {
             if (tmp.left == dest->left) dest->left = tmp.right;
@@ -1440,6 +1440,10 @@ BOOL WINAPI SubtractRect( LPRECT dest, const RECT *src1, const RECT *src2 )
             else if (tmp.bottom == dest->bottom) dest->bottom = tmp.top;
         }
     }
+    else
+    {
+        *dest = *src1;
+    }
     return TRUE;
 }
 
diff --git a/dlls/usp10/bidi.c b/dlls/usp10/bidi.c
index ceb498e..3962671 100644
--- a/dlls/usp10/bidi.c
+++ b/dlls/usp10/bidi.c
@@ -827,10 +827,13 @@ static void resolveResolved(unsigned baselevel, const WORD * pcls, WORD *plevel,
 static void computeIsolatingRunsSet(unsigned baselevel, WORD *pcls, WORD *pLevel, int uCount, struct list *set)
 {
     int run_start, run_end, i;
-    Run runs[uCount];
     int run_count = 0;
+    Run *runs;
     IsolatedRun *current_isolated;
 
+    runs = HeapAlloc(GetProcessHeap(), 0, uCount * sizeof(Run));
+    if (!runs) return;
+
     list_init(set);
 
     /* Build Runs */
@@ -857,6 +860,7 @@ static void computeIsolatingRunsSet(unsigned baselevel, WORD *pcls, WORD *pLevel
             int type_fence, real_end;
             int j;
             current_isolated = HeapAlloc(GetProcessHeap(), 0, sizeof(IsolatedRun) + sizeof(WORD*)*uCount);
+            if (!current_isolated) break;
 
             run_start = runs[k].start;
             current_isolated->e = runs[k].e;
@@ -944,6 +948,8 @@ search:
         }
         i++;
     }
+
+    HeapFree(GetProcessHeap(), 0, runs);
 }
 
 /*************************************************************
diff --git a/dlls/vbscript/compile.c b/dlls/vbscript/compile.c
index 609bb66..e1245d6 100644
--- a/dlls/vbscript/compile.c
+++ b/dlls/vbscript/compile.c
@@ -873,8 +873,10 @@ static HRESULT compile_select_statement(compile_ctx_t *ctx, select_statement_t *
             if(FAILED(hres))
                 break;
 
-            if(!emit_catch_jmp(ctx, 0, case_labels[i]))
-                return E_OUTOFMEMORY;
+            if(!emit_catch_jmp(ctx, 0, case_labels[i])) {
+                hres = E_OUTOFMEMORY;
+                break;
+            }
         }
     }
 
diff --git a/dlls/vbscript/global.c b/dlls/vbscript/global.c
index 9b6ca48..9983509 100644
--- a/dlls/vbscript/global.c
+++ b/dlls/vbscript/global.c
@@ -1886,6 +1886,8 @@ static HRESULT Err_HelpFile(vbdisp_t *This, VARIANT *args, unsigned args_cnt, VA
 
 static HRESULT Err_Number(vbdisp_t *This, VARIANT *args, unsigned args_cnt, VARIANT *res)
 {
+    HRESULT hres;
+
     TRACE("\n");
 
     if(!This->desc)
@@ -1896,7 +1898,8 @@ static HRESULT Err_Number(vbdisp_t *This, VARIANT *args, unsigned args_cnt, VARI
         return E_NOTIMPL;
     }
 
-    return return_int(res, This->desc->ctx->err_number);
+    hres = This->desc->ctx->err_number;
+    return return_int(res, HRESULT_FACILITY(hres) == FACILITY_VBS ? HRESULT_CODE(hres) : hres);
 }
 
 static HRESULT Err_Source(vbdisp_t *This, VARIANT *args, unsigned args_cnt, VARIANT *res)
diff --git a/dlls/vbscript/interp.c b/dlls/vbscript/interp.c
index a9c8766..3b5f78c 100644
--- a/dlls/vbscript/interp.c
+++ b/dlls/vbscript/interp.c
@@ -2107,7 +2107,7 @@ HRESULT exec_script(script_ctx_t *ctx, function_t *func, vbdisp_t *vbthis, DISPP
         op = exec.instr->op;
         hres = op_funcs[op](&exec);
         if(FAILED(hres)) {
-            ctx->err_number = hres;
+            ctx->err_number = hres = map_hres(hres);
 
             if(exec.resume_next) {
                 unsigned stack_off;
@@ -2124,9 +2124,8 @@ HRESULT exec_script(script_ctx_t *ctx, function_t *func, vbdisp_t *vbthis, DISPP
 
                 TRACE("unwind jmp %d stack_off %d\n", exec.instr->arg1.uint, exec.instr->arg2.uint);
 
-                instr_jmp(&exec, exec.instr->arg1.uint);
-
                 stack_off = exec.instr->arg2.uint;
+                instr_jmp(&exec, exec.instr->arg1.uint);
 
                 if(exec.top > stack_off) {
                     stack_popn(&exec, exec.top-stack_off);
diff --git a/dlls/vbscript/tests/error.vbs b/dlls/vbscript/tests/error.vbs
index 943fdd2..afe9da2 100644
--- a/dlls/vbscript/tests/error.vbs
+++ b/dlls/vbscript/tests/error.vbs
@@ -23,6 +23,57 @@ const E_TESTERROR = &h80080008&
 const VB_E_FORLOOPNOTINITIALIZED = 92
 const VB_E_OBJNOTCOLLECTION = 451
 
+const E_NOTIMPL = &h80004001&
+const E_NOINTERFACE = &h80004002&
+const DISP_E_UNKNOWNINTERFACE = &h80020001&
+const DISP_E_MEMBERNOTFOUND = &h80020003&
+const DISP_E_PARAMNOTFOUND = &h80020004&
+const DISP_E_TYPEMISMATCH = &h80020005&
+const DISP_E_UNKNOWNNAME = &h80020006&
+const DISP_E_NONAMEDARGS = &h80020007&
+const DISP_E_BADVARTYPE = &h80020008&
+const DISP_E_OVERFLOW = &h8002000A&
+const DISP_E_BADINDEX = &h8002000B&
+const DISP_E_UNKNOWNLCID = &h8002000C&
+const DISP_E_ARRAYISLOCKED = &h8002000D&
+const DISP_E_BADPARAMCOUNT = &h8002000E&
+const DISP_E_PARAMNOTOPTIONAL = &h8002000F&
+const DISP_E_NOTACOLLECTION = &h80020011&
+const TYPE_E_DLLFUNCTIONNOTFOUND = &h8002802F&
+const TYPE_E_TYPEMISMATCH = &h80028CA0&
+const TYPE_E_OUTOFBOUNDS = &h80028CA1&
+const TYPE_E_IOERROR = &h80028CA2&
+const TYPE_E_CANTCREATETMPFILE = &h80028CA3&
+const STG_E_FILENOTFOUND = &h80030002&
+const STG_E_PATHNOTFOUND = &h80030003&
+const STG_E_TOOMANYOPENFILES = &h80030004&
+const STG_E_ACCESSDENIED = &h80030005&
+const STG_E_INSUFFICIENTMEMORY = &h80030008&
+const STG_E_NOMOREFILES = &h80030012&
+const STG_E_DISKISWRITEPROTECTED = &h80030013&
+const STG_E_WRITEFAULT = &h8003001D&
+const STG_E_READFAULT = &h8003001E&
+const STG_E_SHAREVIOLATION = &h80030020&
+const STG_E_LOCKVIOLATION = &h80030021&
+const STG_E_FILEALREADYEXISTS = &h80030050&
+const STG_E_MEDIUMFULL = &h80030070&
+const STG_E_INVALIDNAME = &h800300FC&
+const STG_E_INUSE = &h80030100&
+const STG_E_NOTCURRENT = &h80030101&
+const STG_E_CANTSAVE = &h80030103&
+const REGDB_E_CLASSNOTREG = &h80040154&
+const MK_E_UNAVAILABLE = &h800401E3&
+const MK_E_INVALIDEXTENSION = &h800401E6&
+const MK_E_CANTOPENFILE = &h800401EA&
+const CO_E_CLASSSTRING = &h800401F3&
+const CO_E_APPNOTFOUND = &h800401F5&
+const O_E_APPDIDNTREG = &h800401FE&
+const E_ACCESSDENIED = &h80070005&
+const E_OUTOFMEMORY = &h8007000E&
+const E_INVALIDARG = &h80070057&
+const RPC_S_SERVER_UNAVAILABLE = &h800706BA&
+const CO_E_SERVER_EXEC_FAILURE = &h80080005&
+
 call ok(Err.Number = 0, "Err.Number = " & Err.Number)
 
 dim calledFunc
@@ -247,4 +298,77 @@ end sub
 
 call testForEachError()
 
+sub testHresMap(hres, code)
+    on error resume next
+
+    call Err.Clear()
+    call throwInt(hres)
+    call ok(Err.Number = code, "throw(" & hex(hres) & ") Err.Number = " & Err.Number)
+end sub
+
+testHresMap E_NOTIMPL, 445
+testHresMap E_NOINTERFACE, 430
+testHresMap DISP_E_UNKNOWNINTERFACE, 438
+testHresMap DISP_E_MEMBERNOTFOUND, 438
+testHresMap DISP_E_PARAMNOTFOUND, 448
+testHresMap DISP_E_TYPEMISMATCH, 13
+testHresMap DISP_E_UNKNOWNNAME, 438
+testHresMap DISP_E_NONAMEDARGS, 446
+testHresMap DISP_E_BADVARTYPE, 458
+testHresMap DISP_E_OVERFLOW, 6
+testHresMap DISP_E_BADINDEX, 9
+testHresMap DISP_E_UNKNOWNLCID, 447
+testHresMap DISP_E_ARRAYISLOCKED, 10
+testHresMap DISP_E_BADPARAMCOUNT, 450
+testHresMap DISP_E_PARAMNOTOPTIONAL, 449
+testHresMap DISP_E_NOTACOLLECTION, 451
+testHresMap TYPE_E_DLLFUNCTIONNOTFOUND, 453
+testHresMap TYPE_E_TYPEMISMATCH, 13
+testHresMap TYPE_E_OUTOFBOUNDS, 9
+testHresMap TYPE_E_IOERROR, 57
+testHresMap TYPE_E_CANTCREATETMPFILE, 322
+testHresMap STG_E_FILENOTFOUND, 432
+testHresMap STG_E_PATHNOTFOUND, 76
+testHresMap STG_E_TOOMANYOPENFILES, 67
+testHresMap STG_E_ACCESSDENIED, 70
+testHresMap STG_E_INSUFFICIENTMEMORY, 7
+testHresMap STG_E_NOMOREFILES, 67
+testHresMap STG_E_DISKISWRITEPROTECTED, 70
+testHresMap STG_E_WRITEFAULT, 57
+testHresMap STG_E_READFAULT, 57
+testHresMap STG_E_SHAREVIOLATION, 75
+testHresMap STG_E_LOCKVIOLATION, 70
+testHresMap STG_E_FILEALREADYEXISTS, 58
+testHresMap STG_E_MEDIUMFULL, 61
+testHresMap STG_E_INVALIDNAME, 53
+testHresMap STG_E_INUSE, 70
+testHresMap STG_E_NOTCURRENT, 70
+testHresMap STG_E_CANTSAVE, 57
+testHresMap REGDB_E_CLASSNOTREG, 429
+testHresMap MK_E_UNAVAILABLE, 429
+testHresMap MK_E_INVALIDEXTENSION, 432
+testHresMap MK_E_CANTOPENFILE, 432
+testHresMap CO_E_CLASSSTRING, 429
+testHresMap CO_E_APPNOTFOUND, 429
+testHresMap O_E_APPDIDNTREG, 429
+testHresMap E_ACCESSDENIED, 70
+testHresMap E_OUTOFMEMORY, 7
+testHresMap E_INVALIDARG, 5
+testHresMap RPC_S_SERVER_UNAVAILABLE, 462
+testHresMap CO_E_SERVER_EXEC_FAILURE, 429
+
+sub testVBErrorCodes()
+    on error resume next
+
+    Err.clear()
+    throwInt(&h800a00aa&)
+    call ok(Err.number = 170, "Err.number = " & Err.number)
+
+    Err.clear()
+    throwInt(&h800a10aa&)
+    call ok(Err.number = 4266, "Err.number = " & Err.number)
+end sub
+
+call testVBErrorCodes
+
 call reportSuccess()
diff --git a/dlls/vbscript/tests/run.c b/dlls/vbscript/tests/run.c
index 708f7aa..2676a37 100644
--- a/dlls/vbscript/tests/run.c
+++ b/dlls/vbscript/tests/run.c
@@ -120,6 +120,9 @@ DEFINE_EXPECT(EnableModeless);
 
 #define DISPID_COLLOBJ_RESET        3000
 
+#define FACILITY_VBS 0xa
+#define MAKE_VBSERROR(code) MAKE_HRESULT(SEVERITY_ERROR, FACILITY_VBS, code)
+
 static const WCHAR testW[] = {'t','e','s','t',0};
 static const WCHAR emptyW[] = {0};
 
@@ -1224,6 +1227,9 @@ static HRESULT WINAPI Global_InvokeEx(IDispatchEx *iface, DISPID id, LCID lcid,
             V_BOOL(pvarRes) = VARIANT_FALSE;
         }
 
+        if(V_VT(v) == (VT_VARIANT|VT_BYREF))
+            v = V_VARIANTREF(v);
+
         switch(V_VT(v)) {
         case VT_I2:
             hres = V_I2(v);
@@ -1236,7 +1242,6 @@ static HRESULT WINAPI Global_InvokeEx(IDispatchEx *iface, DISPID id, LCID lcid,
             return E_INVALIDARG;
         }
 
-        trace("throwing %08x (%d)\n", hres, hres);
         return hres;
     }
     }
@@ -1983,6 +1988,17 @@ static void run_tests(void)
     hres = parse_script_ar("throwInt(&h80080008&)");
     ok(hres == 0x80080008, "hres = %08x\n", hres);
 
+    /* DISP_E_BADINDEX */
+    hres = parse_script_ar("throwInt(&h8002000b&)");
+    ok(hres == MAKE_VBSERROR(9), "hres = %08x\n", hres);
+
+    hres = parse_script_ar("throwInt(&h800a0009&)");
+    ok(hres == MAKE_VBSERROR(9), "hres = %08x\n", hres);
+
+    /* E_NOTIMPL */
+    hres = parse_script_ar("throwInt(&h80004001&)");
+    ok(hres == MAKE_VBSERROR(445), "hres = %08x\n", hres);
+
     strict_dispid_check = FALSE;
 
     parse_script_a("Sub testsub\n"
diff --git a/dlls/vbscript/vbdisp.c b/dlls/vbscript/vbdisp.c
index 6382570..df072da 100644
--- a/dlls/vbscript/vbdisp.c
+++ b/dlls/vbscript/vbdisp.c
@@ -968,6 +968,69 @@ HRESULT disp_get_id(IDispatch *disp, BSTR name, vbdisp_invoke_type_t invoke_type
     return hres;
 }
 
+#define RPC_E_SERVER_UNAVAILABLE 0x800706ba
+
+HRESULT map_hres(HRESULT hres)
+{
+    if(SUCCEEDED(hres) || HRESULT_FACILITY(hres) == FACILITY_VBS)
+        return hres;
+
+    switch(hres) {
+    case E_NOTIMPL:                  return MAKE_VBSERROR(VBSE_ACTION_NOT_SUPPORTED);
+    case E_NOINTERFACE:              return MAKE_VBSERROR(VBSE_OLE_NOT_SUPPORTED);
+    case DISP_E_UNKNOWNINTERFACE:    return MAKE_VBSERROR(VBSE_OLE_NO_PROP_OR_METHOD);
+    case DISP_E_MEMBERNOTFOUND:      return MAKE_VBSERROR(VBSE_OLE_NO_PROP_OR_METHOD);
+    case DISP_E_PARAMNOTFOUND:       return MAKE_VBSERROR(VBSE_NAMED_PARAM_NOT_FOUND);
+    case DISP_E_TYPEMISMATCH:        return MAKE_VBSERROR(VBSE_TYPE_MISMATCH);
+    case DISP_E_UNKNOWNNAME:         return MAKE_VBSERROR(VBSE_OLE_NO_PROP_OR_METHOD);
+    case DISP_E_NONAMEDARGS:         return MAKE_VBSERROR(VBSE_NAMED_ARGS_NOT_SUPPORTED);
+    case DISP_E_BADVARTYPE:          return MAKE_VBSERROR(VBSE_INVALID_TYPELIB_VARIABLE);
+    case DISP_E_OVERFLOW:            return MAKE_VBSERROR(VBSE_OVERFLOW);
+    case DISP_E_BADINDEX:            return MAKE_VBSERROR(VBSE_OUT_OF_BOUNDS);
+    case DISP_E_UNKNOWNLCID:         return MAKE_VBSERROR(VBSE_LOCALE_SETTING_NOT_SUPPORTED);
+    case DISP_E_ARRAYISLOCKED:       return MAKE_VBSERROR(VBSE_ARRAY_LOCKED);
+    case DISP_E_BADPARAMCOUNT:       return MAKE_VBSERROR(VBSE_FUNC_ARITY_MISMATCH);
+    case DISP_E_PARAMNOTOPTIONAL:    return MAKE_VBSERROR(VBSE_PARAMETER_NOT_OPTIONAL);
+    case DISP_E_NOTACOLLECTION:      return MAKE_VBSERROR(VBSE_NOT_ENUM);
+    case TYPE_E_DLLFUNCTIONNOTFOUND: return MAKE_VBSERROR(VBSE_INVALID_DLL_FUNCTION_NAME);
+    case TYPE_E_TYPEMISMATCH:        return MAKE_VBSERROR(VBSE_TYPE_MISMATCH);
+    case TYPE_E_OUTOFBOUNDS:         return MAKE_VBSERROR(VBSE_OUT_OF_BOUNDS);
+    case TYPE_E_IOERROR:             return MAKE_VBSERROR(VBSE_IO_ERROR);
+    case TYPE_E_CANTCREATETMPFILE:   return MAKE_VBSERROR(VBSE_CANT_CREATE_TMP_FILE);
+    case STG_E_FILENOTFOUND:         return MAKE_VBSERROR(VBSE_OLE_FILE_NOT_FOUND);
+    case STG_E_PATHNOTFOUND:         return MAKE_VBSERROR(VBSE_PATH_NOT_FOUND);
+    case STG_E_TOOMANYOPENFILES:     return MAKE_VBSERROR(VBSE_TOO_MANY_FILES);
+    case STG_E_ACCESSDENIED:         return MAKE_VBSERROR(VBSE_PERMISSION_DENIED);
+    case STG_E_INSUFFICIENTMEMORY:   return MAKE_VBSERROR(VBSE_OUT_OF_MEMORY);
+    case STG_E_NOMOREFILES:          return MAKE_VBSERROR(VBSE_TOO_MANY_FILES);
+    case STG_E_DISKISWRITEPROTECTED: return MAKE_VBSERROR(VBSE_PERMISSION_DENIED);
+    case STG_E_WRITEFAULT:           return MAKE_VBSERROR(VBSE_IO_ERROR);
+    case STG_E_READFAULT:            return MAKE_VBSERROR(VBSE_IO_ERROR);
+    case STG_E_SHAREVIOLATION:       return MAKE_VBSERROR(VBSE_PATH_FILE_ACCESS);
+    case STG_E_LOCKVIOLATION:        return MAKE_VBSERROR(VBSE_PERMISSION_DENIED);
+    case STG_E_FILEALREADYEXISTS:    return MAKE_VBSERROR(VBSE_FILE_ALREADY_EXISTS);
+    case STG_E_MEDIUMFULL:           return MAKE_VBSERROR(VBSE_DISK_FULL);
+    case STG_E_INVALIDNAME:          return MAKE_VBSERROR(VBSE_FILE_NOT_FOUND);
+    case STG_E_INUSE:                return MAKE_VBSERROR(VBSE_PERMISSION_DENIED);
+    case STG_E_NOTCURRENT:           return MAKE_VBSERROR(VBSE_PERMISSION_DENIED);
+    case STG_E_CANTSAVE:             return MAKE_VBSERROR(VBSE_IO_ERROR);
+    case REGDB_E_CLASSNOTREG:        return MAKE_VBSERROR(VBSE_CANT_CREATE_OBJECT);
+    case MK_E_UNAVAILABLE:           return MAKE_VBSERROR(VBSE_CANT_CREATE_OBJECT);
+    case MK_E_INVALIDEXTENSION:      return MAKE_VBSERROR(VBSE_OLE_FILE_NOT_FOUND);
+    case MK_E_CANTOPENFILE:          return MAKE_VBSERROR(VBSE_OLE_FILE_NOT_FOUND);
+    case CO_E_CLASSSTRING:           return MAKE_VBSERROR(VBSE_CANT_CREATE_OBJECT);
+    case CO_E_APPNOTFOUND:           return MAKE_VBSERROR(VBSE_CANT_CREATE_OBJECT);
+    case CO_E_APPDIDNTREG:           return MAKE_VBSERROR(VBSE_CANT_CREATE_OBJECT);
+    case E_ACCESSDENIED:             return MAKE_VBSERROR(VBSE_PERMISSION_DENIED);
+    case E_OUTOFMEMORY:              return MAKE_VBSERROR(VBSE_OUT_OF_MEMORY);
+    case E_INVALIDARG:               return MAKE_VBSERROR(VBSE_ILLEGAL_FUNC_CALL);
+    case RPC_E_SERVER_UNAVAILABLE:   return MAKE_VBSERROR(VBSE_SERVER_NOT_FOUND);
+    case CO_E_SERVER_EXEC_FAILURE:   return MAKE_VBSERROR(VBSE_CANT_CREATE_OBJECT);
+    }
+
+    return hres;
+}
+
 HRESULT disp_call(script_ctx_t *ctx, IDispatch *disp, DISPID id, DISPPARAMS *dp, VARIANT *retv)
 {
     const WORD flags = DISPATCH_METHOD|(retv ? DISPATCH_PROPERTYGET : 0);
diff --git a/dlls/vbscript/vbscript.h b/dlls/vbscript/vbscript.h
index ecad111..c2fedd6 100644
--- a/dlls/vbscript/vbscript.h
+++ b/dlls/vbscript/vbscript.h
@@ -387,6 +387,41 @@ static inline BOOL is_int32(double d)
 
 HRESULT create_regexp(IDispatch**) DECLSPEC_HIDDEN;
 
+HRESULT map_hres(HRESULT) DECLSPEC_HIDDEN;
+
+#define FACILITY_VBS 0xa
+#define MAKE_VBSERROR(code) MAKE_HRESULT(SEVERITY_ERROR, FACILITY_VBS, code)
+
+#define VBSE_ILLEGAL_FUNC_CALL              5
+#define VBSE_OVERFLOW                       6
+#define VBSE_OUT_OF_MEMORY                  7
+#define VBSE_OUT_OF_BOUNDS                  9
+#define VBSE_ARRAY_LOCKED                  10
+#define VBSE_TYPE_MISMATCH                 13
+#define VBSE_FILE_NOT_FOUND                53
+#define VBSE_IO_ERROR                      57
+#define VBSE_FILE_ALREADY_EXISTS           58
+#define VBSE_DISK_FULL                     61
+#define VBSE_TOO_MANY_FILES                67
+#define VBSE_PERMISSION_DENIED             70
+#define VBSE_PATH_FILE_ACCESS              75
+#define VBSE_PATH_NOT_FOUND                76
+#define VBSE_OLE_NOT_SUPPORTED            430
+#define VBSE_OLE_NO_PROP_OR_METHOD        438
+#define VBSE_ACTION_NOT_SUPPORTED         445
+#define VBSE_NAMED_ARGS_NOT_SUPPORTED     446
+#define VBSE_LOCALE_SETTING_NOT_SUPPORTED 447
+#define VBSE_NAMED_PARAM_NOT_FOUND        448
+#define VBSE_INVALID_TYPELIB_VARIABLE     458
+#define VBSE_FUNC_ARITY_MISMATCH          450
+#define VBSE_PARAMETER_NOT_OPTIONAL       449
+#define VBSE_NOT_ENUM                     451
+#define VBSE_INVALID_DLL_FUNCTION_NAME    453
+#define VBSE_CANT_CREATE_TMP_FILE         322
+#define VBSE_OLE_FILE_NOT_FOUND           432
+#define VBSE_CANT_CREATE_OBJECT           429
+#define VBSE_SERVER_NOT_FOUND             462
+
 HRESULT WINAPI VBScriptFactory_CreateInstance(IClassFactory*,IUnknown*,REFIID,void**) DECLSPEC_HIDDEN;
 HRESULT WINAPI VBScriptRegExpFactory_CreateInstance(IClassFactory*,IUnknown*,REFIID,void**) DECLSPEC_HIDDEN;
 
diff --git a/dlls/wbemprox/builtin.c b/dlls/wbemprox/builtin.c
index 66f2882..9fda507 100644
--- a/dlls/wbemprox/builtin.c
+++ b/dlls/wbemprox/builtin.c
@@ -1270,11 +1270,13 @@ static enum fill_status fill_datafile( struct table *table, const struct expr *c
     DWORD drives = GetLogicalDrives();
     WIN32_FIND_DATAW data;
     HANDLE handle;
-    struct dirstack *dirstack = alloc_dirstack(2);
+    struct dirstack *dirstack;
     enum fill_status status = FILL_STATUS_UNFILTERED;
 
     if (!resize_table( table, 8, sizeof(*rec) )) return FILL_STATUS_FAILED;
 
+    dirstack = alloc_dirstack(2);
+
     for (i = 0; i < sizeof(drives); i++)
     {
         if (!(drives & (1 << i))) continue;
@@ -1300,6 +1302,7 @@ static enum fill_status fill_datafile( struct table *table, const struct expr *c
                     if (!resize_table( table, row + 1, sizeof(*rec) ))
                     {
                         status = FILL_STATUS_FAILED;
+                        FindClose( handle );
                         goto done;
                     }
                     if (!strcmpW( data.cFileName, dotW ) || !strcmpW( data.cFileName, dotdotW )) continue;
@@ -1309,6 +1312,7 @@ static enum fill_status fill_datafile( struct table *table, const struct expr *c
                     {
                         if (push_dir( dirstack, new_path, len )) continue;
                         heap_free( new_path );
+                        FindClose( handle );
                         status = FILL_STATUS_FAILED;
                         goto done;
                     }
diff --git a/dlls/wbemprox/class.c b/dlls/wbemprox/class.c
index 58fbbf8..5a9e2e4 100644
--- a/dlls/wbemprox/class.c
+++ b/dlls/wbemprox/class.c
@@ -476,17 +476,17 @@ static HRESULT WINAPI class_object_GetNames(
     TRACE("%p, %s, %08x, %s, %p\n", iface, debugstr_w(wszQualifierName), lFlags,
           debugstr_variant(pQualifierVal), pNames);
 
-    if (wszQualifierName || pQualifierVal)
-    {
-        FIXME("qualifier not supported\n");
-        return E_NOTIMPL;
-    }
-    if (lFlags != WBEM_FLAG_ALWAYS)
+    if (lFlags != WBEM_FLAG_ALWAYS &&
+        lFlags != WBEM_FLAG_NONSYSTEM_ONLY &&
+        lFlags != WBEM_FLAG_SYSTEM_ONLY)
     {
         FIXME("flags %08x not supported\n", lFlags);
         return E_NOTIMPL;
     }
-    return get_properties( ec->query->view, pNames );
+    if (wszQualifierName || pQualifierVal)
+        FIXME("qualifier not supported\n");
+
+    return get_properties( ec->query->view, lFlags, pNames );
 }
 
 static HRESULT WINAPI class_object_BeginEnumeration(
diff --git a/dlls/wbemprox/query.c b/dlls/wbemprox/query.c
index 921c3cd..fdfcc16 100644
--- a/dlls/wbemprox/query.c
+++ b/dlls/wbemprox/query.c
@@ -959,7 +959,7 @@ HRESULT put_propval( const struct view *view, UINT index, const WCHAR *name, VAR
     return set_value( view->table, row, column, val, type );
 }
 
-HRESULT get_properties( const struct view *view, SAFEARRAY **props )
+HRESULT get_properties( const struct view *view, LONG flags, SAFEARRAY **props )
 {
     SAFEARRAY *sa;
     BSTR str;
@@ -970,8 +970,14 @@ HRESULT get_properties( const struct view *view, SAFEARRAY **props )
 
     for (i = 0; i < view->table->num_cols; i++)
     {
+        BOOL is_system;
+
         if (is_method( view->table, i )) continue;
 
+        is_system = is_system_prop( view->table->columns[i].name );
+        if ((flags & WBEM_FLAG_NONSYSTEM_ONLY) && is_system) continue;
+        else if ((flags & WBEM_FLAG_SYSTEM_ONLY) && !is_system) continue;
+
         str = SysAllocString( view->table->columns[i].name );
         if (!str || SafeArrayPutElement( sa, &i, str ) != S_OK)
         {
diff --git a/dlls/wbemprox/tests/query.c b/dlls/wbemprox/tests/query.c
index 9b77b4c..e99e4ea 100644
--- a/dlls/wbemprox/tests/query.c
+++ b/dlls/wbemprox/tests/query.c
@@ -616,6 +616,40 @@ static void test_query_async( IWbemServices *services )
     SysFreeString( query );
 }
 
+void test_GetNames( IWbemServices *services )
+{
+    static const WCHAR queryW[] =
+        {'S','E','L','E','C','T',' ','*',' ','F','R','O','M',' ','W','i','n','3','2','_',
+         'O','p','e','r','a','t','i','n','g','S','y','s','t','e','m',0};
+    BSTR wql = SysAllocString( wqlW ), query = SysAllocString( queryW );
+    IEnumWbemClassObject *result;
+    HRESULT hr;
+
+    hr = IWbemServices_ExecQuery( services, wql, query, 0, NULL, &result );
+    ok( hr == S_OK, "got %08x\n", hr );
+
+    for (;;)
+    {
+        IWbemClassObject *obj;
+        SAFEARRAY *names;
+        ULONG count;
+        VARIANT val;
+
+        IEnumWbemClassObject_Next( result, 10000, 1, &obj, &count );
+        if (!count) break;
+
+        VariantInit( &val );
+        hr = IWbemClassObject_GetNames( obj, NULL, WBEM_FLAG_NONSYSTEM_ONLY, &val, &names );
+        ok( hr == S_OK, "got %08x\n", hr );
+
+        SafeArrayDestroy( names );
+        IWbemClassObject_Release( obj );
+    }
+    IEnumWbemClassObject_Release( result );
+    SysFreeString( query );
+    SysFreeString( wql );
+}
+
 START_TEST(query)
 {
     static const WCHAR cimv2W[] = {'R','O','O','T','\\','C','I','M','V','2',0};
@@ -647,6 +681,7 @@ START_TEST(query)
     test_StdRegProv( services );
     test_notification_query_async( services );
     test_query_async( services );
+    test_GetNames( services );
 
     SysFreeString( path );
     IWbemServices_Release( services );
diff --git a/dlls/wbemprox/wbemprox_private.h b/dlls/wbemprox/wbemprox_private.h
index da4f84f..c047ac1 100644
--- a/dlls/wbemprox/wbemprox_private.h
+++ b/dlls/wbemprox/wbemprox_private.h
@@ -200,7 +200,7 @@ HRESULT to_longlong( VARIANT *, LONGLONG *, CIMTYPE * ) DECLSPEC_HIDDEN;
 SAFEARRAY *to_safearray( const struct array *, CIMTYPE ) DECLSPEC_HIDDEN;
 VARTYPE to_vartype( CIMTYPE ) DECLSPEC_HIDDEN;
 void destroy_array( struct array *, CIMTYPE ) DECLSPEC_HIDDEN;
-HRESULT get_properties( const struct view *, SAFEARRAY ** ) DECLSPEC_HIDDEN;
+HRESULT get_properties( const struct view *, LONG, SAFEARRAY ** ) DECLSPEC_HIDDEN;
 HRESULT get_object( const WCHAR *, IWbemClassObject ** ) DECLSPEC_HIDDEN;
 BSTR get_method_name( const WCHAR *, UINT ) DECLSPEC_HIDDEN;
 BSTR get_property_name( const WCHAR *, UINT ) DECLSPEC_HIDDEN;
diff --git a/dlls/wined3d/arb_program_shader.c b/dlls/wined3d/arb_program_shader.c
index 1eab0eb..fc94466 100644
--- a/dlls/wined3d/arb_program_shader.c
+++ b/dlls/wined3d/arb_program_shader.c
@@ -9,7 +9,7 @@
  * Copyright 2006 Ivan Gyurdiev
  * Copyright 2006 Jason Green
  * Copyright 2006 Henri Verbeet
- * Copyright 2007-2011, 2013 Stefan Dösinger for CodeWeavers
+ * Copyright 2007-2011, 2013-2014 Stefan Dösinger for CodeWeavers
  * Copyright 2009 Henri Verbeet for CodeWeavers
  *
  * This library is free software; you can redistribute it and/or
@@ -706,7 +706,7 @@ static void shader_arb_load_constants_internal(struct shader_arb_priv *priv,
     {
         const struct wined3d_shader *pshader = state->shader[WINED3D_SHADER_TYPE_PIXEL];
         const struct arb_ps_compiled_shader *gl_shader = priv->compiled_fprog;
-        UINT rt_height = state->fb->render_targets[0]->resource.height;
+        UINT rt_height = state->fb.render_targets[0]->resource.height;
 
         /* Load DirectX 9 float constants for pixel shader */
         priv->highest_dirty_ps_const = shader_arb_load_constantsF(pshader, gl_info, GL_FRAGMENT_PROGRAM_ARB,
@@ -1792,6 +1792,11 @@ static void shader_hw_map2gl(const struct wined3d_shader_instruction *ins)
 
 static void shader_hw_nop(const struct wined3d_shader_instruction *ins) {}
 
+static DWORD shader_arb_select_component(DWORD swizzle, DWORD component)
+{
+    return ((swizzle >> 2 * component) & 0x3) * 0x55;
+}
+
 static void shader_hw_mov(const struct wined3d_shader_instruction *ins)
 {
     const struct wined3d_shader *shader = ins->ctx->shader;
@@ -1862,7 +1867,7 @@ static void shader_hw_mov(const struct wined3d_shader_instruction *ins)
              * with more than one component. Thus replicate the first source argument over all
              * 4 components. For example, .xyzw -> .x (or better: .xxxx), .zwxy -> .z, etc) */
             struct wined3d_shader_src_param tmp_src = ins->src[0];
-            tmp_src.swizzle = (tmp_src.swizzle & 0x3) * 0x55;
+            tmp_src.swizzle = shader_arb_select_component(tmp_src.swizzle, 0);
             shader_arb_get_src_param(ins, &tmp_src, 0, src0_param);
             shader_addline(buffer, "ARL A0.x, %s;\n", src0_param);
         }
@@ -2472,30 +2477,36 @@ static void shader_hw_mnxn(const struct wined3d_shader_instruction *ins)
     }
 }
 
-static void shader_hw_rcp(const struct wined3d_shader_instruction *ins)
+static DWORD abs_modifier(DWORD mod, BOOL *need_abs)
 {
-    struct wined3d_shader_buffer *buffer = ins->ctx->buffer;
-
-    char dst[50];
-    char src[50];
+    *need_abs = FALSE;
 
-    shader_arb_get_dst_param(ins, &ins->dst[0], dst); /* Destination */
-    shader_arb_get_src_param(ins, &ins->src[0], 0, src);
-    if (ins->src[0].swizzle == WINED3DSP_NOSWIZZLE)
+    switch(mod)
     {
-        /* Dx sdk says .x is used if no swizzle is given, but our test shows that
-         * .w is used
-         */
-        strcat(src, ".w");
+        case WINED3DSPSM_NONE:      return WINED3DSPSM_ABS;
+        case WINED3DSPSM_NEG:       return WINED3DSPSM_ABS;
+        case WINED3DSPSM_BIAS:      *need_abs = TRUE; return WINED3DSPSM_BIAS;
+        case WINED3DSPSM_BIASNEG:   *need_abs = TRUE; return WINED3DSPSM_BIASNEG;
+        case WINED3DSPSM_SIGN:      *need_abs = TRUE; return WINED3DSPSM_SIGN;
+        case WINED3DSPSM_SIGNNEG:   *need_abs = TRUE; return WINED3DSPSM_SIGNNEG;
+        case WINED3DSPSM_COMP:      *need_abs = TRUE; return WINED3DSPSM_COMP;
+        case WINED3DSPSM_X2:        *need_abs = TRUE; return WINED3DSPSM_X2;
+        case WINED3DSPSM_X2NEG:     *need_abs = TRUE; return WINED3DSPSM_X2NEG;
+        case WINED3DSPSM_DZ:        *need_abs = TRUE; return WINED3DSPSM_DZ;
+        case WINED3DSPSM_DW:        *need_abs = TRUE; return WINED3DSPSM_DW;
+        case WINED3DSPSM_ABS:       return WINED3DSPSM_ABS;
+        case WINED3DSPSM_ABSNEG:    return WINED3DSPSM_ABS;
     }
-
-    shader_addline(buffer, "RCP%s %s, %s;\n", shader_arb_get_modifier(ins), dst, src);
+    FIXME("Unknown modifier %u\n", mod);
+    return mod;
 }
 
 static void shader_hw_scalar_op(const struct wined3d_shader_instruction *ins)
 {
     struct wined3d_shader_buffer *buffer = ins->ctx->buffer;
     const char *instruction;
+    struct wined3d_shader_src_param src0_copy = ins->src[0];
+    BOOL need_abs = FALSE;
 
     char dst[50];
     char src[50];
@@ -2504,24 +2515,46 @@ static void shader_hw_scalar_op(const struct wined3d_shader_instruction *ins)
     {
         case WINED3DSIH_RSQ:  instruction = "RSQ"; break;
         case WINED3DSIH_RCP:  instruction = "RCP"; break;
-        case WINED3DSIH_EXP:  instruction = "EX2"; break;
-        case WINED3DSIH_EXPP: instruction = "EXP"; break;
+        case WINED3DSIH_EXPP:
+            if (ins->ctx->reg_maps->shader_version.major < 2)
+            {
+                instruction = "EXP";
+                break;
+            }
+            /* Drop through. */
+        case WINED3DSIH_EXP:
+            instruction = "EX2";
+            break;
+        case WINED3DSIH_LOG:
+        case WINED3DSIH_LOGP:
+            /* The precision requirements suggest that LOGP matches ARBvp's LOG
+             * instruction, but notice that the output of those instructions is
+             * different. */
+            src0_copy.modifiers = abs_modifier(src0_copy.modifiers, &need_abs);
+            instruction = "LG2";
+            break;
         default: instruction = "";
             FIXME("Unhandled opcode %#x\n", ins->handler_idx);
             break;
     }
 
+    /* Dx sdk says .x is used if no swizzle is given, but our test shows that
+     * .w is used. */
+    src0_copy.swizzle = shader_arb_select_component(src0_copy.swizzle, 3);
+
     shader_arb_get_dst_param(ins, &ins->dst[0], dst); /* Destination */
-    shader_arb_get_src_param(ins, &ins->src[0], 0, src);
-    if (ins->src[0].swizzle == WINED3DSP_NOSWIZZLE)
+    shader_arb_get_src_param(ins, &src0_copy, 0, src);
+
+    if(need_abs)
     {
-        /* Dx sdk says .x is used if no swizzle is given, but our test shows that
-         * .w is used
-         */
-        strcat(src, ".w");
+        shader_addline(buffer, "ABS TA.w, %s;\n", src);
+        shader_addline(buffer, "%s%s %s, TA.w;\n", instruction, shader_arb_get_modifier(ins), dst);
+    }
+    else
+    {
+        shader_addline(buffer, "%s%s %s, %s;\n", instruction, shader_arb_get_modifier(ins), dst, src);
     }
 
-    shader_addline(buffer, "%s%s %s, %s;\n", instruction, shader_arb_get_modifier(ins), dst, src);
 }
 
 static void shader_hw_nrm(const struct wined3d_shader_instruction *ins)
@@ -2761,64 +2794,6 @@ static void shader_hw_dsy(const struct wined3d_shader_instruction *ins)
     shader_addline(buffer, "MUL%s %s, %s, ycorrection.y;\n", shader_arb_get_modifier(ins), dst, dst_name);
 }
 
-static DWORD abs_modifier(DWORD mod, BOOL *need_abs)
-{
-    *need_abs = FALSE;
-
-    switch(mod)
-    {
-        case WINED3DSPSM_NONE:      return WINED3DSPSM_ABS;
-        case WINED3DSPSM_NEG:       return WINED3DSPSM_ABS;
-        case WINED3DSPSM_BIAS:      *need_abs = TRUE; return WINED3DSPSM_BIAS;
-        case WINED3DSPSM_BIASNEG:   *need_abs = TRUE; return WINED3DSPSM_BIASNEG;
-        case WINED3DSPSM_SIGN:      *need_abs = TRUE; return WINED3DSPSM_SIGN;
-        case WINED3DSPSM_SIGNNEG:   *need_abs = TRUE; return WINED3DSPSM_SIGNNEG;
-        case WINED3DSPSM_COMP:      *need_abs = TRUE; return WINED3DSPSM_COMP;
-        case WINED3DSPSM_X2:        *need_abs = TRUE; return WINED3DSPSM_X2;
-        case WINED3DSPSM_X2NEG:     *need_abs = TRUE; return WINED3DSPSM_X2NEG;
-        case WINED3DSPSM_DZ:        *need_abs = TRUE; return WINED3DSPSM_DZ;
-        case WINED3DSPSM_DW:        *need_abs = TRUE; return WINED3DSPSM_DW;
-        case WINED3DSPSM_ABS:       return WINED3DSPSM_ABS;
-        case WINED3DSPSM_ABSNEG:    return WINED3DSPSM_ABS;
-    }
-    FIXME("Unknown modifier %u\n", mod);
-    return mod;
-}
-
-static void shader_hw_log(const struct wined3d_shader_instruction *ins)
-{
-    struct wined3d_shader_buffer *buffer = ins->ctx->buffer;
-    char src0[50], dst[50];
-    struct wined3d_shader_src_param src0_copy = ins->src[0];
-    BOOL need_abs = FALSE;
-    const char *instr;
-
-    switch(ins->handler_idx)
-    {
-        case WINED3DSIH_LOG:  instr = "LG2"; break;
-        case WINED3DSIH_LOGP: instr = "LOG"; break;
-        default:
-            ERR("Unexpected instruction %d\n", ins->handler_idx);
-            return;
-    }
-
-    /* LOG and LOGP operate on the absolute value of the input */
-    src0_copy.modifiers = abs_modifier(src0_copy.modifiers, &need_abs);
-
-    shader_arb_get_dst_param(ins, &ins->dst[0], dst);
-    shader_arb_get_src_param(ins, &src0_copy, 0, src0);
-
-    if(need_abs)
-    {
-        shader_addline(buffer, "ABS TA, %s;\n", src0);
-        shader_addline(buffer, "%s%s %s, TA;\n", instr, shader_arb_get_modifier(ins), dst);
-    }
-    else
-    {
-        shader_addline(buffer, "%s%s %s, %s;\n", instr, shader_arb_get_modifier(ins), dst, src0);
-    }
-}
-
 static void shader_hw_pow(const struct wined3d_shader_instruction *ins)
 {
     struct wined3d_shader_buffer *buffer = ins->ctx->buffer;
@@ -4698,7 +4673,7 @@ static void shader_arb_select(void *shader_priv, struct wined3d_context *context
         }
         else
         {
-            UINT rt_height = state->fb->render_targets[0]->resource.height;
+            UINT rt_height = state->fb.render_targets[0]->resource.height;
             shader_arb_ps_local_constants(compiled, context, state, rt_height);
         }
 
@@ -5243,8 +5218,8 @@ static const SHADER_HANDLER shader_arb_instruction_handler_table[WINED3DSIH_TABL
     /* WINED3DSIH_LABEL                 */ shader_hw_label,
     /* WINED3DSIH_LD                    */ NULL,
     /* WINED3DSIH_LIT                   */ shader_hw_map2gl,
-    /* WINED3DSIH_LOG                   */ shader_hw_log,
-    /* WINED3DSIH_LOGP                  */ shader_hw_log,
+    /* WINED3DSIH_LOG                   */ shader_hw_scalar_op,
+    /* WINED3DSIH_LOGP                  */ shader_hw_scalar_op,
     /* WINED3DSIH_LOOP                  */ shader_hw_loop,
     /* WINED3DSIH_LRP                   */ shader_hw_lrp,
     /* WINED3DSIH_LT                    */ NULL,
@@ -5264,7 +5239,7 @@ static const SHADER_HANDLER shader_arb_instruction_handler_table[WINED3DSIH_TABL
     /* WINED3DSIH_NRM                   */ shader_hw_nrm,
     /* WINED3DSIH_PHASE                 */ shader_hw_nop,
     /* WINED3DSIH_POW                   */ shader_hw_pow,
-    /* WINED3DSIH_RCP                   */ shader_hw_rcp,
+    /* WINED3DSIH_RCP                   */ shader_hw_scalar_op,
     /* WINED3DSIH_REP                   */ shader_hw_rep,
     /* WINED3DSIH_RET                   */ shader_hw_ret,
     /* WINED3DSIH_ROUND_NI              */ NULL,
@@ -7659,7 +7634,7 @@ HRESULT arbfp_blit_surface(struct wined3d_device *device, DWORD filter,
 
     /* Now load the surface */
     if (wined3d_settings.offscreen_rendering_mode != ORM_FBO
-            && (src_surface->locations & (WINED3D_LOCATION_TEXTURE_RGB | WINED3D_LOCATION_DRAWABLE))
+            && (src_surface->resource.locations & (WINED3D_LOCATION_TEXTURE_RGB | WINED3D_LOCATION_DRAWABLE))
             == WINED3D_LOCATION_DRAWABLE
             && !surface_is_offscreen(src_surface))
     {
@@ -7689,14 +7664,16 @@ HRESULT arbfp_blit_surface(struct wined3d_device *device, DWORD filter,
     /* Leave the opengl state valid for blitting */
     arbfp_blit_unset(context->gl_info);
 
-    if (wined3d_settings.strict_draw_ordering
+    if (wined3d_settings.cs_multithreaded)
+        context->gl_info->gl_ops.gl.p_glFinish();
+    else if (wined3d_settings.strict_draw_ordering
             || (dst_surface->swapchain && (dst_surface->swapchain->front_buffer == dst_surface)))
         context->gl_info->gl_ops.gl.p_glFlush(); /* Flush to ensure ordering across contexts. */
 
     context_release(context);
 
-    surface_validate_location(dst_surface, dst_surface->draw_binding);
-    surface_invalidate_location(dst_surface, ~dst_surface->draw_binding);
+    wined3d_resource_validate_location(&dst_surface->resource, dst_surface->draw_binding);
+    wined3d_resource_invalidate_location(&dst_surface->resource, ~dst_surface->draw_binding);
 
     return WINED3D_OK;
 }
diff --git a/dlls/wined3d/buffer.c b/dlls/wined3d/buffer.c
index fbbe398..33b6ad2 100644
--- a/dlls/wined3d/buffer.c
+++ b/dlls/wined3d/buffer.c
@@ -32,17 +32,17 @@ WINE_DEFAULT_DEBUG_CHANNEL(d3d);
 #define WINED3D_BUFFER_HASDESC      0x01    /* A vertex description has been found. */
 #define WINED3D_BUFFER_CREATEBO     0x02    /* Create a buffer object for this buffer. */
 #define WINED3D_BUFFER_DOUBLEBUFFER 0x04    /* Keep both a buffer object and a system memory copy for this buffer. */
-#define WINED3D_BUFFER_FLUSH        0x08    /* Manual unmap flushing. */
-#define WINED3D_BUFFER_DISCARD      0x10    /* A DISCARD lock has occurred since the last preload. */
-#define WINED3D_BUFFER_NOSYNC       0x20    /* All locks since the last preload had NOOVERWRITE set. */
-#define WINED3D_BUFFER_APPLESYNC    0x40    /* Using sync as in GL_APPLE_flush_buffer_range. */
+#define WINED3D_BUFFER_DISCARD      0x08    /* The next PreLoad may discard the buffer contents. */
+#define WINED3D_BUFFER_NOSYNC       0x10    /* All locks since the last preload had NOOVERWRITE set. */
+#define WINED3D_BUFFER_APPLESYNC    0x20    /* Using sync as in GL_APPLE_flush_buffer_range. */
+#define WINED3D_BUFFER_DISCARDED    0x40    /* The buffer has been discarded since the last draw. */
 
 #define VB_MAXDECLCHANGES     100     /* After that number of decl changes we stop converting */
 #define VB_RESETDECLCHANGE    1000    /* Reset the decl changecount after that number of draws */
 #define VB_MAXFULLCONVERSIONS 5       /* Number of full conversions before we stop converting */
 #define VB_RESETFULLCONVS     20      /* Reset full conversion counts after that number of draws */
 
-static void buffer_invalidate_bo_range(struct wined3d_buffer *buffer, UINT offset, UINT size)
+void buffer_invalidate_bo_range(struct wined3d_buffer *buffer, UINT offset, UINT size)
 {
     if (!offset && !size)
         goto invalidate_all;
@@ -118,7 +118,7 @@ static void delete_gl_buffer(struct wined3d_buffer *This, const struct wined3d_g
 }
 
 /* Context activation is done by the caller. */
-static void buffer_create_buffer_object(struct wined3d_buffer *This, struct wined3d_context *context)
+void buffer_create_buffer_object(struct wined3d_buffer *This, struct wined3d_context *context)
 {
     GLenum gl_usage = GL_STATIC_DRAW_ARB;
     GLenum error;
@@ -167,8 +167,6 @@ static void buffer_create_buffer_object(struct wined3d_buffer *This, struct wine
         {
             GL_EXTCALL(glBufferParameteriAPPLE(This->buffer_type_hint, GL_BUFFER_FLUSHING_UNMAP_APPLE, GL_FALSE));
             checkGLcall("glBufferParameteriAPPLE(This->buffer_type_hint, GL_BUFFER_FLUSHING_UNMAP_APPLE, GL_FALSE)");
-            This->flags |= WINED3D_BUFFER_FLUSH;
-
             GL_EXTCALL(glBufferParameteriAPPLE(This->buffer_type_hint, GL_BUFFER_SERIALIZED_MODIFY_APPLE, GL_FALSE));
             checkGLcall("glBufferParameteriAPPLE(This->buffer_type_hint, GL_BUFFER_SERIALIZED_MODIFY_APPLE, GL_FALSE)");
             This->flags |= WINED3D_BUFFER_APPLESYNC;
@@ -194,7 +192,10 @@ static void buffer_create_buffer_object(struct wined3d_buffer *This, struct wine
     if (This->flags & WINED3D_BUFFER_DOUBLEBUFFER)
         buffer_invalidate_bo_range(This, 0, 0);
     else
+    {
         wined3d_resource_free_sysmem(&This->resource);
+        This->map_mem = NULL;
+    }
 
     return;
 
@@ -423,7 +424,7 @@ static inline void fixup_d3dcolor(DWORD *dst_color)
 {
     DWORD src_color = *dst_color;
 
-    /* Color conversion like in drawStridedSlow. watch out for little endianity
+    /* Color conversion like in draw_strided_slow. watch out for little endianity
      * If we want that stuff to work on big endian machines too we have to consider more things
      *
      * 0xff000000: Alpha mask
@@ -457,7 +458,8 @@ void buffer_get_memory(struct wined3d_buffer *buffer, struct wined3d_context *co
     data->buffer_object = buffer->buffer_object;
     if (!buffer->buffer_object)
     {
-        if ((buffer->flags & WINED3D_BUFFER_CREATEBO) && !buffer->resource.map_count)
+        if ((!buffer->resource.map_count || buffer->flags & WINED3D_BUFFER_DOUBLEBUFFER)
+                && buffer->flags & WINED3D_BUFFER_CREATEBO)
         {
             buffer_create_buffer_object(buffer, context);
             buffer->flags &= ~WINED3D_BUFFER_CREATEBO;
@@ -496,6 +498,8 @@ BYTE *buffer_get_sysmem(struct wined3d_buffer *This, struct wined3d_context *con
 
     if (!wined3d_resource_allocate_sysmem(&This->resource))
         ERR("Failed to allocate system memory.\n");
+    This->resource.heap_memory = This->resource.map_heap_memory;
+    This->map_mem = This->resource.heap_memory;
 
     if (This->buffer_type_hint == GL_ELEMENT_ARRAY_BUFFER_ARB)
         context_invalidate_state(context, STATE_INDEXBUFFER);
@@ -543,28 +547,38 @@ static void buffer_unload(struct wined3d_resource *resource)
     resource_unload(resource);
 }
 
+void wined3d_buffer_cleanup_cs(struct wined3d_buffer *buffer)
+{
+    struct wined3d_context *context;
+    struct wined3d_device *device = buffer->resource.device;
+
+    if (buffer->buffer_object)
+    {
+        context = context_acquire(device, NULL);
+        delete_gl_buffer(buffer, context->gl_info);
+        context_release(context);
+
+        HeapFree(GetProcessHeap(), 0, buffer->conversion_map);
+    }
+
+    HeapFree(GetProcessHeap(), 0, buffer->maps);
+    HeapFree(GetProcessHeap(), 0, buffer);
+}
+
 ULONG CDECL wined3d_buffer_decref(struct wined3d_buffer *buffer)
 {
     ULONG refcount = InterlockedDecrement(&buffer->resource.ref);
-    struct wined3d_context *context;
 
     TRACE("%p decreasing refcount to %u.\n", buffer, refcount);
 
     if (!refcount)
     {
-        if (buffer->buffer_object)
-        {
-            context = context_acquire(buffer->resource.device, NULL);
-            delete_gl_buffer(buffer, context->gl_info);
-            context_release(context);
-
-            HeapFree(GetProcessHeap(), 0, buffer->conversion_map);
-        }
+        struct wined3d_device *device = buffer->resource.device;
 
         resource_cleanup(&buffer->resource);
+
         buffer->resource.parent_ops->wined3d_object_destroyed(buffer->resource.parent);
-        HeapFree(GetProcessHeap(), 0, buffer->maps);
-        HeapFree(GetProcessHeap(), 0, buffer);
+        wined3d_cs_emit_buffer_cleanup(device->cs, buffer);
     }
 
     return refcount;
@@ -659,43 +673,17 @@ drop_query:
 /* The caller provides a GL context */
 static void buffer_direct_upload(struct wined3d_buffer *This, const struct wined3d_gl_info *gl_info, DWORD flags)
 {
-    BYTE *map;
     UINT start = 0, len = 0;
 
     /* This potentially invalidates the element array buffer binding, but the
      * caller always takes care of this. */
     GL_EXTCALL(glBindBufferARB(This->buffer_type_hint, This->buffer_object));
     checkGLcall("glBindBufferARB");
-    if (gl_info->supported[ARB_MAP_BUFFER_RANGE])
-    {
-        GLbitfield mapflags;
-        mapflags = GL_MAP_WRITE_BIT | GL_MAP_FLUSH_EXPLICIT_BIT;
-        if (flags & WINED3D_BUFFER_DISCARD)
-            mapflags |= GL_MAP_INVALIDATE_BUFFER_BIT;
-        if (flags & WINED3D_BUFFER_NOSYNC)
-            mapflags |= GL_MAP_UNSYNCHRONIZED_BIT;
-        map = GL_EXTCALL(glMapBufferRange(This->buffer_type_hint, 0,
-                    This->resource.size, mapflags));
-        checkGLcall("glMapBufferRange");
-    }
-    else
-    {
-        if (This->flags & WINED3D_BUFFER_APPLESYNC)
-        {
-            DWORD syncflags = 0;
-            if (flags & WINED3D_BUFFER_DISCARD)
-                syncflags |= WINED3D_MAP_DISCARD;
-            if (flags & WINED3D_BUFFER_NOSYNC)
-                syncflags |= WINED3D_MAP_NOOVERWRITE;
-            buffer_sync_apple(This, syncflags, gl_info);
-        }
-        map = GL_EXTCALL(glMapBufferARB(This->buffer_type_hint, GL_WRITE_ONLY_ARB));
-        checkGLcall("glMapBufferARB");
-    }
-    if (!map)
+
+    if (flags & WINED3D_BUFFER_DISCARD)
     {
-        ERR("Failed to map opengl buffer\n");
-        return;
+        GL_EXTCALL(glBufferDataARB(This->buffer_type_hint, This->resource.size, NULL, GL_STREAM_DRAW_ARB));
+        checkGLcall("glBufferDataARB");
     }
 
     while (This->modified_areas)
@@ -704,21 +692,9 @@ static void buffer_direct_upload(struct wined3d_buffer *This, const struct wined
         start = This->maps[This->modified_areas].offset;
         len = This->maps[This->modified_areas].size;
 
-        memcpy(map + start, (BYTE *)This->resource.heap_memory + start, len);
-
-        if (gl_info->supported[ARB_MAP_BUFFER_RANGE])
-        {
-            GL_EXTCALL(glFlushMappedBufferRange(This->buffer_type_hint, start, len));
-            checkGLcall("glFlushMappedBufferRange");
-        }
-        else if (This->flags & WINED3D_BUFFER_FLUSH)
-        {
-            GL_EXTCALL(glFlushMappedBufferRangeAPPLE(This->buffer_type_hint, start, len));
-            checkGLcall("glFlushMappedBufferRangeAPPLE");
-        }
+        GL_EXTCALL(glBufferSubDataARB(This->buffer_type_hint, start, len, (BYTE *)This->resource.heap_memory + start));
+        checkGLcall("glBufferSubDataARB");
     }
-    GL_EXTCALL(glUnmapBufferARB(This->buffer_type_hint));
-    checkGLcall("glUnmapBufferARB");
 }
 
 /* Context activation is done by the caller. */
@@ -735,12 +711,6 @@ void buffer_internal_preload(struct wined3d_buffer *buffer, struct wined3d_conte
 
     TRACE("buffer %p.\n", buffer);
 
-    if (buffer->resource.map_count)
-    {
-        WARN("Buffer is mapped, skipping preload.\n");
-        return;
-    }
-
     buffer->flags &= ~(WINED3D_BUFFER_NOSYNC | WINED3D_BUFFER_DISCARD);
 
     if (!buffer->buffer_object)
@@ -929,10 +899,15 @@ void buffer_internal_preload(struct wined3d_buffer *buffer, struct wined3d_conte
 
 void CDECL wined3d_buffer_preload(struct wined3d_buffer *buffer)
 {
-    struct wined3d_context *context;
-    context = context_acquire(buffer->resource.device, NULL);
-    buffer_internal_preload(buffer, context, NULL);
-    context_release(context);
+    struct wined3d_device *device = buffer->resource.device;
+
+    if (buffer->resource.map_count)
+    {
+        WARN("Buffer is mapped, skipping preload.\n");
+        return;
+    }
+
+    wined3d_cs_emit_buffer_preload(device->cs, buffer);
 }
 
 struct wined3d_resource * CDECL wined3d_buffer_get_resource(struct wined3d_buffer *buffer)
@@ -946,9 +921,31 @@ HRESULT CDECL wined3d_buffer_map(struct wined3d_buffer *buffer, UINT offset, UIN
 {
     LONG count;
     BYTE *base;
+    struct wined3d_device *device = buffer->resource.device;
+    struct wined3d_context *context;
 
     TRACE("buffer %p, offset %u, size %u, data %p, flags %#x\n", buffer, offset, size, data, flags);
 
+    /* FIXME: There is a race condition with the same code in
+     * buffer_internal_preload and buffer_get_memory.
+     *
+     * This deals with a race condition concering buffer creation and buffer maps.
+     * If a VBO is created by the worker thread while the buffer is mapped, outdated
+     * data may be uploaded, and the BO range is not properly invaliated. Keep in
+     * mind that a broken application might draw from a buffer before mapping it.
+     *
+     * Don't try to solve this by going back to always invalidating changed areas.
+     * This won't work if we ever want to support glMapBufferRange mapping with
+     * GL_ARB_buffer_storage in the CS.
+     *
+     * Also keep in mind that UnLoad can destroy the VBO, so simply creating it
+     * on buffer creation won't work either. */
+    if (buffer->flags & WINED3D_BUFFER_CREATEBO)
+    {
+        wined3d_cs_emit_create_vbo(device->cs, buffer);
+        buffer->flags &= ~WINED3D_BUFFER_CREATEBO;
+    }
+
     flags = wined3d_resource_sanitize_map_flags(&buffer->resource, flags);
     /* Filter redundant WINED3D_MAP_DISCARD maps. The 3DMark2001 multitexture
      * fill rate test seems to depend on this. When we map a buffer with
@@ -956,7 +953,7 @@ HRESULT CDECL wined3d_buffer_map(struct wined3d_buffer *buffer, UINT offset, UIN
      * previous contents of the buffer. The r600g driver only does this when
      * the buffer is currently in use, while the proprietary NVIDIA driver
      * appears to do this unconditionally. */
-    if (buffer->flags & WINED3D_BUFFER_DISCARD)
+    if (buffer->flags & WINED3D_BUFFER_DISCARDED)
         flags &= ~WINED3D_MAP_DISCARD;
     count = ++buffer->resource.map_count;
 
@@ -967,18 +964,24 @@ HRESULT CDECL wined3d_buffer_map(struct wined3d_buffer *buffer, UINT offset, UIN
          * being uploaded in that case. Two such applications are Port Royale
          * and Darkstar One. */
         if (flags & WINED3D_MAP_DISCARD)
-            buffer_invalidate_bo_range(buffer, 0, 0);
+            wined3d_cs_emit_buffer_invalidate_bo_range(device->cs, buffer, 0, 0);
         else if (!(flags & WINED3D_MAP_READONLY))
-            buffer_invalidate_bo_range(buffer, offset, size);
+            wined3d_cs_emit_buffer_invalidate_bo_range(device->cs, buffer, offset, size);
 
         if (!(buffer->flags & WINED3D_BUFFER_DOUBLEBUFFER))
         {
             if (count == 1)
             {
                 struct wined3d_device *device = buffer->resource.device;
-                struct wined3d_context *context;
                 const struct wined3d_gl_info *gl_info;
 
+                if (wined3d_settings.cs_multithreaded)
+                {
+                    FIXME("waiting for cs\n");
+                    wined3d_cs_emit_glfinish(device->cs);
+                    device->cs->ops->finish(device->cs);
+                }
+
                 context = context_acquire(device, NULL);
                 gl_info = context->gl_info;
 
@@ -1030,20 +1033,47 @@ HRESULT CDECL wined3d_buffer_map(struct wined3d_buffer *buffer, UINT offset, UIN
                     TRACE("New pointer is %p.\n", buffer->resource.heap_memory);
                     buffer->map_ptr = NULL;
                 }
+                buffer->map_mem = buffer->resource.heap_memory;
                 context_release(context);
             }
         }
+        else if(!wined3d_settings.cs_multithreaded)
+        {
+            if (flags & WINED3D_MAP_DISCARD)
+                buffer->flags |= WINED3D_BUFFER_DISCARD;
 
+            if (buffer_is_dirty(buffer))
+            {
+                if (buffer->flags & WINED3D_BUFFER_NOSYNC && !(flags & WINED3D_MAP_NOOVERWRITE))
+                {
+                    buffer->flags &= ~WINED3D_BUFFER_NOSYNC;
+                }
+            }
+            else if(flags & WINED3D_MAP_NOOVERWRITE)
+            {
+                buffer->flags |= WINED3D_BUFFER_NOSYNC;
+            }
+        }
         if (flags & WINED3D_MAP_DISCARD)
-            buffer->flags |= WINED3D_BUFFER_DISCARD;
+            buffer->flags |= WINED3D_BUFFER_DISCARDED;
+
+    }
 
-        if (!(flags & WINED3D_MAP_NOOVERWRITE))
-            buffer->flags &= ~WINED3D_BUFFER_NOSYNC;
-        else if (!buffer_is_dirty(buffer))
-            buffer->flags |= WINED3D_BUFFER_NOSYNC;
+    if (wined3d_settings.cs_multithreaded && count == 1)
+    {
+        BOOL swvp = device->create_parms.flags & WINED3DCREATE_SOFTWARE_VERTEXPROCESSING;
+        if (flags & WINED3D_MAP_DISCARD && !swvp)
+        {
+            buffer->map_mem = wined3d_resource_allocate_sysmem2(&buffer->resource);
+            wined3d_cs_emit_swap_mem(device->cs, buffer, buffer->map_mem);
+        }
+        else if(!(flags & (WINED3D_MAP_NOOVERWRITE | WINED3D_MAP_READONLY)))
+        {
+            wined3d_resource_wait_fence((struct wined3d_resource *)buffer);
+        }
     }
 
-    base = buffer->map_ptr ? buffer->map_ptr : buffer->resource.heap_memory;
+    base = buffer->map_ptr ? buffer->map_ptr : buffer->map_mem;
     *data = base + offset;
 
     TRACE("Returning memory at %p (base %p, offset %u).\n", *data, base, offset);
@@ -1097,7 +1127,7 @@ void CDECL wined3d_buffer_unmap(struct wined3d_buffer *buffer)
                 checkGLcall("glFlushMappedBufferRange");
             }
         }
-        else if (buffer->flags & WINED3D_BUFFER_FLUSH)
+        else if (buffer->flags & WINED3D_BUFFER_APPLESYNC)
         {
             for (i = 0; i < buffer->modified_areas; ++i)
             {
@@ -1108,22 +1138,35 @@ void CDECL wined3d_buffer_unmap(struct wined3d_buffer *buffer)
         }
 
         GL_EXTCALL(glUnmapBufferARB(buffer->buffer_type_hint));
-        if (wined3d_settings.strict_draw_ordering)
+        if (wined3d_settings.cs_multithreaded)
+            gl_info->gl_ops.gl.p_glFinish();
+        else if (wined3d_settings.strict_draw_ordering)
             gl_info->gl_ops.gl.p_glFlush(); /* Flush to ensure ordering across contexts. */
         context_release(context);
 
+        buffer->map_mem = NULL;
         buffer_clear_dirty_areas(buffer);
         buffer->map_ptr = NULL;
     }
-    else if (buffer->flags & WINED3D_BUFFER_HASDESC)
-    {
-        wined3d_buffer_preload(buffer);
-    }
+}
+
+static void wined3d_buffer_location_invalidated(struct wined3d_resource *resource, DWORD location)
+{
+    ERR("Not yet implemented.\n");
+}
+
+/* Context activation is done by the caller. */
+static void wined3d_buffer_load_location(struct wined3d_resource *resource,
+        struct wined3d_context *context, DWORD location)
+{
+    ERR("Not yet implemented.\n");
 }
 
 static const struct wined3d_resource_ops buffer_resource_ops =
 {
     buffer_unload,
+    wined3d_buffer_location_invalidated,
+    wined3d_buffer_load_location,
 };
 
 static HRESULT buffer_init(struct wined3d_buffer *buffer, struct wined3d_device *device,
@@ -1150,6 +1193,7 @@ static HRESULT buffer_init(struct wined3d_buffer *buffer, struct wined3d_device
         return hr;
     }
     buffer->buffer_type_hint = bind_hint;
+    buffer->map_mem = buffer->resource.heap_memory;
 
     TRACE("size %#x, usage %#x, format %s, memory @ %p, iface @ %p.\n", buffer->resource.size, buffer->resource.usage,
             debug_d3dformat(buffer->resource.format->id), buffer->resource.heap_memory, buffer);
@@ -1165,11 +1209,11 @@ static HRESULT buffer_init(struct wined3d_buffer *buffer, struct wined3d_device
 
     dynamic_buffer_ok = gl_info->supported[APPLE_FLUSH_BUFFER_RANGE] || gl_info->supported[ARB_MAP_BUFFER_RANGE];
 
-    /* Observations show that drawStridedSlow is faster on dynamic VBs than converting +
+    /* Observations show that draw_strided_slow is faster on dynamic VBs than converting +
      * drawStridedFast (half-life 2 and others).
      *
      * Basically converting the vertices in the buffer is quite expensive, and observations
-     * show that drawStridedSlow is faster than converting + uploading + drawStridedFast.
+     * show that draw_strided_slow is faster than converting + uploading + drawStridedFast.
      * Therefore do not create a VBO for WINED3DUSAGE_DYNAMIC buffers.
      */
     if (!gl_info->supported[ARB_VERTEX_BUFFER_OBJECT])
@@ -1217,6 +1261,9 @@ static HRESULT buffer_init(struct wined3d_buffer *buffer, struct wined3d_device
     }
     buffer->maps_size = 1;
 
+    if (wined3d_settings.cs_multithreaded)
+        buffer->flags |= WINED3D_BUFFER_DOUBLEBUFFER;
+
     return WINED3D_OK;
 }
 
@@ -1322,3 +1369,10 @@ HRESULT CDECL wined3d_buffer_create_ib(struct wined3d_device *device, UINT size,
 
     return WINED3D_OK;
 }
+
+void buffer_swap_mem(struct wined3d_buffer *buffer, BYTE *mem)
+{
+    wined3d_resource_free_sysmem(&buffer->resource);
+    buffer->resource.heap_memory = mem;
+    buffer->flags |= WINED3D_BUFFER_DISCARD;
+}
diff --git a/dlls/wined3d/context.c b/dlls/wined3d/context.c
index 56673c7..02bb4a5 100644
--- a/dlls/wined3d/context.c
+++ b/dlls/wined3d/context.c
@@ -719,9 +719,10 @@ void context_surface_update(struct wined3d_context *context, const struct wined3
     }
 }
 
-static void context_restore_pixel_format(struct wined3d_context *ctx)
+static BOOL context_restore_pixel_format(struct wined3d_context *ctx)
 {
     const struct wined3d_gl_info *gl_info = ctx->gl_info;
+    BOOL ret = FALSE;
 
     if (ctx->restore_pf && IsWindow(ctx->restore_pf_win))
     {
@@ -730,7 +731,7 @@ static void context_restore_pixel_format(struct wined3d_context *ctx)
             HDC dc = GetDC(ctx->restore_pf_win);
             if (dc)
             {
-                if (!GL_EXTCALL(wglSetPixelFormatWINE(dc, ctx->restore_pf)))
+                if (!(ret = GL_EXTCALL(wglSetPixelFormatWINE(dc, ctx->restore_pf))))
                 {
                     ERR("wglSetPixelFormatWINE failed to restore pixel format %d on window %p.\n",
                             ctx->restore_pf, ctx->restore_pf_win);
@@ -746,14 +747,19 @@ static void context_restore_pixel_format(struct wined3d_context *ctx)
 
     ctx->restore_pf = 0;
     ctx->restore_pf_win = NULL;
+    return ret;
 }
 
-static BOOL context_set_pixel_format(struct wined3d_context *context, HDC dc, int format)
+static BOOL context_set_pixel_format(struct wined3d_context *context, HDC dc, BOOL private, int format)
 {
     const struct wined3d_gl_info *gl_info = context->gl_info;
-    int current = GetPixelFormat(dc);
+    int current;
+
+    if (dc == context->hdc && context->hdc_is_private && context->hdc_has_format)
+        return TRUE;
 
-    if (current == format) return TRUE;
+    current = GetPixelFormat(dc);
+    if (current == format) goto success;
 
     if (!current)
     {
@@ -766,8 +772,8 @@ static BOOL context_set_pixel_format(struct wined3d_context *context, HDC dc, in
         }
 
         context->restore_pf = 0;
-        context->restore_pf_win = WindowFromDC(dc);
-        return TRUE;
+        context->restore_pf_win = private ? NULL : WindowFromDC(dc);
+        goto success;
     }
 
     /* By default WGL doesn't allow pixel format adjustments but we need it
@@ -785,16 +791,16 @@ static BOOL context_set_pixel_format(struct wined3d_context *context, HDC dc, in
             return FALSE;
         }
 
-        win = WindowFromDC(dc);
+        win = private ? NULL : WindowFromDC(dc);
         if (win != context->restore_pf_win)
         {
             context_restore_pixel_format(context);
 
-            context->restore_pf = current;
+            context->restore_pf = private ? 0 : current;
             context->restore_pf_win = win;
         }
 
-        return TRUE;
+        goto success;
     }
 
     /* OpenGL doesn't allow pixel format adjustments. Print an error and
@@ -804,6 +810,11 @@ static BOOL context_set_pixel_format(struct wined3d_context *context, HDC dc, in
     ERR("Unable to set pixel format %d on device context %p. Already using format %d.\n",
             format, dc, current);
     return TRUE;
+
+success:
+    if (dc == context->hdc && context->hdc_is_private)
+        context->hdc_has_format = TRUE;
+    return TRUE;
 }
 
 static BOOL context_set_gl_context(struct wined3d_context *ctx)
@@ -811,7 +822,7 @@ static BOOL context_set_gl_context(struct wined3d_context *ctx)
     struct wined3d_swapchain *swapchain = ctx->swapchain;
     BOOL backup = FALSE;
 
-    if (!context_set_pixel_format(ctx, ctx->hdc, ctx->pixel_format))
+    if (!context_set_pixel_format(ctx, ctx->hdc, ctx->hdc_is_private, ctx->pixel_format))
     {
         WARN("Failed to set pixel format %d on device context %p.\n",
                 ctx->pixel_format, ctx->hdc);
@@ -844,7 +855,7 @@ static BOOL context_set_gl_context(struct wined3d_context *ctx)
             return FALSE;
         }
 
-        if (!context_set_pixel_format(ctx, dc, ctx->pixel_format))
+        if (!context_set_pixel_format(ctx, dc, TRUE, ctx->pixel_format))
         {
             ERR("Failed to set pixel format %d on device context %p.\n",
                     ctx->pixel_format, dc);
@@ -884,24 +895,20 @@ static void context_update_window(struct wined3d_context *context)
     TRACE("Updating context %p window from %p to %p.\n",
             context, context->win_handle, context->swapchain->win_handle);
 
-    if (context->valid)
+    if (context->hdc)
         wined3d_release_dc(context->win_handle, context->hdc);
-    else
-        context->valid = 1;
 
     context->win_handle = context->swapchain->win_handle;
+    context->hdc_is_private = FALSE;
+    context->hdc_has_format = FALSE;
     context->needs_set = 1;
+    context->valid = 1;
 
     if (!(context->hdc = GetDC(context->win_handle)))
     {
         ERR("Failed to get a device context for window %p.\n", context->win_handle);
-        goto err;
+        context->valid = 0;
     }
-
-    return;
-
-err:
-    context->valid = 0;
 }
 
 static void context_destroy_gl_resources(struct wined3d_context *context)
@@ -1094,7 +1101,8 @@ void context_release(struct wined3d_context *context)
 
     if (!--context->level)
     {
-        context_restore_pixel_format(context);
+        if (context_restore_pixel_format(context))
+            context->needs_set = 1;
         if (context->restore_ctx)
         {
             TRACE("Restoring GL context %p on device context %p.\n", context->restore_ctx, context->restore_dc);
@@ -1122,7 +1130,8 @@ static void context_enter(struct wined3d_context *context)
             context->restore_dc = wglGetCurrentDC();
             context->needs_set = 1;
         }
-        else if (context->pixel_format != GetPixelFormat(context->hdc))
+        else if (!context->needs_set && !(context->hdc_is_private && context->hdc_has_format)
+                    && context->pixel_format != GetPixelFormat(context->hdc))
             context->needs_set = 1;
     }
 }
@@ -1331,6 +1340,7 @@ struct wined3d_context *context_create(struct wined3d_swapchain *swapchain,
     int swap_interval;
     DWORD state;
     HDC hdc;
+    BOOL hdc_is_private = FALSE;
 
     TRACE("swapchain %p, target %p, window %p.\n", swapchain, target, swapchain->win_handle);
 
@@ -1372,6 +1382,14 @@ struct wined3d_context *context_create(struct wined3d_swapchain *swapchain,
         goto out;
     }
 
+    ret->current_fb.render_targets = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
+            sizeof(*ret->current_fb.render_targets) * gl_info->limits.buffers);
+    ret->current_fb.rt_size = gl_info->limits.buffers;
+    if (!ret->current_fb.render_targets)
+        goto out;
+    if (device->context_count)
+        ret->offscreenBuffer = device->contexts[0]->offscreenBuffer;
+
     /* Initialize the texture unit mapping to a 1:1 mapping */
     for (s = 0; s < MAX_COMBINED_SAMPLERS; ++s)
     {
@@ -1391,7 +1409,9 @@ struct wined3d_context *context_create(struct wined3d_swapchain *swapchain,
     {
         WARN("Failed to retireve device context, trying swapchain backup.\n");
 
-        if (!(hdc = swapchain_get_backup_dc(swapchain)))
+        if ((hdc = swapchain_get_backup_dc(swapchain)))
+            hdc_is_private = TRUE;
+        else
         {
             ERR("Failed to retrieve a device context.\n");
             goto out;
@@ -1442,7 +1462,7 @@ struct wined3d_context *context_create(struct wined3d_swapchain *swapchain,
 
     ret->gl_info = gl_info;
 
-    if (!context_set_pixel_format(ret, hdc, pixel_format))
+    if (!context_set_pixel_format(ret, hdc, hdc_is_private, pixel_format))
     {
         ERR("Failed to set pixel format %d on device context %p.\n", pixel_format, hdc);
         context_release(ret);
@@ -1519,6 +1539,8 @@ struct wined3d_context *context_create(struct wined3d_swapchain *swapchain,
     ret->glCtx = ctx;
     ret->win_handle = swapchain->win_handle;
     ret->hdc = hdc;
+    ret->hdc_is_private = hdc_is_private;
+    ret->hdc_has_format = TRUE;
     ret->pixel_format = pixel_format;
     ret->needs_set = 1;
 
@@ -1684,6 +1706,7 @@ struct wined3d_context *context_create(struct wined3d_swapchain *swapchain,
 
 out:
     device->shader_backend->shader_free_context_data(ret);
+    HeapFree(GetProcessHeap(), 0, ret->current_fb.render_targets);
     HeapFree(GetProcessHeap(), 0, ret->free_event_queries);
     HeapFree(GetProcessHeap(), 0, ret->free_occlusion_queries);
     HeapFree(GetProcessHeap(), 0, ret->draw_buffers);
@@ -1716,6 +1739,7 @@ void context_destroy(struct wined3d_device *device, struct wined3d_context *cont
     }
 
     device->shader_backend->shader_free_context_data(context);
+    HeapFree(GetProcessHeap(), 0, context->current_fb.render_targets);
     HeapFree(GetProcessHeap(), 0, context->draw_buffers);
     HeapFree(GetProcessHeap(), 0, context->blit_targets);
     device_context_remove(device, context);
@@ -2118,7 +2142,7 @@ static BOOL match_depth_stencil_format(const struct wined3d_format *existing,
     return TRUE;
 }
 
-/* The caller provides a context */
+/* Context activation is done by the caller. */
 static void context_validate_onscreen_formats(struct wined3d_context *context,
         const struct wined3d_surface *depth_stencil)
 {
@@ -2134,20 +2158,20 @@ static void context_validate_onscreen_formats(struct wined3d_context *context,
     WARN("Depth stencil format is not supported by WGL, rendering the backbuffer in an FBO\n");
 
     /* The currently active context is the necessary context to access the swapchain's onscreen buffers */
-    surface_load_location(context->current_rt, WINED3D_LOCATION_TEXTURE_RGB);
+    wined3d_resource_load_location(&context->current_rt->resource, context, WINED3D_LOCATION_TEXTURE_RGB);
     swapchain->render_to_fbo = TRUE;
     swapchain_update_draw_bindings(swapchain);
     context_set_render_offscreen(context, TRUE);
 }
 
-static DWORD context_generate_rt_mask_no_fbo(const struct wined3d_device *device, const struct wined3d_surface *rt)
+static DWORD context_generate_rt_mask_no_fbo(const struct wined3d_context *context, const struct wined3d_surface *rt)
 {
     if (!rt || rt->resource.format->id == WINED3DFMT_NULL)
         return 0;
     else if (rt->swapchain)
         return context_generate_rt_mask_from_surface(rt);
     else
-        return context_generate_rt_mask(device->offscreenBuffer);
+        return context_generate_rt_mask(context->offscreenBuffer);
 }
 
 /* Context activation is done by the caller. */
@@ -2179,7 +2203,7 @@ void context_apply_blit_state(struct wined3d_context *context, const struct wine
     }
     else
     {
-        rt_mask = context_generate_rt_mask_no_fbo(device, rt);
+        rt_mask = context_generate_rt_mask_no_fbo(context, rt);
     }
 
     cur_mask = context->current_fbo ? &context->current_fbo->rt_mask : &context->draw_buffers_mask;
@@ -2225,7 +2249,7 @@ BOOL context_apply_clear_state(struct wined3d_context *context, const struct win
     UINT i;
     struct wined3d_surface **rts = fb->render_targets;
 
-    if (isStateDirty(context, STATE_FRAMEBUFFER) || fb != &device->fb
+    if (isStateDirty(context, STATE_FRAMEBUFFER) || !wined3d_fb_equal(fb, &context->current_fb)
             || rt_count != context->gl_info->limits.buffers)
     {
         if (!context_validate_rt_config(rt_count, rts, fb->depth_stencil))
@@ -2264,8 +2288,10 @@ BOOL context_apply_clear_state(struct wined3d_context *context, const struct win
         }
         else
         {
-            rt_mask = context_generate_rt_mask_no_fbo(device, rt_count ? rts[0] : NULL);
+            rt_mask = context_generate_rt_mask_no_fbo(context, rt_count ? rts[0] : NULL);
         }
+
+        wined3d_fb_copy(&context->current_fb, fb);
     }
     else if (wined3d_settings.offscreen_rendering_mode == ORM_FBO
             && (!rt_count || surface_is_offscreen(rts[0])))
@@ -2277,7 +2303,7 @@ BOOL context_apply_clear_state(struct wined3d_context *context, const struct win
     }
     else
     {
-        rt_mask = context_generate_rt_mask_no_fbo(device, rt_count ? rts[0] : NULL);
+        rt_mask = context_generate_rt_mask_no_fbo(context, rt_count ? rts[0] : NULL);
     }
 
     cur_mask = context->current_fbo ? &context->current_fbo->rt_mask : &context->draw_buffers_mask;
@@ -2311,16 +2337,17 @@ BOOL context_apply_clear_state(struct wined3d_context *context, const struct win
     return TRUE;
 }
 
-static DWORD find_draw_buffers_mask(const struct wined3d_context *context, const struct wined3d_device *device)
+static DWORD find_draw_buffers_mask(const struct wined3d_context *context, const struct wined3d_state *state)
 {
-    const struct wined3d_state *state = &device->state;
-    struct wined3d_surface **rts = state->fb->render_targets;
+    struct wined3d_surface **rts = state->fb.render_targets;
     struct wined3d_shader *ps = state->shader[WINED3D_SHADER_TYPE_PIXEL];
     DWORD rt_mask, rt_mask_bits;
     unsigned int i;
 
-    if (wined3d_settings.offscreen_rendering_mode != ORM_FBO) return context_generate_rt_mask_no_fbo(device, rts[0]);
-    else if (!context->render_offscreen) return context_generate_rt_mask_from_surface(rts[0]);
+    if (wined3d_settings.offscreen_rendering_mode != ORM_FBO)
+        return context_generate_rt_mask_no_fbo(context, rts[0]);
+    else if (!context->render_offscreen)
+        return context_generate_rt_mask_from_surface(rts[0]);
 
     rt_mask = ps ? ps->reg_maps.rt_mask : 1;
     rt_mask &= context->d3d_info->valid_rt_mask;
@@ -2341,9 +2368,8 @@ static DWORD find_draw_buffers_mask(const struct wined3d_context *context, const
 /* Context activation is done by the caller. */
 void context_state_fb(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
 {
-    const struct wined3d_device *device = context->swapchain->device;
-    const struct wined3d_fb_state *fb = state->fb;
-    DWORD rt_mask = find_draw_buffers_mask(context, device);
+    const struct wined3d_fb_state *fb = &state->fb;
+    DWORD rt_mask = find_draw_buffers_mask(context, state);
     DWORD *cur_mask;
 
     if (wined3d_settings.offscreen_rendering_mode == ORM_FBO)
@@ -2365,6 +2391,8 @@ void context_state_fb(struct wined3d_context *context, const struct wined3d_stat
         context_apply_draw_buffers(context, rt_mask);
         *cur_mask = rt_mask;
     }
+
+    wined3d_fb_copy(&context->current_fb, &state->fb);
 }
 
 static void context_map_stage(struct wined3d_context *context, DWORD stage, DWORD unit)
@@ -2602,13 +2630,12 @@ static void context_update_tex_unit_map(struct wined3d_context *context, const s
 /* Context activation is done by the caller. */
 void context_state_drawbuf(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
 {
-    const struct wined3d_device *device = context->swapchain->device;
     DWORD rt_mask, *cur_mask;
 
     if (isStateDirty(context, STATE_FRAMEBUFFER)) return;
 
     cur_mask = context->current_fbo ? &context->current_fbo->rt_mask : &context->draw_buffers_mask;
-    rt_mask = find_draw_buffers_mask(context, device);
+    rt_mask = find_draw_buffers_mask(context, state);
     if (rt_mask != *cur_mask)
     {
         context_apply_draw_buffers(context, rt_mask);
@@ -2684,7 +2711,7 @@ void context_stream_info_from_declaration(struct wined3d_context *context,
          * (or rather offsets bigger than the vbo, because the pointer is unsigned), so use system memory
          * sources. In most sane cases the pointer - offset will still be > 0, otherwise it will wrap
          * around to some big value. Hope that with the indices, the driver wraps it back internally. If
-         * not, drawStridedSlow is needed, including a vertex buffer path. */
+         * not, draw_strided_slow is needed, including a vertex buffer path. */
         if (state->load_base_vertex_index < 0)
         {
             WARN_(d3d_perf)("load_base_vertex_index is < 0 (%d), not using VBOs.\n",
@@ -2799,7 +2826,7 @@ static void context_update_stream_info(struct wined3d_context *context, const st
     {
         if (state->vertex_declaration->half_float_conv_needed && !stream_info->all_vbo)
         {
-            TRACE("Using drawStridedSlow with vertex shaders for FLOAT16 conversion.\n");
+            TRACE("Using draw_strided_slow with vertex shaders for FLOAT16 conversion.\n");
             context->use_immediate_mode_draw = TRUE;
         }
         else
@@ -2871,11 +2898,11 @@ static void context_preload_textures(struct wined3d_context *context, const stru
 }
 
 /* Context activation is done by the caller. */
-BOOL context_apply_draw_state(struct wined3d_context *context, struct wined3d_device *device)
+BOOL context_apply_draw_state(struct wined3d_context *context, const struct wined3d_device *device,
+        const struct wined3d_state *state)
 {
-    const struct wined3d_state *state = &device->state;
     const struct StateEntry *state_table = context->state_table;
-    const struct wined3d_fb_state *fb = state->fb;
+    const struct wined3d_fb_state *fb = &state->fb;
     unsigned int i;
 
     if (!context_validate_rt_config(context->gl_info->limits.buffers,
@@ -2894,6 +2921,15 @@ BOOL context_apply_draw_state(struct wined3d_context *context, struct wined3d_de
     context_preload_textures(context, state);
     if (isStateDirty(context, STATE_VDECL) || isStateDirty(context, STATE_STREAMSRC))
         context_update_stream_info(context, state);
+    else
+    {
+        for (i = 0; i < sizeof(state->streams) / sizeof(*state->streams); i++)
+        {
+            if (state->streams[i].buffer)
+                buffer_internal_preload(state->streams[i].buffer, context, state);
+        }
+    }
+
     if (state->index_buffer)
     {
         if (context->stream_info.all_vbo)
@@ -2980,7 +3016,7 @@ static void context_setup_target(struct wined3d_context *context, struct wined3d
             if (texture->texture_srgb.name)
                 wined3d_texture_load(texture, context, TRUE);
             wined3d_texture_load(texture, context, FALSE);
-            surface_invalidate_location(context->current_rt, WINED3D_LOCATION_DRAWABLE);
+            wined3d_resource_invalidate_location(&context->current_rt->resource, WINED3D_LOCATION_DRAWABLE);
         }
     }
 
diff --git a/dlls/wined3d/cs.c b/dlls/wined3d/cs.c
index 9288b94..bfb1848 100644
--- a/dlls/wined3d/cs.c
+++ b/dlls/wined3d/cs.c
@@ -22,10 +22,11 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(d3d);
 
-#define WINED3D_INITIAL_CS_SIZE 4096
-
 enum wined3d_cs_op
 {
+    WINED3D_CS_OP_NOP,
+    WINED3D_CS_OP_SKIP,
+    WINED3D_CS_OP_FENCE,
     WINED3D_CS_OP_PRESENT,
     WINED3D_CS_OP_CLEAR,
     WINED3D_CS_OP_DRAW,
@@ -49,28 +50,85 @@ enum wined3d_cs_op
     WINED3D_CS_OP_SET_CLIP_PLANE,
     WINED3D_CS_OP_SET_MATERIAL,
     WINED3D_CS_OP_RESET_STATE,
+    WINED3D_CS_OP_SET_VS_CONSTS_F,
+    WINED3D_CS_OP_SET_VS_CONSTS_B,
+    WINED3D_CS_OP_SET_VS_CONSTS_I,
+    WINED3D_CS_OP_SET_PS_CONSTS_F,
+    WINED3D_CS_OP_SET_PS_CONSTS_B,
+    WINED3D_CS_OP_SET_PS_CONSTS_I,
+    WINED3D_CS_OP_GLFINISH,
+    WINED3D_CS_OP_SET_BASE_VERTEX_INDEX,
+    WINED3D_CS_OP_SET_PRIMITIVE_TYPE,
+    WINED3D_CS_OP_SET_LIGHT,
+    WINED3D_CS_OP_SET_LIGHT_ENABLE,
+    WINED3D_CS_OP_BLT,
+    WINED3D_CS_OP_COLOR_FILL,
+    WINED3D_CS_OP_RESOURCE_MAP,
+    WINED3D_CS_OP_RESOURCE_UNMAP,
+    WINED3D_CS_OP_RESOURCE_CHANGED,
+    WINED3D_CS_OP_SWAP_MEM,
+    WINED3D_CS_OP_BUFFER_INVALIDATE_RANGE,
+    WINED3D_CS_OP_QUERY_ISSUE,
+    WINED3D_CS_OP_QUERY_DESTROY,
+    WINED3D_CS_OP_BUFFER_PRELOAD,
+    WINED3D_CS_OP_VDECL_DESTROY,
+    WINED3D_CS_OP_SHADER_CLEANUP,
+    WINED3D_CS_OP_UPDATE_SURFACE,
+    WINED3D_CS_OP_TEXTURE_PRELOAD,
+    WINED3D_CS_OP_SURFACE_PRELOAD,
+    WINED3D_CS_OP_UPDATE_TEXTURE,
+    WINED3D_CS_OP_EVICT_RESOURCE,
+    WINED3D_CS_OP_CREATE_VBO,
+    WINED3D_CS_OP_RESOURCE_CLEANUP,
+    WINED3D_CS_OP_BUFFER_CLEANUP,
+    WINED3D_CS_OP_VOLUME_CLEANUP,
+    WINED3D_CS_OP_SURFACE_CLEANUP,
+    WINED3D_CS_OP_TEXTURE_CLEANUP,
+    WINED3D_CS_OP_CREATE_DUMMY_TEXTURES,
+    WINED3D_CS_OP_CREATE_SWAPCHAIN_CONTEXT,
+    WINED3D_CS_OP_DELETE_GL_CONTEXTS,
+    WINED3D_CS_OP_SET_PALETTE,
+    WINED3D_CS_OP_PALETTE_SET_ENTRIES,
+    WINED3D_CS_OP_GETDC,
+    WINED3D_CS_OP_RELEASEDC,
+    WINED3D_CS_OP_STOP,
+};
+
+struct wined3d_cs_stop
+{
+    enum wined3d_cs_op opcode;
+};
+
+struct wined3d_cs_fence
+{
+    enum wined3d_cs_op opcode;
+    BOOL *signalled;
 };
 
+#define CS_PRESENT_SRC_RECT 1
+#define CS_PRESENT_DST_RECT 2
+#define CS_PRESENT_DIRTY_RGN 4
 struct wined3d_cs_present
 {
     enum wined3d_cs_op opcode;
     HWND dst_window_override;
     struct wined3d_swapchain *swapchain;
-    const RECT *src_rect;
-    const RECT *dst_rect;
-    const RGNDATA *dirty_region;
+    RECT src_rect;
+    RECT dst_rect;
+    RGNDATA dirty_region;
     DWORD flags;
+    DWORD set_data;
 };
 
 struct wined3d_cs_clear
 {
     enum wined3d_cs_op opcode;
     DWORD rect_count;
-    const RECT *rects;
     DWORD flags;
-    const struct wined3d_color *color;
+    struct wined3d_color color;
     float depth;
     DWORD stencil;
+    RECT rects[1];
 };
 
 struct wined3d_cs_draw
@@ -86,13 +144,13 @@ struct wined3d_cs_draw
 struct wined3d_cs_set_viewport
 {
     enum wined3d_cs_op opcode;
-    const struct wined3d_viewport *viewport;
+    struct wined3d_viewport viewport;
 };
 
 struct wined3d_cs_set_scissor_rect
 {
     enum wined3d_cs_op opcode;
-    const RECT *rect;
+    RECT rect;
 };
 
 struct wined3d_cs_set_render_target
@@ -203,20 +261,20 @@ struct wined3d_cs_set_transform
 {
     enum wined3d_cs_op opcode;
     enum wined3d_transform_state state;
-    const struct wined3d_matrix *matrix;
+    struct wined3d_matrix matrix;
 };
 
 struct wined3d_cs_set_clip_plane
 {
     enum wined3d_cs_op opcode;
     UINT plane_idx;
-    const struct wined3d_vec4 *plane;
+    struct wined3d_vec4 plane;
 };
 
 struct wined3d_cs_set_material
 {
     enum wined3d_cs_op opcode;
-    const struct wined3d_material *material;
+    struct wined3d_material material;
 };
 
 struct wined3d_cs_reset_state
@@ -224,626 +282,2369 @@ struct wined3d_cs_reset_state
     enum wined3d_cs_op opcode;
 };
 
-static void wined3d_cs_exec_present(struct wined3d_cs *cs, const void *data)
+struct wined3d_cs_set_consts_f
 {
-    const struct wined3d_cs_present *op = data;
-    struct wined3d_swapchain *swapchain;
+    enum wined3d_cs_op opcode;
+    UINT start_register, vector4f_count;
+    float constants[4];
+};
 
-    swapchain = op->swapchain;
-    wined3d_swapchain_set_window(swapchain, op->dst_window_override);
+struct wined3d_cs_set_consts_b
+{
+    enum wined3d_cs_op opcode;
+    UINT start_register, bool_count;
+    BOOL constants[1];
+};
 
-    swapchain->swapchain_ops->swapchain_present(swapchain,
-            op->src_rect, op->dst_rect, op->dirty_region, op->flags);
-}
+struct wined3d_cs_set_consts_i
+{
+    enum wined3d_cs_op opcode;
+    UINT start_register, vector4i_count;
+    int constants[4];
+};
 
-void wined3d_cs_emit_present(struct wined3d_cs *cs, struct wined3d_swapchain *swapchain,
-        const RECT *src_rect, const RECT *dst_rect, HWND dst_window_override,
-        const RGNDATA *dirty_region, DWORD flags)
+struct wined3d_cs_finish
 {
-    struct wined3d_cs_present *op;
+    enum wined3d_cs_op opcode;
+};
 
-    op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_PRESENT;
-    op->dst_window_override = dst_window_override;
-    op->swapchain = swapchain;
-    op->src_rect = src_rect;
-    op->dst_rect = dst_rect;
-    op->dirty_region = dirty_region;
-    op->flags = flags;
+struct wined3d_cs_set_base_vertex_index
+{
+    enum wined3d_cs_op opcode;
+    UINT base_vertex_index;
+};
 
-    cs->ops->submit(cs);
-}
+struct wined3d_cs_set_primitive_type
+{
+    enum wined3d_cs_op opcode;
+    GLenum gl_primitive_type;
+};
 
-static void wined3d_cs_exec_clear(struct wined3d_cs *cs, const void *data)
+struct wined3d_cs_set_light
 {
-    const struct wined3d_cs_clear *op = data;
-    struct wined3d_device *device;
-    RECT draw_rect;
+    enum wined3d_cs_op opcode;
+    struct wined3d_light_info light;
+};
 
-    device = cs->device;
-    wined3d_get_draw_rect(&device->state, &draw_rect);
-    device_clear_render_targets(device, device->adapter->gl_info.limits.buffers,
-            &device->fb, op->rect_count, op->rects, &draw_rect, op->flags,
-            op->color, op->depth, op->stencil);
-}
+struct wined3d_cs_set_light_enable
+{
+    enum wined3d_cs_op opcode;
+    UINT idx;
+    BOOL enable;
+};
 
-void wined3d_cs_emit_clear(struct wined3d_cs *cs, DWORD rect_count, const RECT *rects,
-        DWORD flags, const struct wined3d_color *color, float depth, DWORD stencil)
+struct wined3d_cs_blt
 {
-    struct wined3d_cs_clear *op;
+    enum wined3d_cs_op opcode;
+    struct wined3d_surface *dst_surface;
+    RECT dst_rect;
+    struct wined3d_surface *src_surface;
+    RECT src_rect;
+    DWORD flags;
+    WINEDDBLTFX fx;
+    enum wined3d_texture_filter_type filter;
+};
 
-    op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_CLEAR;
-    op->rect_count = rect_count;
-    op->rects = rects;
-    op->flags = flags;
-    op->color = color;
-    op->depth = depth;
-    op->stencil = stencil;
+struct wined3d_cs_color_fill
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_surface *surface;
+    RECT rect;
+    struct wined3d_color color;
+};
 
-    cs->ops->submit(cs);
-}
+struct wined3d_cs_resource_map
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_resource *resource;
+    DWORD flags;
+    void **mem;
+};
 
-static void wined3d_cs_exec_draw(struct wined3d_cs *cs, const void *data)
+struct wined3d_cs_resource_unmap
 {
-    const struct wined3d_cs_draw *op = data;
+    enum wined3d_cs_op opcode;
+    struct wined3d_resource *resource;
+};
 
-    draw_primitive(cs->device, op->start_idx, op->index_count,
-            op->start_instance, op->instance_count, op->indexed);
-}
+struct wined3d_cs_resource_changed
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_resource *resource;
+    struct wined3d_gl_bo *swap_buffer;
+    void *swap_heap_memory;
+};
 
-void wined3d_cs_emit_draw(struct wined3d_cs *cs, UINT start_idx, UINT index_count,
-        UINT start_instance, UINT instance_count, BOOL indexed)
+struct wined3d_cs_skip
 {
-    struct wined3d_cs_draw *op;
+    enum wined3d_cs_op opcode;
+    DWORD size;
+};
 
-    op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_DRAW;
-    op->start_idx = start_idx;
-    op->index_count = index_count;
-    op->start_instance = start_instance;
-    op->instance_count = instance_count;
-    op->indexed = indexed;
+struct wined3d_cs_swap_mem
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_buffer *buffer;
+    BYTE *mem;
+};
 
-    cs->ops->submit(cs);
-}
+struct wined3d_cs_buffer_invalidate_bo_range
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_buffer *buffer;
+    UINT offset, size;
+};
 
-static void wined3d_cs_exec_set_viewport(struct wined3d_cs *cs, const void *data)
+struct wined3d_cs_query_issue
 {
-    const struct wined3d_cs_set_viewport *op = data;
+    enum wined3d_cs_op opcode;
+    struct wined3d_query *query;
+    DWORD flags;
+};
 
-    cs->state.viewport = *op->viewport;
-    device_invalidate_state(cs->device, STATE_VIEWPORT);
-}
+struct wined3d_cs_query_destroy
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_query *query;
+};
 
-void wined3d_cs_emit_set_viewport(struct wined3d_cs *cs, const struct wined3d_viewport *viewport)
+struct wined3d_cs_buffer_preload
 {
-    struct wined3d_cs_set_viewport *op;
+    enum wined3d_cs_op opcode;
+    struct wined3d_buffer *buffer;
+};
 
-    op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_SET_VIEWPORT;
-    op->viewport = viewport;
+struct wined3d_cs_vertex_declaration_destroy
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_vertex_declaration *declaration;
+};
 
-    cs->ops->submit(cs);
-}
+struct wined3d_cs_shader_cleanup
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_shader *shader;
+};
 
-static void wined3d_cs_exec_set_scissor_rect(struct wined3d_cs *cs, const void *data)
+struct wined3d_cs_update_surface
 {
-    const struct wined3d_cs_set_scissor_rect *op = data;
+    enum wined3d_cs_op opcode;
+    struct wined3d_surface *src, *dst;
+    RECT src_rect;
+    POINT dst_point;
+    BOOL has_src_rect, has_dst_point;
+};
 
-    cs->state.scissor_rect = *op->rect;
-    device_invalidate_state(cs->device, STATE_SCISSORRECT);
-}
+struct wined3d_cs_texture_preload
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_texture *texture;
+};
 
-void wined3d_cs_emit_set_scissor_rect(struct wined3d_cs *cs, const RECT *rect)
+struct wined3d_cs_surface_preload
 {
-    struct wined3d_cs_set_scissor_rect *op;
+    enum wined3d_cs_op opcode;
+    struct wined3d_surface *surface;
+};
 
-    op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_SET_SCISSOR_RECT;
-    op->rect = rect;
+struct wined3d_cs_update_texture
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_texture *src, *dst;
+};
 
-    cs->ops->submit(cs);
-}
+struct wined3d_cs_evict_resource
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_resource *resource;
+};
 
-static void wined3d_cs_exec_set_render_target(struct wined3d_cs *cs, const void *data)
+struct wined3d_cs_create_vbo
 {
-    const struct wined3d_cs_set_render_target *op = data;
+    enum wined3d_cs_op opcode;
+    struct wined3d_buffer *buffer;
+};
 
-    cs->state.fb->render_targets[op->render_target_idx] = op->render_target;
-    device_invalidate_state(cs->device, STATE_FRAMEBUFFER);
-}
+struct wined3d_cs_resource_cleanup
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_resource *resource;
+};
 
-void wined3d_cs_emit_set_render_target(struct wined3d_cs *cs, UINT render_target_idx,
-        struct wined3d_surface *render_target)
+struct wined3d_cs_buffer_cleanup
 {
-    struct wined3d_cs_set_render_target *op;
+    enum wined3d_cs_op opcode;
+    struct wined3d_buffer *buffer;
+};
 
-    op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_SET_RENDER_TARGET;
-    op->render_target_idx = render_target_idx;
-    op->render_target = render_target;
+struct wined3d_cs_volume_cleanup
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_volume *volume;
+};
 
-    cs->ops->submit(cs);
-}
+struct wined3d_cs_surface_cleanup
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_surface *surface;
+};
 
-static void wined3d_cs_exec_set_depth_stencil(struct wined3d_cs *cs, const void *data)
+struct wined3d_cs_texture_cleanup
 {
-    const struct wined3d_cs_set_depth_stencil *op = data;
-    struct wined3d_device *device = cs->device;
-    struct wined3d_surface *prev;
+    enum wined3d_cs_op opcode;
+    struct wined3d_texture *texture;
+};
 
-    if ((prev = cs->state.fb->depth_stencil))
-    {
-        if (device->swapchains[0]->desc.flags & WINED3DPRESENTFLAG_DISCARD_DEPTHSTENCIL
-                || prev->flags & SFLAG_DISCARD)
-        {
-            surface_modify_ds_location(prev, WINED3D_LOCATION_DISCARDED,
-                    prev->resource.width, prev->resource.height);
-            if (prev == device->onscreen_depth_stencil)
-            {
-                wined3d_surface_decref(device->onscreen_depth_stencil);
-                device->onscreen_depth_stencil = NULL;
-            }
-        }
-    }
+struct wined3d_cs_create_dummy_textures
+{
+    enum wined3d_cs_op opcode;
+};
 
-    cs->fb.depth_stencil = op->depth_stencil;
+struct wined3d_cs_create_swapchain_context
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_swapchain *swapchain;
+    HRESULT *ret;
+};
 
-    if (!prev != !op->depth_stencil)
-    {
-        /* Swapping NULL / non NULL depth stencil affects the depth and tests */
-        device_invalidate_state(device, STATE_RENDER(WINED3D_RS_ZENABLE));
-        device_invalidate_state(device, STATE_RENDER(WINED3D_RS_STENCILENABLE));
-        device_invalidate_state(device, STATE_RENDER(WINED3D_RS_STENCILWRITEMASK));
-        device_invalidate_state(device, STATE_RENDER(WINED3D_RS_DEPTHBIAS));
-    }
-    else if (prev && prev->resource.format->depth_size != op->depth_stencil->resource.format->depth_size)
-    {
-        device_invalidate_state(device, STATE_RENDER(WINED3D_RS_DEPTHBIAS));
-    }
+struct wined3d_cs_delete_gl_contexts
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_swapchain *swapchain;
+};
 
-    device_invalidate_state(device, STATE_FRAMEBUFFER);
-}
+struct wined3d_cs_set_palette
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_surface *surface;
+    struct wined3d_palette *palette;
+};
 
-void wined3d_cs_emit_set_depth_stencil(struct wined3d_cs *cs, struct wined3d_surface *depth_stencil)
+struct wined3d_cs_palette_set_entries
 {
-    struct wined3d_cs_set_depth_stencil *op;
+    enum wined3d_cs_op opcode;
+    struct wined3d_palette *palette;
+    DWORD flags, start, count;
+    BYTE data[4];
+};
 
-    op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_SET_DEPTH_STENCIL;
-    op->depth_stencil = depth_stencil;
+struct wined3d_cs_getdc
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_surface *surface;
+};
+
+struct wined3d_cs_releasedc
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_surface *surface;
+};
+
+static void wined3d_cs_mt_submit(struct wined3d_cs *cs, size_t size)
+{
+    LONG new_val = (cs->queue.head + size) & (WINED3D_CS_QUEUE_SIZE - 1);
+    /* There is only one thread writing to queue.head, InterlockedExchange
+     * is used for the memory barrier. */
+    InterlockedExchange(&cs->queue.head, new_val);
 
-    cs->ops->submit(cs);
+    if (InterlockedCompareExchange(&cs->waiting_for_event, FALSE, TRUE))
+        SetEvent(cs->event);
 }
 
-static void wined3d_cs_exec_set_vertex_declaration(struct wined3d_cs *cs, const void *data)
+static void wined3d_cs_mt_submit_prio(struct wined3d_cs *cs, size_t size)
 {
-    const struct wined3d_cs_set_vertex_declaration *op = data;
+    LONG new_val = (cs->prio_queue.head + size) & (WINED3D_CS_QUEUE_SIZE - 1);
+    /* There is only one thread writing to queue.head, InterlockedExchange
+     * is used for the memory barrier. */
+    InterlockedExchange(&cs->prio_queue.head, new_val);
 
-    cs->state.vertex_declaration = op->declaration;
-    device_invalidate_state(cs->device, STATE_VDECL);
+    if (InterlockedCompareExchange(&cs->waiting_for_event, FALSE, TRUE))
+        SetEvent(cs->event);
 }
 
-void wined3d_cs_emit_set_vertex_declaration(struct wined3d_cs *cs, struct wined3d_vertex_declaration *declaration)
+static UINT wined3d_cs_exec_nop(struct wined3d_cs *cs, const void *data)
 {
-    struct wined3d_cs_set_vertex_declaration *op;
+    return sizeof(enum wined3d_cs_op);
+}
 
-    op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_SET_VERTEX_DECLARATION;
-    op->declaration = declaration;
+static UINT wined3d_cs_exec_skip(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_skip *op = data;
 
-    cs->ops->submit(cs);
+    return op->size;
 }
 
-static void wined3d_cs_exec_set_stream_source(struct wined3d_cs *cs, const void *data)
+static UINT wined3d_cs_exec_fence(struct wined3d_cs *cs, const void *data)
 {
-    const struct wined3d_cs_set_stream_source *op = data;
-    struct wined3d_stream_state *stream;
-    struct wined3d_buffer *prev;
+    const struct wined3d_cs_fence *op = data;
 
-    stream = &cs->state.streams[op->stream_idx];
-    prev = stream->buffer;
-    stream->buffer = op->buffer;
-    stream->offset = op->offset;
-    stream->stride = op->stride;
+    InterlockedExchange(op->signalled, TRUE);
 
-    if (op->buffer)
-        InterlockedIncrement(&op->buffer->resource.bind_count);
-    if (prev)
-        InterlockedDecrement(&prev->resource.bind_count);
+    return sizeof(*op);
+}
+
+static void wined3d_cs_emit_fence(struct wined3d_cs *cs, BOOL *signalled)
+{
+    struct wined3d_cs_fence *op;
+
+    *signalled = FALSE;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_FENCE;
+    op->signalled = signalled;
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static void wined3d_cs_emit_fence_prio(struct wined3d_cs *cs, BOOL *signalled)
+{
+    struct wined3d_cs_fence *op;
+
+    *signalled = FALSE;
+
+    op = cs->ops->require_space_prio(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_FENCE;
+    op->signalled = signalled;
+    cs->ops->submit_prio(cs, sizeof(*op));
+}
+
+static void wined3d_cs_surface_dec_fence(struct wined3d_surface *surface)
+{
+    if (surface->container)
+        wined3d_resource_dec_fence(&surface->container->resource);
+    else
+        wined3d_resource_dec_fence(&surface->resource);
+}
+
+static void wined3d_cs_surface_inc_fence(struct wined3d_surface *surface)
+{
+    if (surface->container)
+        wined3d_resource_inc_fence(&surface->container->resource);
+    else
+        wined3d_resource_inc_fence(&surface->resource);
+}
+
+static UINT wined3d_cs_exec_present(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_present *op = data;
+    struct wined3d_swapchain *swapchain;
+    const RECT *src_rect = op->set_data & CS_PRESENT_SRC_RECT ? &op->src_rect : NULL;
+    const RECT *dst_rect = op->set_data & CS_PRESENT_DST_RECT ? &op->dst_rect : NULL;
+    const RGNDATA *dirty_region = op->set_data & CS_PRESENT_DIRTY_RGN ? &op->dirty_region : NULL;
+    unsigned int i;
+
+    swapchain = op->swapchain;
+    wined3d_swapchain_set_window(swapchain, op->dst_window_override);
+
+    swapchain->swapchain_ops->swapchain_present(swapchain,
+            src_rect, dst_rect, dirty_region, op->flags,
+            cs->state.fb.depth_stencil);
+
+    InterlockedDecrement(&cs->pending_presents);
+
+    wined3d_cs_surface_dec_fence(swapchain->front_buffer);
+    for (i = 0; i < swapchain->desc.backbuffer_count; i++)
+        wined3d_cs_surface_dec_fence(swapchain->back_buffers[i]);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_present(struct wined3d_cs *cs, struct wined3d_swapchain *swapchain,
+        const RECT *src_rect, const RECT *dst_rect, HWND dst_window_override,
+        const RGNDATA *dirty_region, DWORD flags)
+{
+    struct wined3d_cs_present *op;
+    LONG pending;
+    unsigned int i;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_PRESENT;
+    op->dst_window_override = dst_window_override;
+    op->swapchain = swapchain;
+    op->set_data = 0;
+    if (src_rect)
+    {
+        op->src_rect = *src_rect;
+        op->set_data |= CS_PRESENT_SRC_RECT;
+    }
+    if (dst_rect)
+    {
+        op->dst_rect = *dst_rect;
+        op->set_data |= CS_PRESENT_DST_RECT;
+    }
+    if (dirty_region)
+    {
+        op->dirty_region = *dirty_region;
+        op->set_data = CS_PRESENT_DIRTY_RGN;
+    }
+    op->flags = flags;
+
+    wined3d_cs_surface_inc_fence(swapchain->front_buffer);
+    for (i = 0; i < swapchain->desc.backbuffer_count; i++)
+        wined3d_cs_surface_inc_fence(swapchain->back_buffers[i]);
+
+    pending = InterlockedIncrement(&cs->pending_presents);
+
+    cs->ops->submit(cs, sizeof(*op));
+
+    while (pending > 1)
+        pending = InterlockedCompareExchange(&cs->pending_presents, 0, 0);
+}
+
+static UINT wined3d_cs_exec_clear(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_clear *op = data;
+    struct wined3d_device *device;
+    RECT draw_rect;
+    unsigned int extra_rects = op->rect_count ? op->rect_count - 1 : 0, i;
+
+    device = cs->device;
+    wined3d_get_draw_rect(&cs->state, &draw_rect);
+    device_clear_render_targets(device, device->adapter->gl_info.limits.buffers,
+            &cs->state.fb, op->rect_count, op->rect_count ? op->rects : NULL, &draw_rect, op->flags,
+            &op->color, op->depth, op->stencil);
+
+    if (op->flags & WINED3DCLEAR_TARGET)
+    {
+        for (i = 0; i < sizeof(cs->state.fb.render_targets) / sizeof(*cs->state.fb.render_targets); i++)
+        {
+            if (cs->state.fb.render_targets[i])
+                wined3d_cs_surface_dec_fence(cs->state.fb.render_targets[i]);
+        }
+    }
+    if (op->flags & (WINED3DCLEAR_ZBUFFER | WINED3DCLEAR_STENCIL))
+        wined3d_cs_surface_dec_fence(cs->state.fb.depth_stencil);
+
+    return sizeof(*op) + sizeof(*op->rects) * extra_rects;
+}
+
+void wined3d_cs_emit_clear(struct wined3d_cs *cs, DWORD rect_count, const RECT *rects,
+        DWORD flags, const struct wined3d_color *color, float depth, DWORD stencil)
+{
+    struct wined3d_cs_clear *op;
+    unsigned int extra_rects = rect_count ? rect_count - 1 : 0, i;
+    size_t size = sizeof(*op) + sizeof(*op->rects) * extra_rects;
+    const struct wined3d_state *state = &cs->device->state;
+
+    op = cs->ops->require_space(cs, size);
+    op->opcode = WINED3D_CS_OP_CLEAR;
+    op->rect_count = rect_count;
+    if (rect_count)
+        memcpy(op->rects, rects, rect_count * sizeof(*rects));
+    op->flags = flags;
+    op->color = *color;
+    op->depth = depth;
+    op->stencil = stencil;
+
+    if (flags & WINED3DCLEAR_TARGET)
+    {
+        for (i = 0; i < sizeof(state->fb.render_targets) / sizeof(*state->fb.render_targets); i++)
+        {
+            if (state->fb.render_targets[i])
+                wined3d_cs_surface_inc_fence(state->fb.render_targets[i]);
+        }
+    }
+    if (flags & (WINED3DCLEAR_ZBUFFER | WINED3DCLEAR_STENCIL))
+        wined3d_cs_surface_inc_fence(state->fb.depth_stencil);
+
+    cs->ops->submit(cs, size);
+}
+
+static inline BOOL wined3d_cs_colorwrite_enabled(const struct wined3d_state *state, unsigned int i)
+{
+    switch (i)
+    {
+        case 0:
+            return !!state->render_states[WINED3D_RS_COLORWRITEENABLE];
+        case 1:
+            return !!state->render_states[WINED3D_RS_COLORWRITEENABLE1];
+        case 2:
+            return !!state->render_states[WINED3D_RS_COLORWRITEENABLE2];
+        case 3:
+            return !!state->render_states[WINED3D_RS_COLORWRITEENABLE3];
+        default:
+            ERR("Unexpected color target %u.\n", i);
+            return TRUE;
+    }
+}
+
+static inline BOOL wined3d_cs_depth_stencil_enabled(const struct wined3d_state *state)
+{
+    return state->render_states[WINED3D_RS_ZENABLE]
+            || state->render_states[WINED3D_RS_STENCILENABLE];
+}
+
+static UINT wined3d_cs_exec_draw(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_draw *op = data;
+    const struct wined3d_gl_info *gl_info = &cs->device->adapter->gl_info;
+    unsigned int i;
+
+    if (op->indexed && !gl_info->supported[ARB_DRAW_ELEMENTS_BASE_VERTEX])
+    {
+        if (cs->state.load_base_vertex_index != cs->state.base_vertex_index)
+        {
+            cs->state.load_base_vertex_index = cs->state.base_vertex_index;
+            device_invalidate_state(cs->device, STATE_BASEVERTEXINDEX);
+        }
+    }
+    else if (cs->state.load_base_vertex_index)
+    {
+        cs->state.load_base_vertex_index = 0;
+        device_invalidate_state(cs->device, STATE_BASEVERTEXINDEX);
+    }
+
+    draw_primitive(cs->device, &cs->state, op->start_idx, op->index_count,
+            op->start_instance, op->instance_count, op->indexed);
+
+    if (op->indexed)
+        wined3d_resource_dec_fence(&cs->state.index_buffer->resource);
+    for (i = 0; i < sizeof(cs->state.streams) / sizeof(*cs->state.streams); i++)
+    {
+        if (cs->state.streams[i].buffer)
+            wined3d_resource_dec_fence(&cs->state.streams[i].buffer->resource);
+    }
+    for (i = 0; i < sizeof(cs->state.textures) / sizeof(*cs->state.textures); i++)
+    {
+        if (cs->state.textures[i])
+            wined3d_resource_dec_fence(&cs->state.textures[i]->resource);
+    }
+    for (i = 0; i < sizeof(cs->state.fb.render_targets) / sizeof(*cs->state.fb.render_targets); i++)
+    {
+        if (cs->state.fb.render_targets[i] && wined3d_cs_colorwrite_enabled(&cs->state, i))
+            wined3d_cs_surface_dec_fence(cs->state.fb.render_targets[i]);
+    }
+    if (cs->state.fb.depth_stencil && wined3d_cs_depth_stencil_enabled(&cs->state))
+        wined3d_cs_surface_dec_fence(cs->state.fb.depth_stencil);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_draw(struct wined3d_cs *cs, UINT start_idx, UINT index_count,
+        UINT start_instance, UINT instance_count, BOOL indexed)
+{
+    #define WINED3D_BUFFER_DISCARDED    0x40    /* FIXME! This really does not belong here. */
+
+    struct wined3d_cs_draw *op;
+    unsigned int i;
+    const struct wined3d_state *state = &cs->device->state;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_DRAW;
+    op->start_idx = start_idx;
+    op->index_count = index_count;
+    op->start_instance = start_instance;
+    op->instance_count = instance_count;
+    op->indexed = indexed;
+
+    if (indexed)
+    {
+        wined3d_resource_inc_fence(&state->index_buffer->resource);
+        state->index_buffer->flags &= ~WINED3D_BUFFER_DISCARDED;
+    }
+    for (i = 0; i < sizeof(state->streams) / sizeof(*state->streams); i++)
+    {
+        if (state->streams[i].buffer)
+        {
+            wined3d_resource_inc_fence(&state->streams[i].buffer->resource);
+            state->streams[i].buffer->flags &= ~WINED3D_BUFFER_DISCARDED;
+        }
+    }
+    for (i = 0; i < sizeof(state->textures) / sizeof(*state->textures); i++)
+    {
+        if (state->textures[i])
+            wined3d_resource_inc_fence(&state->textures[i]->resource);
+    }
+    for (i = 0; i < sizeof(state->fb.render_targets) / sizeof(*state->fb.render_targets); i++)
+    {
+        if (state->fb.render_targets[i] && wined3d_cs_colorwrite_enabled(state, i))
+            wined3d_cs_surface_inc_fence(state->fb.render_targets[i]);
+    }
+    if (state->fb.depth_stencil && wined3d_cs_depth_stencil_enabled(state))
+        wined3d_cs_surface_inc_fence(state->fb.depth_stencil);
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_viewport(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_viewport *op = data;
+    struct wined3d_device *device = cs->device;
+
+    cs->state.viewport = op->viewport;
+    device_invalidate_state(device, STATE_VIEWPORT);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_viewport(struct wined3d_cs *cs, const struct wined3d_viewport *viewport)
+{
+    struct wined3d_cs_set_viewport *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_VIEWPORT;
+    op->viewport = *viewport;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_scissor_rect(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_scissor_rect *op = data;
+
+    cs->state.scissor_rect = op->rect;
+    device_invalidate_state(cs->device, STATE_SCISSORRECT);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_scissor_rect(struct wined3d_cs *cs, const RECT *rect)
+{
+    struct wined3d_cs_set_scissor_rect *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_SCISSOR_RECT;
+    op->rect = *rect;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_render_target(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_render_target *op = data;
+
+    cs->state.fb.render_targets[op->render_target_idx] = op->render_target;
+    device_invalidate_state(cs->device, STATE_FRAMEBUFFER);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_render_target(struct wined3d_cs *cs, UINT render_target_idx,
+        struct wined3d_surface *render_target)
+{
+    struct wined3d_cs_set_render_target *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_RENDER_TARGET;
+    op->render_target_idx = render_target_idx;
+    op->render_target = render_target;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_depth_stencil(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_depth_stencil *op = data;
+    struct wined3d_device *device = cs->device;
+    struct wined3d_surface *prev;
+
+    if ((prev = cs->state.fb.depth_stencil))
+    {
+        if (device->swapchains[0]->desc.flags & WINED3DPRESENTFLAG_DISCARD_DEPTHSTENCIL
+                || prev->flags & SFLAG_DISCARD)
+        {
+            surface_modify_ds_location(prev, WINED3D_LOCATION_DISCARDED,
+                    prev->resource.width, prev->resource.height);
+            if (prev == cs->onscreen_depth_stencil)
+            {
+                wined3d_surface_decref(cs->onscreen_depth_stencil);
+                cs->onscreen_depth_stencil = NULL;
+            }
+        }
+    }
+
+    cs->state.fb.depth_stencil = op->depth_stencil;
+
+    if (!prev != !op->depth_stencil)
+    {
+        /* Swapping NULL / non NULL depth stencil affects the depth and tests */
+        device_invalidate_state(device, STATE_RENDER(WINED3D_RS_ZENABLE));
+        device_invalidate_state(device, STATE_RENDER(WINED3D_RS_STENCILENABLE));
+        device_invalidate_state(device, STATE_RENDER(WINED3D_RS_STENCILWRITEMASK));
+        device_invalidate_state(device, STATE_RENDER(WINED3D_RS_DEPTHBIAS));
+    }
+    else if (prev && prev->resource.format->depth_size != op->depth_stencil->resource.format->depth_size)
+    {
+        device_invalidate_state(device, STATE_RENDER(WINED3D_RS_DEPTHBIAS));
+    }
+
+    device_invalidate_state(device, STATE_FRAMEBUFFER);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_depth_stencil(struct wined3d_cs *cs, struct wined3d_surface *depth_stencil)
+{
+    struct wined3d_cs_set_depth_stencil *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_DEPTH_STENCIL;
+    op->depth_stencil = depth_stencil;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_vertex_declaration(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_vertex_declaration *op = data;
+
+    cs->state.vertex_declaration = op->declaration;
+    device_invalidate_state(cs->device, STATE_VDECL);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_vertex_declaration(struct wined3d_cs *cs, struct wined3d_vertex_declaration *declaration)
+{
+    struct wined3d_cs_set_vertex_declaration *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_VERTEX_DECLARATION;
+    op->declaration = declaration;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_stream_source(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_stream_source *op = data;
+    struct wined3d_stream_state *stream;
+    struct wined3d_buffer *prev;
+
+    stream = &cs->state.streams[op->stream_idx];
+    prev = stream->buffer;
+    stream->buffer = op->buffer;
+    stream->offset = op->offset;
+    stream->stride = op->stride;
+
+    if (op->buffer)
+        InterlockedIncrement(&op->buffer->resource.bind_count);
+    if (prev)
+        InterlockedDecrement(&prev->resource.bind_count);
+
+    device_invalidate_state(cs->device, STATE_STREAMSRC);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_stream_source(struct wined3d_cs *cs, UINT stream_idx,
+        struct wined3d_buffer *buffer, UINT offset, UINT stride)
+{
+    struct wined3d_cs_set_stream_source *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_STREAM_SOURCE;
+    op->stream_idx = stream_idx;
+    op->buffer = buffer;
+    op->offset = offset;
+    op->stride = stride;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_stream_source_freq(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_stream_source_freq *op = data;
+    struct wined3d_stream_state *stream;
+
+    stream = &cs->state.streams[op->stream_idx];
+    stream->frequency = op->frequency;
+    stream->flags = op->flags;
 
     device_invalidate_state(cs->device, STATE_STREAMSRC);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_stream_source_freq(struct wined3d_cs *cs, UINT stream_idx, UINT frequency, UINT flags)
+{
+    struct wined3d_cs_set_stream_source_freq *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_STREAM_SOURCE_FREQ;
+    op->stream_idx = stream_idx;
+    op->frequency = frequency;
+    op->flags = flags;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_stream_output(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_stream_output *op = data;
+    struct wined3d_stream_output *stream;
+    struct wined3d_buffer *prev;
+
+    stream = &cs->state.stream_output[op->stream_idx];
+    prev = stream->buffer;
+    stream->buffer = op->buffer;
+    stream->offset = op->offset;
+
+    if (op->buffer)
+        InterlockedIncrement(&op->buffer->resource.bind_count);
+    if (prev)
+        InterlockedDecrement(&prev->resource.bind_count);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_stream_output(struct wined3d_cs *cs, UINT stream_idx,
+        struct wined3d_buffer *buffer, UINT offset)
+{
+    struct wined3d_cs_set_stream_output *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_STREAM_OUTPUT;
+    op->stream_idx = stream_idx;
+    op->buffer = buffer;
+    op->offset = offset;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_index_buffer(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_index_buffer *op = data;
+    struct wined3d_buffer *prev;
+
+    prev = cs->state.index_buffer;
+    cs->state.index_buffer = op->buffer;
+    cs->state.index_format = op->format_id;
+
+    if (op->buffer)
+        InterlockedIncrement(&op->buffer->resource.bind_count);
+    if (prev)
+        InterlockedDecrement(&prev->resource.bind_count);
+
+    device_invalidate_state(cs->device, STATE_INDEXBUFFER);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_index_buffer(struct wined3d_cs *cs, struct wined3d_buffer *buffer,
+        enum wined3d_format_id format_id)
+{
+    struct wined3d_cs_set_index_buffer *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_INDEX_BUFFER;
+    op->buffer = buffer;
+    op->format_id = format_id;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_constant_buffer(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_constant_buffer *op = data;
+    struct wined3d_buffer *prev;
+
+    prev = cs->state.cb[op->type][op->cb_idx];
+    cs->state.cb[op->type][op->cb_idx] = op->buffer;
+
+    if (op->buffer)
+        InterlockedIncrement(&op->buffer->resource.bind_count);
+    if (prev)
+        InterlockedDecrement(&prev->resource.bind_count);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_constant_buffer(struct wined3d_cs *cs, enum wined3d_shader_type type,
+        UINT cb_idx, struct wined3d_buffer *buffer)
+{
+    struct wined3d_cs_set_constant_buffer *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_CONSTANT_BUFFER;
+    op->type = type;
+    op->cb_idx = cb_idx;
+    op->buffer = buffer;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_texture(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_d3d_info *d3d_info = &cs->device->adapter->d3d_info;
+    const struct wined3d_cs_set_texture *op = data;
+    struct wined3d_texture *prev;
+
+    prev = cs->state.textures[op->stage];
+    cs->state.textures[op->stage] = op->texture;
+
+    if (op->texture)
+    {
+        if (InterlockedIncrement(&op->texture->resource.bind_count) == 1)
+            op->texture->sampler = op->stage;
+
+        if (!prev || op->texture->target != prev->target)
+            device_invalidate_state(cs->device, STATE_SHADER(WINED3D_SHADER_TYPE_PIXEL));
+
+        if (!prev && op->stage < d3d_info->limits.ffp_blend_stages)
+        {
+            /* The source arguments for color and alpha ops have different
+             * meanings when a NULL texture is bound, so the COLOR_OP and
+             * ALPHA_OP have to be dirtified. */
+            device_invalidate_state(cs->device, STATE_TEXTURESTAGE(op->stage, WINED3D_TSS_COLOR_OP));
+            device_invalidate_state(cs->device, STATE_TEXTURESTAGE(op->stage, WINED3D_TSS_ALPHA_OP));
+        }
+    }
+
+    if (prev)
+    {
+        if (InterlockedDecrement(&prev->resource.bind_count) && prev->sampler == op->stage)
+        {
+            unsigned int i;
+
+            /* Search for other stages the texture is bound to. Shouldn't
+             * happen if applications bind textures to a single stage only. */
+            TRACE("Searching for other stages the texture is bound to.\n");
+            for (i = 0; i < MAX_COMBINED_SAMPLERS; ++i)
+            {
+                if (cs->state.textures[i] == prev)
+                {
+                    TRACE("Texture is also bound to stage %u.\n", i);
+                    prev->sampler = i;
+                    break;
+                }
+            }
+        }
+
+        if (!op->texture && op->stage < d3d_info->limits.ffp_blend_stages)
+        {
+            device_invalidate_state(cs->device, STATE_TEXTURESTAGE(op->stage, WINED3D_TSS_COLOR_OP));
+            device_invalidate_state(cs->device, STATE_TEXTURESTAGE(op->stage, WINED3D_TSS_ALPHA_OP));
+        }
+    }
+
+    device_invalidate_state(cs->device, STATE_SAMPLER(op->stage));
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_texture(struct wined3d_cs *cs, UINT stage, struct wined3d_texture *texture)
+{
+    struct wined3d_cs_set_texture *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_TEXTURE;
+    op->stage = stage;
+    op->texture = texture;
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_sampler(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_sampler *op = data;
+
+    cs->state.sampler[op->type][op->sampler_idx] = op->sampler;
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_sampler(struct wined3d_cs *cs, enum wined3d_shader_type type,
+        UINT sampler_idx, struct wined3d_sampler *sampler)
+{
+    struct wined3d_cs_set_sampler *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_SAMPLER;
+    op->type = type;
+    op->sampler_idx = sampler_idx;
+    op->sampler = sampler;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_shader(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_shader *op = data;
+
+    cs->state.shader[op->type] = op->shader;
+    device_invalidate_state(cs->device, STATE_SHADER(op->type));
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_shader(struct wined3d_cs *cs, enum wined3d_shader_type type, struct wined3d_shader *shader)
+{
+    struct wined3d_cs_set_shader *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_SHADER;
+    op->type = type;
+    op->shader = shader;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_vs_consts_f(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_consts_f *op = data;
+    struct wined3d_device *device = cs->device;
+
+    memcpy(cs->state.vs_consts_f + op->start_register * 4, op->constants,
+            sizeof(*cs->state.vs_consts_f) * 4 * op->vector4f_count);
+
+    device->shader_backend->shader_update_float_vertex_constants(device,
+            op->start_register, op->vector4f_count);
+
+    return sizeof(*op) + sizeof(op->constants) * (op->vector4f_count - 1);
+}
+
+static UINT wined3d_cs_exec_set_ps_consts_f(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_consts_f *op = data;
+    struct wined3d_device *device = cs->device;
+
+    memcpy(cs->state.ps_consts_f + op->start_register * 4, op->constants,
+            sizeof(*cs->state.ps_consts_f) * 4 * op->vector4f_count);
+
+    device->shader_backend->shader_update_float_pixel_constants(device,
+            op->start_register, op->vector4f_count);
+
+    return sizeof(*op) + sizeof(op->constants) * (op->vector4f_count - 1);
+}
+
+void wined3d_cs_emit_set_consts_f(struct wined3d_cs *cs, UINT start_register,
+        const float *constants, UINT vector4f_count, enum wined3d_shader_type type)
+{
+    struct wined3d_cs_set_consts_f *op;
+    UINT extra_space = vector4f_count - 1;
+    size_t size = sizeof(*op) + sizeof(op->constants) * extra_space;
+
+    op = cs->ops->require_space(cs, size);
+    switch (type)
+    {
+        case WINED3D_SHADER_TYPE_PIXEL:
+            op->opcode = WINED3D_CS_OP_SET_PS_CONSTS_F;
+            break;
+
+        case WINED3D_SHADER_TYPE_VERTEX:
+            op->opcode = WINED3D_CS_OP_SET_VS_CONSTS_F;
+            break;
+
+        case WINED3D_SHADER_TYPE_GEOMETRY:
+            FIXME("Invalid for geometry shaders\n");
+            return;
+
+        case WINED3D_SHADER_TYPE_COUNT:
+            break;
+    }
+    op->start_register = start_register;
+    op->vector4f_count = vector4f_count;
+    memcpy(op->constants, constants, sizeof(*constants) * 4 * vector4f_count);
+
+    cs->ops->submit(cs, size);
+}
+
+static UINT wined3d_cs_exec_set_render_state(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_render_state *op = data;
+
+    cs->state.render_states[op->state] = op->value;
+    device_invalidate_state(cs->device, STATE_RENDER(op->state));
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_render_state(struct wined3d_cs *cs, enum wined3d_render_state state, DWORD value)
+{
+    struct wined3d_cs_set_render_state *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_RENDER_STATE;
+    op->state = state;
+    op->value = value;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_vs_consts_b(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_consts_b *op = data;
+    struct wined3d_device *device = cs->device;
+
+    memcpy(&cs->state.vs_consts_b[op->start_register], op->constants,
+            sizeof(*cs->state.vs_consts_b) * op->bool_count);
+
+    device_invalidate_shader_constants(device, WINED3D_SHADER_CONST_VS_B);
+
+    return sizeof(*op) + sizeof(op->constants) * (op->bool_count - 1);
+}
+
+static UINT wined3d_cs_exec_set_ps_consts_b(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_consts_b *op = data;
+    struct wined3d_device *device = cs->device;
+
+    memcpy(&cs->state.ps_consts_b[op->start_register], op->constants,
+            sizeof(*cs->state.ps_consts_b) * op->bool_count);
+
+    device_invalidate_shader_constants(device, WINED3D_SHADER_CONST_PS_B);
+
+    return sizeof(*op) + sizeof(op->constants) * (op->bool_count - 1);
+}
+
+void wined3d_cs_emit_set_consts_b(struct wined3d_cs *cs, UINT start_register,
+        const BOOL *constants, UINT bool_count, enum wined3d_shader_type type)
+{
+    struct wined3d_cs_set_consts_b *op;
+    UINT extra_space = bool_count - 1;
+    size_t size = sizeof(*op) + sizeof(op->constants) * extra_space;
+
+    op = cs->ops->require_space(cs, size);
+    switch (type)
+    {
+        case WINED3D_SHADER_TYPE_PIXEL:
+            op->opcode = WINED3D_CS_OP_SET_PS_CONSTS_B;
+            break;
+
+        case WINED3D_SHADER_TYPE_VERTEX:
+            op->opcode = WINED3D_CS_OP_SET_VS_CONSTS_B;
+            break;
+
+        case WINED3D_SHADER_TYPE_GEOMETRY:
+            FIXME("Invalid for geometry shaders\n");
+            return;
+
+        case WINED3D_SHADER_TYPE_COUNT:
+            break;
+    }
+    op->start_register = start_register;
+    op->bool_count = bool_count;
+    memcpy(op->constants, constants, sizeof(op->constants) * bool_count);
+
+    cs->ops->submit(cs, size);
+}
+
+static UINT wined3d_cs_exec_set_vs_consts_i(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_consts_i *op = data;
+    struct wined3d_device *device = cs->device;
+
+    memcpy(&cs->state.vs_consts_i[op->start_register * 4], op->constants,
+            sizeof(*cs->state.vs_consts_i) * 4 * op->vector4i_count);
+
+    device_invalidate_shader_constants(device, WINED3D_SHADER_CONST_VS_I);
+
+    return sizeof(*op) + sizeof(op->constants) * (op->vector4i_count - 1);
+}
+
+static UINT wined3d_cs_exec_set_ps_consts_i(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_consts_i *op = data;
+    struct wined3d_device *device = cs->device;
+
+    memcpy(&cs->state.ps_consts_i[op->start_register * 4], op->constants,
+            sizeof(*cs->state.ps_consts_i) * 4 * op->vector4i_count);
+
+    device_invalidate_shader_constants(device, WINED3D_SHADER_CONST_PS_I);
+
+    return sizeof(*op) + sizeof(op->constants) * (op->vector4i_count - 1);
+}
+
+void wined3d_cs_emit_set_consts_i(struct wined3d_cs *cs, UINT start_register,
+        const int *constants, UINT vector4i_count, enum wined3d_shader_type type)
+{
+    struct wined3d_cs_set_consts_i *op;
+    UINT extra_space = vector4i_count - 1;
+    size_t size = sizeof(*op) + sizeof(op->constants) * extra_space;
+
+    op = cs->ops->require_space(cs, size);
+    switch (type)
+    {
+        case WINED3D_SHADER_TYPE_PIXEL:
+            op->opcode = WINED3D_CS_OP_SET_PS_CONSTS_I;
+            break;
+
+        case WINED3D_SHADER_TYPE_VERTEX:
+            op->opcode = WINED3D_CS_OP_SET_VS_CONSTS_I;
+            break;
+
+        case WINED3D_SHADER_TYPE_GEOMETRY:
+            ERR("Invalid for geometry shaders\n");
+            return;
+
+        case WINED3D_SHADER_TYPE_COUNT:
+            break;
+    }
+    op->start_register = start_register;
+    op->vector4i_count = vector4i_count;
+    memcpy(op->constants, constants, sizeof(op->constants) * vector4i_count);
+
+    cs->ops->submit(cs, size);
+}
+
+static UINT wined3d_cs_exec_set_texture_state(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_texture_state *op = data;
+
+    cs->state.texture_states[op->stage][op->state] = op->value;
+    device_invalidate_state(cs->device, STATE_TEXTURESTAGE(op->stage, op->state));
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_texture_state(struct wined3d_cs *cs, UINT stage,
+        enum wined3d_texture_stage_state state, DWORD value)
+{
+    struct wined3d_cs_set_texture_state *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_TEXTURE_STATE;
+    op->stage = stage;
+    op->state = state;
+    op->value = value;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_sampler_state(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_sampler_state *op = data;
+
+    cs->state.sampler_states[op->sampler_idx][op->state] = op->value;
+    device_invalidate_state(cs->device, STATE_SAMPLER(op->sampler_idx));
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_sampler_state(struct wined3d_cs *cs, UINT sampler_idx,
+        enum wined3d_sampler_state state, DWORD value)
+{
+    struct wined3d_cs_set_sampler_state *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_SAMPLER_STATE;
+    op->sampler_idx = sampler_idx;
+    op->state = state;
+    op->value = value;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_transform(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_transform *op = data;
+
+    cs->state.transforms[op->state] = op->matrix;
+    if (op->state < WINED3D_TS_WORLD_MATRIX(cs->device->adapter->gl_info.limits.blends))
+        device_invalidate_state(cs->device, STATE_TRANSFORM(op->state));
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_transform(struct wined3d_cs *cs, enum wined3d_transform_state state,
+        const struct wined3d_matrix *matrix)
+{
+    struct wined3d_cs_set_transform *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_TRANSFORM;
+    op->state = state;
+    op->matrix = *matrix;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_clip_plane(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_clip_plane *op = data;
+
+    cs->state.clip_planes[op->plane_idx] = op->plane;
+    device_invalidate_state(cs->device, STATE_CLIPPLANE(op->plane_idx));
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_clip_plane(struct wined3d_cs *cs, UINT plane_idx, const struct wined3d_vec4 *plane)
+{
+    struct wined3d_cs_set_clip_plane *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_CLIP_PLANE;
+    op->plane_idx = plane_idx;
+    op->plane = *plane;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_material(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_material *op = data;
+
+    cs->state.material = op->material;
+    device_invalidate_state(cs->device, STATE_MATERIAL);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_material(struct wined3d_cs *cs, const struct wined3d_material *material)
+{
+    struct wined3d_cs_set_material *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_MATERIAL;
+    op->material = *material;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_reset_state(struct wined3d_cs *cs, const void *data)
+{
+    struct wined3d_adapter *adapter = cs->device->adapter;
+    HRESULT hr;
+
+    state_cleanup(&cs->state);
+    memset(&cs->state, 0, sizeof(cs->state));
+    if (FAILED(hr = state_init(&cs->state, &adapter->gl_info, &adapter->d3d_info,
+            WINED3D_STATE_NO_REF | WINED3D_STATE_INIT_DEFAULT)))
+        ERR("Failed to initialize CS state, hr %#x.\n", hr);
+
+    return sizeof(struct wined3d_cs_reset_state);
+}
+
+void wined3d_cs_emit_reset_state(struct wined3d_cs *cs)
+{
+    struct wined3d_cs_reset_state *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_RESET_STATE;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_glfinish(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_finish *op = data;
+    struct wined3d_device *device = cs->device;
+    struct wined3d_context *context;
+
+    if (!device->d3d_initialized)
+        return sizeof(*op);
+
+    context = context_acquire(device, NULL);
+    context->gl_info->gl_ops.gl.p_glFinish();
+    context_release(context);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_glfinish(struct wined3d_cs *cs)
+{
+    struct wined3d_cs_finish *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_GLFINISH;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_base_vertex_index(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_base_vertex_index *op = data;
+
+    cs->state.base_vertex_index = op->base_vertex_index;
+    device_invalidate_state(cs->device, STATE_BASEVERTEXINDEX);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_base_vertex_index(struct wined3d_cs *cs,
+        UINT base_vertex_index)
+{
+    struct wined3d_cs_set_base_vertex_index *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_BASE_VERTEX_INDEX;
+    op->base_vertex_index = base_vertex_index;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_primitive_type(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_primitive_type *op = data;
+    GLenum prev;
+
+    prev = cs->state.gl_primitive_type;
+
+    if (op->gl_primitive_type == GL_POINTS || prev == GL_POINTS)
+        device_invalidate_state(cs->device, STATE_POINT_SIZE_ENABLE);
+
+    cs->state.gl_primitive_type = op->gl_primitive_type;
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_primitive_type(struct wined3d_cs *cs, GLenum primitive_type)
+{
+    struct wined3d_cs_set_primitive_type *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_PRIMITIVE_TYPE;
+    op->gl_primitive_type = primitive_type;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_light(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_light *op = data;
+
+    UINT light_idx = op->light.OriginalIndex;
+    UINT hash_idx = LIGHTMAP_HASHFUNC(op->light.OriginalIndex);
+    struct wined3d_light_info *object = NULL;
+    struct list *e;
+
+    LIST_FOR_EACH(e, &cs->state.light_map[hash_idx])
+    {
+        object = LIST_ENTRY(e, struct wined3d_light_info, entry);
+        if (object->OriginalIndex == light_idx)
+            break;
+        object = NULL;
+    }
+
+    if (!object)
+    {
+        TRACE("Adding new light\n");
+        object = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*object));
+        if (!object)
+            return E_OUTOFMEMORY;
+
+        list_add_head(&cs->state.light_map[hash_idx], &object->entry);
+        object->glIndex = -1;
+        object->OriginalIndex = light_idx;
+    }
+
+    object->OriginalParms = op->light.OriginalParms;
+    memcpy(object->lightPosn, op->light.lightPosn, sizeof(object->lightPosn));
+    memcpy(object->lightDirn, op->light.lightDirn, sizeof(object->lightDirn));
+    object->exponent = op->light.exponent;
+    object->cutoff = op->light.cutoff;
+
+    /* Update the live definitions if the light is currently assigned a glIndex. */
+    if (object->glIndex != -1)
+    {
+        if (object->OriginalParms.type != op->light.OriginalParms.type)
+            device_invalidate_state(cs->device, STATE_LIGHT_TYPE);
+        device_invalidate_state(cs->device, STATE_ACTIVELIGHT(object->glIndex));
+    }
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_light(struct wined3d_cs *cs, const struct wined3d_light_info *light)
+{
+    struct wined3d_cs_set_light *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_LIGHT;
+    op->light = *light;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_light_enable(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_light_enable *op = data;
+    UINT hash_idx = LIGHTMAP_HASHFUNC(op->idx);
+    struct wined3d_light_info *light_info = NULL;
+    struct list *e;
+    struct wined3d_device *device = cs->device;
+
+    LIST_FOR_EACH(e, &cs->state.light_map[hash_idx])
+    {
+        light_info = LIST_ENTRY(e, struct wined3d_light_info, entry);
+        if (light_info->OriginalIndex == op->idx)
+            break;
+        light_info = NULL;
+    }
+    TRACE("Found light %p.\n", light_info);
+
+    /* Should be handled by the device by emitting a set_light op */
+    if (!light_info)
+    {
+        ERR("Light enabled requested but light not defined in cs state!\n");
+        return sizeof(*op);
+    }
+
+    if (!op->enable)
+    {
+        if (light_info->glIndex != -1)
+        {
+            device_invalidate_state(device, STATE_LIGHT_TYPE);
+            device_invalidate_state(device, STATE_ACTIVELIGHT(light_info->glIndex));
+            cs->state.lights[light_info->glIndex] = NULL;
+            light_info->glIndex = -1;
+        }
+        else
+        {
+            TRACE("Light already disabled, nothing to do\n");
+        }
+        light_info->enabled = FALSE;
+    }
+    else
+    {
+        light_info->enabled = TRUE;
+        if (light_info->glIndex != -1)
+        {
+            TRACE("Nothing to do as light was enabled\n");
+        }
+        else
+        {
+            unsigned int i;
+            const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
+            /* Find a free GL light. */
+            for (i = 0; i < gl_info->limits.lights; ++i)
+            {
+                if (!cs->state.lights[i])
+                {
+                    cs->state.lights[i] = light_info;
+                    light_info->glIndex = i;
+                    break;
+                }
+            }
+            if (light_info->glIndex == -1)
+            {
+                /* Should be caught by the device before emitting
+                 * the light_enable op */
+                ERR("Too many concurrently active lights in cs\n");
+                return sizeof(*op);
+            }
+
+            /* i == light_info->glIndex */
+            device_invalidate_state(device, STATE_LIGHT_TYPE);
+            device_invalidate_state(device, STATE_ACTIVELIGHT(i));
+        }
+    }
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_light_enable(struct wined3d_cs *cs, UINT idx, BOOL enable)
+{
+    struct wined3d_cs_set_light_enable *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_LIGHT_ENABLE;
+    op->idx = idx;
+    op->enable = enable;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_blt(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_blt *op = data;
+
+    surface_blt_ugly(op->dst_surface, &op->dst_rect,
+            op->src_surface, &op->src_rect,
+            op->flags, &op->fx, op->filter);
+
+    wined3d_cs_surface_dec_fence(op->dst_surface);
+    if (op->src_surface && op->src_surface != op->dst_surface)
+        wined3d_cs_surface_dec_fence(op->src_surface);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_blt(struct wined3d_cs *cs, struct wined3d_surface *dst_surface,
+        const RECT *dst_rect, struct wined3d_surface *src_surface,
+        const RECT *src_rect, DWORD flags, const WINEDDBLTFX *fx,
+        enum wined3d_texture_filter_type filter)
+{
+    struct wined3d_cs_blt *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_BLT;
+    op->dst_surface = dst_surface;
+    op->dst_rect = *dst_rect;
+    op->src_surface = src_surface;
+    op->src_rect = *src_rect;
+    op->flags = flags;
+    op->filter = filter;
+    if (fx)
+        op->fx = *fx;
+
+    wined3d_cs_surface_inc_fence(dst_surface);
+    if (src_surface && src_surface != dst_surface)
+        wined3d_cs_surface_inc_fence(src_surface);
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_color_fill(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_color_fill *op = data;
+
+    surface_color_fill(op->surface, &op->rect, &op->color);
+
+    wined3d_cs_surface_dec_fence(op->surface);
+
+    return sizeof(*op);
 }
 
-void wined3d_cs_emit_set_stream_source(struct wined3d_cs *cs, UINT stream_idx,
-        struct wined3d_buffer *buffer, UINT offset, UINT stride)
+void wined3d_cs_emit_color_fill(struct wined3d_cs *cs, struct wined3d_surface *surface,
+        const RECT *rect, const struct wined3d_color *color)
 {
-    struct wined3d_cs_set_stream_source *op;
+    struct wined3d_cs_color_fill *op;
 
     op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_SET_STREAM_SOURCE;
-    op->stream_idx = stream_idx;
+    op->opcode = WINED3D_CS_OP_COLOR_FILL;
+    op->surface = surface;
+    op->rect = *rect;
+    op->color = *color;
+
+    wined3d_cs_surface_inc_fence(surface);
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_resource_map(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_resource_map *op = data;
+
+    *op->mem = wined3d_resource_map_internal(op->resource, op->flags);
+
+    return sizeof(*op);
+}
+
+void *wined3d_cs_emit_resource_map(struct wined3d_cs *cs, struct wined3d_resource *resource,
+        DWORD flags)
+{
+    struct wined3d_cs_resource_map *op;
+    void *ret;
+
+    op = cs->ops->require_space_prio(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_RESOURCE_MAP;
+    op->resource = resource;
+    op->flags = flags;
+    op->mem = &ret;
+
+    cs->ops->submit_prio(cs, sizeof(*op));
+
+    cs->ops->finish_prio(cs);
+
+    return ret;
+}
+
+static UINT wined3d_cs_exec_resource_unmap(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_resource_unmap *op = data;
+    struct wined3d_resource *resource = op->resource;
+
+    wined3d_resource_unmap_internal(resource);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_resource_unmap(struct wined3d_cs *cs, struct wined3d_resource *resource)
+{
+    struct wined3d_cs_resource_unmap *op;
+
+    op = cs->ops->require_space_prio(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_RESOURCE_UNMAP;
+    op->resource = resource;
+
+    cs->ops->submit_prio(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_resource_changed(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_resource_changed *op = data;
+    struct wined3d_resource *resource = op->resource;
+
+    wined3d_resource_changed(resource, op->swap_buffer, op->swap_heap_memory);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_resource_changed(struct wined3d_cs *cs, struct wined3d_resource *resource,
+        struct wined3d_gl_bo *swap_buffer, void *swap_heap_memory)
+{
+    struct wined3d_cs_resource_changed *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_RESOURCE_CHANGED;
+    op->resource = resource;
+    op->swap_buffer = swap_buffer;
+    op->swap_heap_memory = swap_heap_memory;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_swap_mem(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_swap_mem *op = data;
+    struct wined3d_buffer *buffer = op->buffer;
+
+    buffer_swap_mem(buffer, op->mem);
+
+    if (!buffer->buffer_object && buffer->resource.bind_count)
+    {
+        device_invalidate_state(cs->device, STATE_STREAMSRC);
+        device_invalidate_state(cs->device, STATE_INDEXBUFFER);
+    }
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_swap_mem(struct wined3d_cs *cs, struct wined3d_buffer *buffer, BYTE *mem)
+{
+    struct wined3d_cs_swap_mem *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SWAP_MEM;
+    op->buffer = buffer;
+    op->mem = mem;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_buffer_invalidate_bo_range(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_buffer_invalidate_bo_range *op = data;
+
+    buffer_invalidate_bo_range(op->buffer, op->offset, op->size);
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_buffer_invalidate_bo_range(struct wined3d_cs *cs,
+        struct wined3d_buffer *buffer, UINT offset, UINT size)
+{
+    struct wined3d_cs_buffer_invalidate_bo_range *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_BUFFER_INVALIDATE_RANGE;
     op->buffer = buffer;
     op->offset = offset;
-    op->stride = stride;
+    op->size = size;
 
-    cs->ops->submit(cs);
+    cs->ops->submit(cs, sizeof(*op));
 }
 
-static void wined3d_cs_exec_set_stream_source_freq(struct wined3d_cs *cs, const void *data)
+static UINT wined3d_cs_exec_query_issue(struct wined3d_cs *cs, const void *data)
 {
-    const struct wined3d_cs_set_stream_source_freq *op = data;
-    struct wined3d_stream_state *stream;
+    const struct wined3d_cs_query_issue *op = data;
+    struct wined3d_query *query = op->query;
+    BOOL poll;
 
-    stream = &cs->state.streams[op->stream_idx];
-    stream->frequency = op->frequency;
-    stream->flags = op->flags;
+    poll = query->query_ops->query_issue(query, op->flags);
 
-    device_invalidate_state(cs->device, STATE_STREAMSRC);
+    if (wined3d_settings.cs_multithreaded)
+    {
+        if (poll && list_empty(&query->poll_list_entry))
+        {
+            list_add_tail(&cs->query_poll_list, &query->poll_list_entry);
+        }
+        else if (!poll && !list_empty(&query->poll_list_entry))
+        {
+            /* Can happen if occlusion queries are restarted. This discards the old
+             * result, polling it could result in a GL error */
+            list_remove(&query->poll_list_entry);
+            list_init(&query->poll_list_entry);
+        }
+        else if (op->flags & WINED3DISSUE_END)
+        {
+            /* Can happen when an occlusion query is ended without being started,
+             * in which case we don't want to poll, but still have to counter-balance
+             * the increment of the main counter (!poll && list_empty).
+             *
+             * This can also happen if an event query is re-issued before the first
+             * fence was reached (poll && !list_empty). In this case the query is
+             * already in the list and the poll function will check the new fence.
+             * We have to counter-balance the discarded increment. */
+            InterlockedIncrement(&query->counter_retrieved);
+        }
+    }
+
+    return sizeof(*op);
 }
 
-void wined3d_cs_emit_set_stream_source_freq(struct wined3d_cs *cs, UINT stream_idx, UINT frequency, UINT flags)
+void wined3d_cs_emit_query_issue(struct wined3d_cs *cs, struct wined3d_query *query, DWORD flags)
 {
-    struct wined3d_cs_set_stream_source_freq *op;
+    struct wined3d_cs_query_issue *op;
 
     op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_SET_STREAM_SOURCE_FREQ;
-    op->stream_idx = stream_idx;
-    op->frequency = frequency;
+    op->opcode = WINED3D_CS_OP_QUERY_ISSUE;
+    op->query = query;
     op->flags = flags;
 
-    cs->ops->submit(cs);
+    cs->ops->submit(cs, sizeof(*op));
 }
 
-static void wined3d_cs_exec_set_stream_output(struct wined3d_cs *cs, const void *data)
+static UINT wined3d_cs_exec_query_destroy(struct wined3d_cs *cs, const void *data)
 {
-    const struct wined3d_cs_set_stream_output *op = data;
-    struct wined3d_stream_output *stream;
-    struct wined3d_buffer *prev;
+    const struct wined3d_cs_query_destroy *op = data;
 
-    stream = &cs->state.stream_output[op->stream_idx];
-    prev = stream->buffer;
-    stream->buffer = op->buffer;
-    stream->offset = op->offset;
+    if (!list_empty(&op->query->poll_list_entry))
+        list_remove(&op->query->poll_list_entry);
 
-    if (op->buffer)
-        InterlockedIncrement(&op->buffer->resource.bind_count);
-    if (prev)
-        InterlockedDecrement(&prev->resource.bind_count);
+    wined3d_query_destroy(op->query);
+
+    return sizeof(*op);
 }
 
-void wined3d_cs_emit_set_stream_output(struct wined3d_cs *cs, UINT stream_idx,
-        struct wined3d_buffer *buffer, UINT offset)
+void wined3d_cs_emit_query_destroy(struct wined3d_cs *cs, struct wined3d_query *query)
 {
-    struct wined3d_cs_set_stream_output *op;
+    struct wined3d_cs_query_destroy *op;
 
     op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_SET_STREAM_OUTPUT;
-    op->stream_idx = stream_idx;
-    op->buffer = buffer;
-    op->offset = offset;
+    op->opcode = WINED3D_CS_OP_QUERY_DESTROY;
+    op->query = query;
 
-    cs->ops->submit(cs);
+    cs->ops->submit(cs, sizeof(*op));
 }
 
-static void wined3d_cs_exec_set_index_buffer(struct wined3d_cs *cs, const void *data)
+static UINT wined3d_cs_exec_buffer_preload(struct wined3d_cs *cs, const void *data)
 {
-    const struct wined3d_cs_set_index_buffer *op = data;
-    struct wined3d_buffer *prev;
+    const struct wined3d_cs_buffer_preload *op = data;
+    struct wined3d_context *context;
 
-    prev = cs->state.index_buffer;
-    cs->state.index_buffer = op->buffer;
-    cs->state.index_format = op->format_id;
+    context = context_acquire(cs->device, NULL);
+    buffer_internal_preload(op->buffer, context, NULL);
+    context_release(context);
 
-    if (op->buffer)
-        InterlockedIncrement(&op->buffer->resource.bind_count);
-    if (prev)
-        InterlockedDecrement(&prev->resource.bind_count);
+    wined3d_resource_dec_fence(&op->buffer->resource);
 
-    device_invalidate_state(cs->device, STATE_INDEXBUFFER);
+    return sizeof(*op);
 }
 
-void wined3d_cs_emit_set_index_buffer(struct wined3d_cs *cs, struct wined3d_buffer *buffer,
-        enum wined3d_format_id format_id)
+void wined3d_cs_emit_buffer_preload(struct wined3d_cs *cs, struct wined3d_buffer *buffer)
 {
-    struct wined3d_cs_set_index_buffer *op;
+    struct wined3d_cs_buffer_preload *op;
 
     op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_SET_INDEX_BUFFER;
+    op->opcode = WINED3D_CS_OP_BUFFER_PRELOAD;
     op->buffer = buffer;
-    op->format_id = format_id;
 
-    cs->ops->submit(cs);
+    wined3d_resource_inc_fence(&buffer->resource);
+
+    cs->ops->submit(cs, sizeof(*op));
 }
 
-static void wined3d_cs_exec_set_constant_buffer(struct wined3d_cs *cs, const void *data)
+static UINT wined3d_cs_exec_vertex_declaration_destroy(struct wined3d_cs *cs, const void *data)
 {
-    const struct wined3d_cs_set_constant_buffer *op = data;
-    struct wined3d_buffer *prev;
+    const struct wined3d_cs_vertex_declaration_destroy *op = data;
 
-    prev = cs->state.cb[op->type][op->cb_idx];
-    cs->state.cb[op->type][op->cb_idx] = op->buffer;
+    wined3d_vertex_declaration_destroy(op->declaration);
 
-    if (op->buffer)
-        InterlockedIncrement(&op->buffer->resource.bind_count);
-    if (prev)
-        InterlockedDecrement(&prev->resource.bind_count);
+    return sizeof(*op);
 }
 
-void wined3d_cs_emit_set_constant_buffer(struct wined3d_cs *cs, enum wined3d_shader_type type,
-        UINT cb_idx, struct wined3d_buffer *buffer)
+void wined3d_cs_emit_vertex_declaration_destroy(struct wined3d_cs *cs,
+        struct wined3d_vertex_declaration *declaration)
 {
-    struct wined3d_cs_set_constant_buffer *op;
+    struct wined3d_cs_vertex_declaration_destroy *op;
 
     op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_SET_CONSTANT_BUFFER;
-    op->type = type;
-    op->cb_idx = cb_idx;
-    op->buffer = buffer;
+    op->opcode = WINED3D_CS_OP_VDECL_DESTROY;
+    op->declaration = declaration;
 
-    cs->ops->submit(cs);
+    cs->ops->submit(cs, sizeof(*op));
 }
 
-static void wined3d_cs_exec_set_texture(struct wined3d_cs *cs, const void *data)
+static UINT wined3d_cs_exec_shader_cleanup(struct wined3d_cs *cs, const void *data)
 {
-    const struct wined3d_d3d_info *d3d_info = &cs->device->adapter->d3d_info;
-    const struct wined3d_cs_set_texture *op = data;
-    struct wined3d_texture *prev;
+    const struct wined3d_cs_shader_cleanup *op = data;
 
-    prev = cs->state.textures[op->stage];
-    cs->state.textures[op->stage] = op->texture;
+    shader_cleanup(op->shader);
+    HeapFree(GetProcessHeap(), 0, op->shader);
 
-    if (op->texture)
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_shader_cleanup(struct wined3d_cs *cs, struct wined3d_shader *shader)
+{
+    struct wined3d_cs_shader_cleanup *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SHADER_CLEANUP;
+    op->shader = shader;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_update_surface(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_update_surface *op = data;
+
+    surface_upload_from_surface(op->dst, op->has_dst_point ? &op->dst_point : NULL,
+            op->src, op->has_src_rect ? &op->src_rect : NULL);
+
+    if (op->src->container)
+        wined3d_resource_dec_fence(&op->src->container->resource);
+    else
+        wined3d_resource_inc_fence(&op->src->resource);
+
+    if (op->dst->container)
+        wined3d_resource_dec_fence(&op->dst->container->resource);
+    else
+        wined3d_resource_inc_fence(&op->dst->resource);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_update_surface(struct wined3d_cs *cs, struct wined3d_surface *src, const RECT *src_rect,
+        struct wined3d_surface *dst, const POINT *dst_point)
+{
+    struct wined3d_cs_update_surface *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_UPDATE_SURFACE;
+    op->src = src;
+    op->dst = dst;
+    op->has_src_rect = FALSE;
+    op->has_dst_point = FALSE;
+
+    if (src_rect)
     {
-        if (InterlockedIncrement(&op->texture->resource.bind_count) == 1)
-            op->texture->sampler = op->stage;
+        op->has_src_rect = TRUE;
+        op->src_rect = *src_rect;
+    }
 
-        if (!prev || op->texture->target != prev->target)
-            device_invalidate_state(cs->device, STATE_SHADER(WINED3D_SHADER_TYPE_PIXEL));
+    if (dst_point)
+    {
+        op->has_dst_point = TRUE;
+        op->dst_point = *dst_point;
+    }
 
-        if (!prev && op->stage < d3d_info->limits.ffp_blend_stages)
-        {
-            /* The source arguments for color and alpha ops have different
-             * meanings when a NULL texture is bound, so the COLOR_OP and
-             * ALPHA_OP have to be dirtified. */
-            device_invalidate_state(cs->device, STATE_TEXTURESTAGE(op->stage, WINED3D_TSS_COLOR_OP));
-            device_invalidate_state(cs->device, STATE_TEXTURESTAGE(op->stage, WINED3D_TSS_ALPHA_OP));
-        }
+    if (src->container)
+        wined3d_resource_inc_fence(&src->container->resource);
+    else
+        wined3d_resource_inc_fence(&src->resource);
+
+    if (dst->container)
+        wined3d_resource_inc_fence(&dst->container->resource);
+    else
+        wined3d_resource_inc_fence(&dst->resource);
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_texture_preload(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_texture_preload *op = data;
+    struct wined3d_context *context;
+    struct wined3d_texture *texture = op->texture;
+
+    context = context_acquire(cs->device, NULL);
+    wined3d_texture_load(texture, context, texture->flags & WINED3D_TEXTURE_IS_SRGB);
+    context_release(context);
+
+    wined3d_resource_dec_fence(&texture->resource);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_texture_preload(struct wined3d_cs *cs, struct wined3d_texture *texture)
+{
+    struct wined3d_cs_texture_preload *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_TEXTURE_PRELOAD;
+    op->texture = texture;
+
+    wined3d_resource_inc_fence(&texture->resource);
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_surface_preload(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_surface_preload *op = data;
+    struct wined3d_context *context;
+
+    context = context_acquire(cs->device, NULL);
+    wined3d_texture_preload(op->surface->container);
+    context_release(context);
+
+    wined3d_cs_surface_dec_fence(op->surface);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_surface_preload(struct wined3d_cs *cs, struct wined3d_surface *surface)
+{
+    struct wined3d_cs_surface_preload *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SURFACE_PRELOAD;
+    op->surface = surface;
+
+    wined3d_cs_surface_inc_fence(surface);
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_update_texture(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_update_texture *op = data;
+    struct wined3d_context *context;
+
+    context = context_acquire(cs->device, NULL);
+    device_exec_update_texture(context, op->src, op->dst);
+    context_release(context);
+
+    wined3d_resource_dec_fence(&op->src->resource);
+    wined3d_resource_dec_fence(&op->dst->resource);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_update_texture(struct wined3d_cs *cs, struct wined3d_texture *src,
+        struct wined3d_texture *dst)
+{
+    struct wined3d_cs_update_texture *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_UPDATE_TEXTURE;
+    op->src = src;
+    op->dst = dst;
+
+    wined3d_resource_inc_fence(&op->src->resource);
+    wined3d_resource_inc_fence(&op->dst->resource);
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_evict_resource(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_evict_resource *op = data;
+    struct wined3d_resource *resource = op->resource;
+
+    resource->resource_ops->resource_unload(resource);
+
+    /* FIXME: Is this necessary? Bound buffers are preloaded anyway, and in theory
+     * PreLoad should take care of invalidating the state if the VBO changes */
+    if (resource->bind_count && resource->type == WINED3D_RTYPE_BUFFER)
+    {
+        device_invalidate_state(cs->device, STATE_STREAMSRC);
+        device_invalidate_state(cs->device, STATE_INDEXBUFFER);
     }
 
-    if (prev)
-    {
-        if (InterlockedDecrement(&prev->resource.bind_count) && prev->sampler == op->stage)
-        {
-            unsigned int i;
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_evict_resource(struct wined3d_cs *cs, struct wined3d_resource *resource)
+{
+    struct wined3d_cs_evict_resource *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_EVICT_RESOURCE;
+    op->resource = resource;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_create_vbo(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_create_vbo *op = data;
+    struct wined3d_context *context = context_acquire(cs->device, NULL);
+
+    buffer_create_buffer_object(op->buffer, context);
+
+    context_release(context);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_create_vbo(struct wined3d_cs *cs, struct wined3d_buffer *buffer)
+{
+    struct wined3d_cs_create_vbo *op;
+
+    op = cs->ops->require_space_prio(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_CREATE_VBO;
+    op->buffer = buffer;
+
+    cs->ops->submit_prio(cs, sizeof(*op));
+    cs->ops->finish_prio(cs);
+}
+
+static UINT wined3d_cs_exec_resource_cleanup(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_resource_cleanup *op = data;
+
+    wined3d_resource_cleanup_cs(op->resource);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_resource_cleanup(struct wined3d_cs *cs, struct wined3d_resource *resource)
+{
+    struct wined3d_cs_resource_cleanup *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_RESOURCE_CLEANUP;
+    op->resource = resource;
 
-            /* Search for other stages the texture is bound to. Shouldn't
-             * happen if applications bind textures to a single stage only. */
-            TRACE("Searching for other stages the texture is bound to.\n");
-            for (i = 0; i < MAX_COMBINED_SAMPLERS; ++i)
-            {
-                if (cs->state.textures[i] == prev)
-                {
-                    TRACE("Texture is also bound to stage %u.\n", i);
-                    prev->sampler = i;
-                    break;
-                }
-            }
-        }
+    cs->ops->submit(cs, sizeof(*op));
+}
 
-        if (!op->texture && op->stage < d3d_info->limits.ffp_blend_stages)
-        {
-            device_invalidate_state(cs->device, STATE_TEXTURESTAGE(op->stage, WINED3D_TSS_COLOR_OP));
-            device_invalidate_state(cs->device, STATE_TEXTURESTAGE(op->stage, WINED3D_TSS_ALPHA_OP));
-        }
-    }
+static UINT wined3d_cs_exec_buffer_cleanup(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_buffer_cleanup *op = data;
 
-    device_invalidate_state(cs->device, STATE_SAMPLER(op->stage));
+    wined3d_buffer_cleanup_cs(op->buffer);
+
+    return sizeof(*op);
 }
 
-void wined3d_cs_emit_set_texture(struct wined3d_cs *cs, UINT stage, struct wined3d_texture *texture)
+void wined3d_cs_emit_buffer_cleanup(struct wined3d_cs *cs, struct wined3d_buffer *buffer)
 {
-    struct wined3d_cs_set_texture *op;
+    struct wined3d_cs_buffer_cleanup *op;
 
     op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_SET_TEXTURE;
-    op->stage = stage;
-    op->texture = texture;
+    op->opcode = WINED3D_CS_OP_BUFFER_CLEANUP;
+    op->buffer = buffer;
 
-    cs->ops->submit(cs);
+    cs->ops->submit(cs, sizeof(*op));
 }
 
-static void wined3d_cs_exec_set_sampler(struct wined3d_cs *cs, const void *data)
+static UINT wined3d_cs_exec_volume_cleanup(struct wined3d_cs *cs, const void *data)
 {
-    const struct wined3d_cs_set_sampler *op = data;
+    const struct wined3d_cs_volume_cleanup *op = data;
 
-    cs->state.sampler[op->type][op->sampler_idx] = op->sampler;
+    wined3d_volume_cleanup_cs(op->volume);
+
+    return sizeof(*op);
 }
 
-void wined3d_cs_emit_set_sampler(struct wined3d_cs *cs, enum wined3d_shader_type type,
-        UINT sampler_idx, struct wined3d_sampler *sampler)
+void wined3d_cs_emit_volume_cleanup(struct wined3d_cs *cs, struct wined3d_volume *volume)
 {
-    struct wined3d_cs_set_sampler *op;
+    struct wined3d_cs_volume_cleanup *op;
 
     op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_SET_SAMPLER;
-    op->type = type;
-    op->sampler_idx = sampler_idx;
-    op->sampler = sampler;
+    op->opcode = WINED3D_CS_OP_VOLUME_CLEANUP;
+    op->volume = volume;
 
-    cs->ops->submit(cs);
+    cs->ops->submit(cs, sizeof(*op));
 }
 
-static void wined3d_cs_exec_set_shader(struct wined3d_cs *cs, const void *data)
+static UINT wined3d_cs_exec_surface_cleanup(struct wined3d_cs *cs, const void *data)
 {
-    const struct wined3d_cs_set_shader *op = data;
+    const struct wined3d_cs_surface_cleanup *op = data;
 
-    cs->state.shader[op->type] = op->shader;
-    device_invalidate_state(cs->device, STATE_SHADER(op->type));
+    wined3d_surface_cleanup_cs(op->surface);
+
+    return sizeof(*op);
 }
 
-void wined3d_cs_emit_set_shader(struct wined3d_cs *cs, enum wined3d_shader_type type, struct wined3d_shader *shader)
+void wined3d_cs_emit_surface_cleanup(struct wined3d_cs *cs, struct wined3d_surface *surface)
 {
-    struct wined3d_cs_set_shader *op;
+    struct wined3d_cs_surface_cleanup *op;
 
     op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_SET_SHADER;
-    op->type = type;
-    op->shader = shader;
+    op->opcode = WINED3D_CS_OP_SURFACE_CLEANUP;
+    op->surface = surface;
 
-    cs->ops->submit(cs);
+    cs->ops->submit(cs, sizeof(*op));
 }
 
-static void wined3d_cs_exec_set_render_state(struct wined3d_cs *cs, const void *data)
+static UINT wined3d_cs_exec_texture_cleanup(struct wined3d_cs *cs, const void *data)
 {
-    const struct wined3d_cs_set_render_state *op = data;
+    const struct wined3d_cs_texture_cleanup *op = data;
 
-    cs->state.render_states[op->state] = op->value;
-    device_invalidate_state(cs->device, STATE_RENDER(op->state));
+    wined3d_texture_cleanup_cs(op->texture);
+
+    return sizeof(*op);
 }
 
-void wined3d_cs_emit_set_render_state(struct wined3d_cs *cs, enum wined3d_render_state state, DWORD value)
+void wined3d_cs_emit_texture_cleanup(struct wined3d_cs *cs, struct wined3d_texture *texture)
 {
-    struct wined3d_cs_set_render_state *op;
+    struct wined3d_cs_texture_cleanup *op;
 
     op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_SET_RENDER_STATE;
-    op->state = state;
-    op->value = value;
+    op->opcode = WINED3D_CS_OP_TEXTURE_CLEANUP;
+    op->texture = texture;
 
-    cs->ops->submit(cs);
+    cs->ops->submit(cs, sizeof(*op));
 }
 
-static void wined3d_cs_exec_set_texture_state(struct wined3d_cs *cs, const void *data)
+static UINT wined3d_cs_exec_create_dummy_textures(struct wined3d_cs *cs, const void *data)
 {
-    const struct wined3d_cs_set_texture_state *op = data;
+    const struct wined3d_cs_create_dummy_textures *op = data;
+    struct wined3d_context *context = context_acquire(cs->device, NULL);
 
-    cs->state.texture_states[op->stage][op->state] = op->value;
-    device_invalidate_state(cs->device, STATE_TEXTURESTAGE(op->stage, op->state));
+    device_create_dummy_textures(cs->device, context);
+
+    context_release(context);
+    return sizeof(*op);
 }
 
-void wined3d_cs_emit_set_texture_state(struct wined3d_cs *cs, UINT stage,
-        enum wined3d_texture_stage_state state, DWORD value)
+void wined3d_cs_emit_create_dummy_textures(struct wined3d_cs *cs)
 {
-    struct wined3d_cs_set_texture_state *op;
+    struct wined3d_cs_create_dummy_textures *op;
 
     op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_SET_TEXTURE_STATE;
-    op->stage = stage;
-    op->state = state;
-    op->value = value;
+    op->opcode = WINED3D_CS_OP_CREATE_DUMMY_TEXTURES;
 
-    cs->ops->submit(cs);
+    cs->ops->submit(cs, sizeof(*op));
+    cs->ops->finish(cs);
 }
 
-static void wined3d_cs_exec_set_sampler_state(struct wined3d_cs *cs, const void *data)
+static UINT wined3d_cs_exec_create_swapchain_context(struct wined3d_cs *cs, const void *data)
 {
-    const struct wined3d_cs_set_sampler_state *op = data;
+    const struct wined3d_cs_create_swapchain_context *op = data;
 
-    cs->state.sampler_states[op->sampler_idx][op->state] = op->value;
-    device_invalidate_state(cs->device, STATE_SAMPLER(op->sampler_idx));
+    *op->ret = swapchain_create_context_cs(cs->device, op->swapchain);
+
+    return sizeof(*op);
 }
 
-void wined3d_cs_emit_set_sampler_state(struct wined3d_cs *cs, UINT sampler_idx,
-        enum wined3d_sampler_state state, DWORD value)
+HRESULT wined3d_cs_emit_create_swapchain_context(struct wined3d_cs *cs, struct wined3d_swapchain *swapchain)
 {
-    struct wined3d_cs_set_sampler_state *op;
+    HRESULT ret;
+    struct wined3d_cs_create_swapchain_context *op;
 
     op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_SET_SAMPLER_STATE;
-    op->sampler_idx = sampler_idx;
-    op->state = state;
-    op->value = value;
+    op->opcode = WINED3D_CS_OP_CREATE_SWAPCHAIN_CONTEXT;
+    op->swapchain = swapchain;
+    op->ret = &ret;
+
+    cs->ops->submit(cs, sizeof(*op));
+    cs->ops->finish(cs);
 
-    cs->ops->submit(cs);
+    return ret;
 }
 
-static void wined3d_cs_exec_set_transform(struct wined3d_cs *cs, const void *data)
+static UINT wined3d_cs_exec_delete_gl_contexts(struct wined3d_cs *cs, const void *data)
 {
-    const struct wined3d_cs_set_transform *op = data;
+    const struct wined3d_cs_delete_gl_contexts *op = data;
 
-    cs->state.transforms[op->state] = *op->matrix;
-    if (op->state < WINED3D_TS_WORLD_MATRIX(cs->device->adapter->gl_info.limits.blends))
-        device_invalidate_state(cs->device, STATE_TRANSFORM(op->state));
+    device_delete_opengl_contexts_cs(cs->device, op->swapchain);
+
+    return sizeof(*op);
 }
 
-void wined3d_cs_emit_set_transform(struct wined3d_cs *cs, enum wined3d_transform_state state,
-        const struct wined3d_matrix *matrix)
+void wined3d_cs_emit_delete_opengl_contexts(struct wined3d_cs *cs, struct wined3d_swapchain *swapchain)
 {
-    struct wined3d_cs_set_transform *op;
+    struct wined3d_cs_delete_gl_contexts *op;
 
     op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_SET_TRANSFORM;
-    op->state = state;
-    op->matrix = matrix;
+    op->opcode = WINED3D_CS_OP_DELETE_GL_CONTEXTS;
+    op->swapchain = swapchain;
 
-    cs->ops->submit(cs);
+    cs->ops->submit(cs, sizeof(*op));
+    cs->ops->finish(cs);
 }
 
-static void wined3d_cs_exec_set_clip_plane(struct wined3d_cs *cs, const void *data)
+static UINT wined3d_cs_exec_set_palette(struct wined3d_cs *cs, const void *data)
 {
-    const struct wined3d_cs_set_clip_plane *op = data;
+    const struct wined3d_cs_set_palette *op = data;
 
-    cs->state.clip_planes[op->plane_idx] = *op->plane;
-    device_invalidate_state(cs->device, STATE_CLIPPLANE(op->plane_idx));
+    op->surface->palette = op->palette;
+    if (op->palette)
+        op->surface->surface_ops->surface_realize_palette(op->surface);
+
+    return sizeof(*op);
 }
 
-void wined3d_cs_emit_set_clip_plane(struct wined3d_cs *cs, UINT plane_idx, const struct wined3d_vec4 *plane)
+void wined3d_cs_emit_set_palette(struct wined3d_cs *cs, struct wined3d_surface *surface,
+        struct wined3d_palette *palette)
 {
-    struct wined3d_cs_set_clip_plane *op;
+    struct wined3d_cs_set_palette *op;
 
     op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_SET_CLIP_PLANE;
-    op->plane_idx = plane_idx;
-    op->plane = plane;
+    op->opcode = WINED3D_CS_OP_SET_PALETTE;
+    op->surface = surface;
+    op->palette = palette;
+
+    cs->ops->submit(cs, sizeof(*op));
+    /* Make this a synchronous op for now. The main consideration is that a palette
+     * change shows up immediately on the front buffer. We might want to treat this
+     * like a swap and increment and wait for the swap counter. */
+    FIXME("Waiting for cs.\n");
+    cs->ops->finish(cs);
+}
+
+static UINT wined3d_cs_exec_palette_set_entries(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_palette_set_entries *op = data;
+    UINT extra_size;
 
-    cs->ops->submit(cs);
+    extra_size = op->flags & WINED3D_PALETTE_8BIT_ENTRIES ? op->count : op->count * 4;
+    extra_size = extra_size < 4 ? 0 : extra_size - 4;
+
+    wined3d_exec_palette_set_entries(op->palette, op->flags, op->start,
+            op->count, (const PALETTEENTRY *)op->data);
+
+    return sizeof(*op) + extra_size;
 }
 
-static void wined3d_cs_exec_set_material(struct wined3d_cs *cs, const void *data)
+void wined3d_cs_emit_palette_set_entries(struct wined3d_cs *cs, struct wined3d_palette *palette,
+        DWORD flags, DWORD start, DWORD count, const PALETTEENTRY *entries)
 {
-    const struct wined3d_cs_set_material *op = data;
+    struct wined3d_cs_palette_set_entries *op;
+    UINT extra_size, copy_size;
 
-    cs->state.material = *op->material;
-    device_invalidate_state(cs->device, STATE_MATERIAL);
+    copy_size = flags & WINED3D_PALETTE_8BIT_ENTRIES ? count : count * 4;
+    extra_size = copy_size < 4 ? 0 : copy_size - 4;
+
+    op = cs->ops->require_space(cs, sizeof(*op) + extra_size);
+    op->opcode = WINED3D_CS_OP_PALETTE_SET_ENTRIES;
+    op->palette = palette;
+    op->flags = flags;
+    op->start = start;
+    op->count = count;
+    memcpy(op->data, entries, copy_size);
+
+    cs->ops->submit(cs, sizeof(*op) + extra_size);
+    /* Make this a synchronous op for now. The main consideration is that a palette
+     * change shows up immediately on the front buffer. We might want to treat this
+     * like a swap and increment and wait for the swap counter. */
+    FIXME("Waiting for cs.\n");
+    cs->ops->finish(cs);
 }
 
-void wined3d_cs_emit_set_material(struct wined3d_cs *cs, const struct wined3d_material *material)
+static UINT wined3d_cs_exec_getdc(struct wined3d_cs *cs, const void *data)
 {
-    struct wined3d_cs_set_material *op;
+    const struct wined3d_cs_getdc *op = data;
+
+    wined3d_surface_getdc_cs(op->surface);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_getdc(struct wined3d_cs *cs, struct wined3d_surface *surface)
+{
+    struct wined3d_cs_getdc *op;
 
     op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_SET_MATERIAL;
-    op->material = material;
+    op->opcode = WINED3D_CS_OP_GETDC;
+    op->surface = surface;
 
-    cs->ops->submit(cs);
+    cs->ops->submit(cs, sizeof(*op));
+    cs->ops->finish(cs);
 }
 
-static void wined3d_cs_exec_reset_state(struct wined3d_cs *cs, const void *data)
+static UINT wined3d_cs_exec_releasedc(struct wined3d_cs *cs, const void *data)
 {
-    struct wined3d_adapter *adapter = cs->device->adapter;
-    HRESULT hr;
+    const struct wined3d_cs_releasedc *op = data;
 
-    state_cleanup(&cs->state);
-    memset(&cs->state, 0, sizeof(cs->state));
-    if (FAILED(hr = state_init(&cs->state, &cs->fb, &adapter->gl_info, &adapter->d3d_info,
-            WINED3D_STATE_NO_REF | WINED3D_STATE_INIT_DEFAULT)))
-        ERR("Failed to initialize CS state, hr %#x.\n", hr);
+    wined3d_surface_releasedc_cs(op->surface);
+
+    return sizeof(*op);
 }
 
-void wined3d_cs_emit_reset_state(struct wined3d_cs *cs)
+void wined3d_cs_emit_releasedc(struct wined3d_cs *cs, struct wined3d_surface *surface)
 {
-    struct wined3d_cs_reset_state *op;
+    struct wined3d_cs_releasedc *op;
 
     op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_RESET_STATE;
+    op->opcode = WINED3D_CS_OP_RELEASEDC;
+    op->surface = surface;
 
-    cs->ops->submit(cs);
+    cs->ops->submit(cs, sizeof(*op));
+    cs->ops->finish(cs);
 }
 
-static void (* const wined3d_cs_op_handlers[])(struct wined3d_cs *cs, const void *data) =
+static UINT (* const wined3d_cs_op_handlers[])(struct wined3d_cs *cs, const void *data) =
 {
+    /* WINED3D_CS_OP_NOP                    */ wined3d_cs_exec_nop,
+    /* WINED3D_CS_OP_SKIP                   */ wined3d_cs_exec_skip,
+    /* WINED3D_CS_OP_FENCE                  */ wined3d_cs_exec_fence,
     /* WINED3D_CS_OP_PRESENT                */ wined3d_cs_exec_present,
     /* WINED3D_CS_OP_CLEAR                  */ wined3d_cs_exec_clear,
     /* WINED3D_CS_OP_DRAW                   */ wined3d_cs_exec_draw,
@@ -867,78 +2668,391 @@ static void (* const wined3d_cs_op_handlers[])(struct wined3d_cs *cs, const void
     /* WINED3D_CS_OP_SET_CLIP_PLANE         */ wined3d_cs_exec_set_clip_plane,
     /* WINED3D_CS_OP_SET_MATERIAL           */ wined3d_cs_exec_set_material,
     /* WINED3D_CS_OP_RESET_STATE            */ wined3d_cs_exec_reset_state,
+    /* WINED3D_CS_OP_SET_VS_CONSTS_F        */ wined3d_cs_exec_set_vs_consts_f,
+    /* WINED3D_CS_OP_SET_VS_CONSTS_B        */ wined3d_cs_exec_set_vs_consts_b,
+    /* WINED3D_CS_OP_SET_VS_CONSTS_I        */ wined3d_cs_exec_set_vs_consts_i,
+    /* WINED3D_CS_OP_SET_PS_CONSTS_F        */ wined3d_cs_exec_set_ps_consts_f,
+    /* WINED3D_CS_OP_SET_PS_CONSTS_B        */ wined3d_cs_exec_set_ps_consts_b,
+    /* WINED3D_CS_OP_SET_PS_CONSTS_I        */ wined3d_cs_exec_set_ps_consts_i,
+    /* WINED3D_CS_OP_GLFINISH               */ wined3d_cs_exec_glfinish,
+    /* WINED3D_CS_OP_SET_BASE_VERTEX_INDEX  */ wined3d_cs_exec_set_base_vertex_index,
+    /* WINED3D_CS_OP_SET_PRIMITIVE_TYPE     */ wined3d_cs_exec_set_primitive_type,
+    /* WINED3D_CS_OP_SET_LIGHT              */ wined3d_cs_exec_set_light,
+    /* WINED3D_CS_OP_SET_LIGHT_ENABLE       */ wined3d_cs_exec_set_light_enable,
+    /* WINED3D_CS_OP_BLT                    */ wined3d_cs_exec_blt,
+    /* WINED3D_CS_OP_COLOR_FILL             */ wined3d_cs_exec_color_fill,
+    /* WINED3D_CS_OP_RESOURCE_MAP           */ wined3d_cs_exec_resource_map,
+    /* WINED3D_CS_OP_RESOURCE_UNMAP         */ wined3d_cs_exec_resource_unmap,
+    /* WINED3D_CS_OP_RESOURCE_CHANGED       */ wined3d_cs_exec_resource_changed,
+    /* WINED3D_CS_OP_SWAP_MEM               */ wined3d_cs_exec_swap_mem,
+    /* WINED3D_CS_OP_BUFFER_INVALIDATE_RANGE*/ wined3d_cs_exec_buffer_invalidate_bo_range,
+    /* WINED3D_CS_OP_QUERY_ISSUE            */ wined3d_cs_exec_query_issue,
+    /* WINED3D_CS_OP_QUERY_DESTROY          */ wined3d_cs_exec_query_destroy,
+    /* WINED3D_CS_OP_BUFFER_PRELOAD         */ wined3d_cs_exec_buffer_preload,
+    /* WINED3D_CS_OP_VDECL_DESTROY          */ wined3d_cs_exec_vertex_declaration_destroy,
+    /* WINED3D_CS_OP_SHADER_CLEANUP         */ wined3d_cs_exec_shader_cleanup,
+    /* WINED3D_CS_OP_UPDATE_SURFACE         */ wined3d_cs_exec_update_surface,
+    /* WINED3D_CS_OP_TEXTURE_PRELOAD        */ wined3d_cs_exec_texture_preload,
+    /* WINED3D_CS_OP_SURFACE_PRELOAD        */ wined3d_cs_exec_surface_preload,
+    /* WINED3D_CS_OP_UPDATE_TEXTURE         */ wined3d_cs_exec_update_texture,
+    /* WINED3D_CS_OP_EVICT_RESOURCE         */ wined3d_cs_exec_evict_resource,
+    /* WINED3D_CS_OP_CREATE_VBO             */ wined3d_cs_exec_create_vbo,
+    /* WINED3D_CS_OP_RESOURCE_CLEANUP       */ wined3d_cs_exec_resource_cleanup,
+    /* WINED3D_CS_OP_BUFFER_CLEANUP         */ wined3d_cs_exec_buffer_cleanup,
+    /* WINED3D_CS_OP_VOLUME_CLEANUP         */ wined3d_cs_exec_volume_cleanup,
+    /* WINED3D_CS_OP_SURFACE_CLEANUP        */ wined3d_cs_exec_surface_cleanup,
+    /* WINED3D_CS_OP_TEXTURE_CLEANUP        */ wined3d_cs_exec_texture_cleanup,
+    /* WINED3D_CS_OP_CREATE_DUMMY_TEXTURES  */ wined3d_cs_exec_create_dummy_textures,
+    /* WINED3D_CS_OP_CREATE_SWAPCHAIN_CON...*/ wined3d_cs_exec_create_swapchain_context,
+    /* WINED3D_CS_OP_DELETE_GL_CONTEXTS     */ wined3d_cs_exec_delete_gl_contexts,
+    /* WINED3D_CS_OP_SET_PALETTE            */ wined3d_cs_exec_set_palette,
+    /* WINED3D_CS_OP_PALETTE_SET_ENTRIES    */ wined3d_cs_exec_palette_set_entries,
+    /* WINED3D_CS_OP_GETDC                  */ wined3d_cs_exec_getdc,
+    /* WINED3D_CS_OP_RELEASEDC              */ wined3d_cs_exec_releasedc,
 };
 
-static void *wined3d_cs_st_require_space(struct wined3d_cs *cs, size_t size)
+static inline void *_wined3d_cs_mt_require_space(struct wined3d_cs *cs, size_t size, BOOL prio)
+{
+    struct wined3d_cs_queue *queue = prio ? &cs->prio_queue : &cs->queue;
+    size_t queue_size = sizeof(queue->data) / sizeof(*queue->data);
+
+    if (queue_size - size < queue->head)
+    {
+        struct wined3d_cs_skip *skip;
+        size_t nop_size = queue_size - queue->head;
+
+        skip = _wined3d_cs_mt_require_space(cs, nop_size, prio);
+        if (nop_size < sizeof(*skip))
+        {
+            skip->opcode = WINED3D_CS_OP_NOP;
+        }
+        else
+        {
+            skip->opcode = WINED3D_CS_OP_SKIP;
+            skip->size = nop_size;
+        }
+
+        if (prio)
+            cs->ops->submit_prio(cs, nop_size);
+        else
+            cs->ops->submit(cs, nop_size);
+
+        assert(!queue->head);
+    }
+
+    while(1)
+    {
+        LONG head = queue->head;
+        LONG tail = *((volatile LONG *)&queue->tail);
+        LONG new_pos;
+        /* Empty */
+        if (head == tail)
+            break;
+        /* Head ahead of tail, take care of wrap-around */
+        new_pos = (head + size) & (WINED3D_CS_QUEUE_SIZE - 1);
+        if (head > tail && (new_pos || tail))
+            break;
+        /* Tail ahead of head, but still enough space */
+        if (new_pos < tail && new_pos)
+            break;
+
+        TRACE("Waiting for free space. Head %u, tail %u, want %u\n", head, tail,
+                (unsigned int) size);
+    }
+
+    return &queue->data[queue->head];
+}
+
+static inline void *wined3d_cs_mt_require_space(struct wined3d_cs *cs, size_t size)
+{
+    return _wined3d_cs_mt_require_space(cs, size, FALSE);
+}
+
+static inline void *wined3d_cs_mt_require_space_prio(struct wined3d_cs *cs, size_t size)
+{
+    return _wined3d_cs_mt_require_space(cs, size, TRUE);
+}
+
+/* FIXME: wined3d_device_uninit_3d() should either flush and wait, or be an
+ * OP itself. */
+static void wined3d_cs_emit_stop(struct wined3d_cs *cs)
+{
+    struct wined3d_cs_stop *op;
+
+    op = wined3d_cs_mt_require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_STOP;
+
+    wined3d_cs_mt_submit(cs, sizeof(*op));
+}
+
+static void wined3d_cs_mt_finish(struct wined3d_cs *cs)
+{
+    BOOL fence;
+
+    if (cs->thread_id == GetCurrentThreadId())
+    {
+        static BOOL once;
+        if (!once)
+        {
+            FIXME("flush_and_wait called from cs thread\n");
+            once = TRUE;
+        }
+        return;
+    }
+
+    wined3d_cs_emit_fence(cs, &fence);
+
+    /* A busy wait should be fine, we're not supposed to have to wait very
+     * long. */
+    while (!InterlockedCompareExchange(&fence, TRUE, TRUE));
+}
+
+static void wined3d_cs_mt_finish_prio(struct wined3d_cs *cs)
 {
-    if (size > cs->data_size)
+    BOOL fence;
+
+    if (cs->thread_id == GetCurrentThreadId())
     {
-        void *new_data;
+        static BOOL once;
+        if (!once)
+        {
+            FIXME("flush_and_wait called from cs thread\n");
+            once = TRUE;
+        }
+        return;
+    }
+
+    wined3d_cs_emit_fence_prio(cs, &fence);
 
-        size = max( size, cs->data_size * 2 );
-        if (!(new_data = HeapReAlloc(GetProcessHeap(), 0, cs->data, size)))
-            return NULL;
+    /* A busy wait should be fine, we're not supposed to have to wait very
+     * long. */
+    while (!InterlockedCompareExchange(&fence, TRUE, TRUE));
+}
+
+static const struct wined3d_cs_ops wined3d_cs_mt_ops =
+{
+    wined3d_cs_mt_require_space,
+    wined3d_cs_mt_require_space_prio,
+    wined3d_cs_mt_submit,
+    wined3d_cs_mt_submit_prio,
+    wined3d_cs_mt_finish,
+    wined3d_cs_mt_finish_prio,
+};
 
-        cs->data_size = size;
-        cs->data = new_data;
+static void wined3d_cs_st_submit(struct wined3d_cs *cs, size_t size)
+{
+    enum wined3d_cs_op opcode = *(const enum wined3d_cs_op *)&cs->queue.data;
+
+    if (opcode >= WINED3D_CS_OP_STOP)
+    {
+        ERR("Invalid opcode %#x.\n", opcode);
+        return;
     }
 
-    return cs->data;
+    wined3d_cs_op_handlers[opcode](cs, &cs->queue.data);
 }
 
-static void wined3d_cs_st_submit(struct wined3d_cs *cs)
+static void wined3d_cs_st_finish(struct wined3d_cs *cs)
 {
-    enum wined3d_cs_op opcode = *(const enum wined3d_cs_op *)cs->data;
+}
 
-    wined3d_cs_op_handlers[opcode](cs, cs->data);
+static void *wined3d_cs_st_require_space(struct wined3d_cs *cs, size_t size)
+{
+    return cs->queue.data;
 }
 
 static const struct wined3d_cs_ops wined3d_cs_st_ops =
 {
     wined3d_cs_st_require_space,
+    wined3d_cs_st_require_space,
+    wined3d_cs_st_submit,
     wined3d_cs_st_submit,
+    wined3d_cs_st_finish,
+    wined3d_cs_st_finish,
 };
 
+void wined3d_cs_switch_onscreen_ds(struct wined3d_cs *cs,
+        struct wined3d_context *context, struct wined3d_surface *depth_stencil)
+{
+    if (cs->onscreen_depth_stencil)
+    {
+        surface_load_ds_location(cs->onscreen_depth_stencil, context, WINED3D_LOCATION_TEXTURE_RGB);
+
+        surface_modify_ds_location(cs->onscreen_depth_stencil, WINED3D_LOCATION_TEXTURE_RGB,
+                cs->onscreen_depth_stencil->ds_current_size.cx,
+                cs->onscreen_depth_stencil->ds_current_size.cy);
+        wined3d_surface_decref(cs->onscreen_depth_stencil);
+    }
+    cs->onscreen_depth_stencil = depth_stencil;
+    wined3d_surface_incref(cs->onscreen_depth_stencil);
+}
+
+static inline void poll_queries(struct wined3d_cs *cs)
+{
+    struct wined3d_query *query, *cursor;
+
+    LIST_FOR_EACH_ENTRY_SAFE(query, cursor, &cs->query_poll_list, struct wined3d_query, poll_list_entry)
+    {
+        BOOL ret;
+
+        ret = query->query_ops->query_poll(query);
+        if (ret)
+        {
+            list_remove(&query->poll_list_entry);
+            list_init(&query->poll_list_entry);
+            InterlockedIncrement(&query->counter_retrieved);
+        }
+    }
+}
+
+static inline BOOL queue_is_empty(const struct wined3d_cs_queue *queue)
+{
+    return *((volatile LONG *)&queue->head) == queue->tail;
+}
+
+static void wined3d_cs_wait_event(struct wined3d_cs *cs)
+{
+    InterlockedExchange(&cs->waiting_for_event, TRUE);
+
+    /* The main thread might enqueue a finish command and block on it
+     * after the worker thread decided to enter wined3d_cs_wait_event
+     * and before waiting_for_event was set to TRUE. Check again if
+     * the queues are empty */
+    if (!queue_is_empty(&cs->prio_queue) || !queue_is_empty(&cs->queue))
+    {
+        /* The main thread might have signalled the event, or be in the process
+         * of doing so. Wait for the event to reset it. ResetEvent is not good
+         * because the main thread might be beween the waiting_for_event reset
+         * and SignalEvent call. */
+        if (!InterlockedCompareExchange(&cs->waiting_for_event, FALSE, FALSE))
+            WaitForSingleObject(cs->event, INFINITE);
+    }
+    else
+    {
+        WaitForSingleObject(cs->event, INFINITE);
+    }
+}
+
+static DWORD WINAPI wined3d_cs_run(void *thread_param)
+{
+    struct wined3d_cs *cs = thread_param;
+    enum wined3d_cs_op opcode;
+    LONG tail;
+    struct wined3d_cs_queue *queue;
+    char poll = 0;
+    unsigned int spin_count = 0;
+
+    TRACE("Started.\n");
+
+    list_init(&cs->query_poll_list);
+    cs->thread_id = GetCurrentThreadId();
+    for (;;)
+    {
+        if (poll == 10)
+        {
+            poll = 0;
+            poll_queries(cs);
+        }
+        else
+            poll++;
+
+        if (!queue_is_empty(&cs->prio_queue))
+        {
+            queue = &cs->prio_queue;
+        }
+        else if (!queue_is_empty(&cs->queue))
+        {
+            queue = &cs->queue;
+            if (!queue_is_empty(&cs->prio_queue))
+                queue = &cs->prio_queue;
+        }
+        else
+        {
+            spin_count++;
+            if (spin_count >= WINED3D_CS_SPIN_COUNT && list_empty(&cs->query_poll_list))
+                wined3d_cs_wait_event(cs);
+
+            continue;
+        }
+
+        spin_count = 0;
+
+        tail = queue->tail;
+        opcode = *(const enum wined3d_cs_op *)&queue->data[tail];
+
+        if (opcode >= WINED3D_CS_OP_STOP)
+        {
+            if (opcode > WINED3D_CS_OP_STOP)
+                ERR("Invalid opcode %#x.\n", opcode);
+            goto done;
+        }
+
+        tail += wined3d_cs_op_handlers[opcode](cs, &queue->data[tail]);
+        tail &= (WINED3D_CS_QUEUE_SIZE - 1);
+        InterlockedExchange(&queue->tail, tail);
+    }
+
+done:
+    TRACE("Stopped.\n");
+    return 0;
+}
+
 struct wined3d_cs *wined3d_cs_create(struct wined3d_device *device)
 {
     const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
-    struct wined3d_cs *cs;
+    struct wined3d_cs *cs = NULL;
 
     if (!(cs = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*cs))))
         return NULL;
 
-    if (!(cs->fb.render_targets = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
-            sizeof(*cs->fb.render_targets) * gl_info->limits.buffers)))
-    {
-        HeapFree(GetProcessHeap(), 0, cs);
-        return NULL;
-    }
-
-    if (FAILED(state_init(&cs->state, &cs->fb, gl_info, &device->adapter->d3d_info,
+    if (FAILED(state_init(&cs->state, gl_info, &device->adapter->d3d_info,
             WINED3D_STATE_NO_REF | WINED3D_STATE_INIT_DEFAULT)))
     {
-        HeapFree(GetProcessHeap(), 0, cs->fb.render_targets);
-        HeapFree(GetProcessHeap(), 0, cs);
-        return NULL;
+        goto err;
     }
 
     cs->ops = &wined3d_cs_st_ops;
     cs->device = device;
 
-    cs->data_size = WINED3D_INITIAL_CS_SIZE;
-    if (!(cs->data = HeapAlloc(GetProcessHeap(), 0, cs->data_size)))
+    if (wined3d_settings.cs_multithreaded)
     {
-        HeapFree(GetProcessHeap(), 0, cs);
-        return NULL;
+        cs->ops = &wined3d_cs_mt_ops;
+
+        cs->event = CreateEventW(NULL, FALSE, FALSE, NULL);
+
+        if (!(cs->thread = CreateThread(NULL, 0, wined3d_cs_run, cs, 0, NULL)))
+        {
+            ERR("Failed to create wined3d command stream thread.\n");
+            goto err;
+        }
     }
 
     return cs;
+
+err:
+    if (cs)
+        state_cleanup(&cs->state);
+    HeapFree(GetProcessHeap(), 0, cs);
+    return NULL;
 }
 
 void wined3d_cs_destroy(struct wined3d_cs *cs)
 {
+    DWORD ret;
+
     state_cleanup(&cs->state);
-    HeapFree(GetProcessHeap(), 0, cs->fb.render_targets);
-    HeapFree(GetProcessHeap(), 0, cs->data);
+
+    if (wined3d_settings.cs_multithreaded)
+    {
+        wined3d_cs_emit_stop(cs);
+
+        ret = WaitForSingleObject(cs->thread, INFINITE);
+        CloseHandle(cs->thread);
+        if (ret != WAIT_OBJECT_0)
+            ERR("Wait failed (%#x).\n", ret);
+        if (!CloseHandle(cs->event))
+            ERR("Closing event failed.\n");
+    }
+
     HeapFree(GetProcessHeap(), 0, cs);
 }
diff --git a/dlls/wined3d/device.c b/dlls/wined3d/device.c
index 4cd6342..44ea4f8 100644
--- a/dlls/wined3d/device.c
+++ b/dlls/wined3d/device.c
@@ -196,22 +196,6 @@ void device_context_remove(struct wined3d_device *device, struct wined3d_context
     device->contexts = new_array;
 }
 
-void device_switch_onscreen_ds(struct wined3d_device *device,
-        struct wined3d_context *context, struct wined3d_surface *depth_stencil)
-{
-    if (device->onscreen_depth_stencil)
-    {
-        surface_load_ds_location(device->onscreen_depth_stencil, context, WINED3D_LOCATION_TEXTURE_RGB);
-
-        surface_modify_ds_location(device->onscreen_depth_stencil, WINED3D_LOCATION_TEXTURE_RGB,
-                device->onscreen_depth_stencil->ds_current_size.cx,
-                device->onscreen_depth_stencil->ds_current_size.cy);
-        wined3d_surface_decref(device->onscreen_depth_stencil);
-    }
-    device->onscreen_depth_stencil = depth_stencil;
-    wined3d_surface_incref(device->onscreen_depth_stencil);
-}
-
 static BOOL is_full_clear(const struct wined3d_surface *target, const RECT *draw_rect, const RECT *clear_rect)
 {
     /* partial draw rect */
@@ -234,7 +218,7 @@ static void prepare_ds_clear(struct wined3d_surface *ds, struct wined3d_context
 {
     RECT current_rect, r;
 
-    if (ds->locations & WINED3D_LOCATION_DISCARDED)
+    if (ds->resource.locations & WINED3D_LOCATION_DISCARDED)
     {
         /* Depth buffer was discarded, make it entirely current in its new location since
          * there is no other place where we would get data anyway. */
@@ -242,7 +226,7 @@ static void prepare_ds_clear(struct wined3d_surface *ds, struct wined3d_context
         return;
     }
 
-    if (ds->locations & location)
+    if (ds->resource.locations & location)
         SetRect(&current_rect, 0, 0,
                 ds->ds_current_size.cx,
                 ds->ds_current_size.cy);
@@ -296,6 +280,15 @@ void device_clear_render_targets(struct wined3d_device *device, UINT rt_count, c
     unsigned int i;
     RECT ds_rect;
 
+    context = context_acquire(device, target);
+    if (!context->valid)
+    {
+        context_release(context);
+        WARN("Invalid context, skipping clear.\n");
+        return;
+    }
+    gl_info = context->gl_info;
+
     /* When we're clearing parts of the drawable, make sure that the target surface is well up to date in the
      * drawable. After the clear we'll mark the drawable up to date, so we have to make sure that this is true
      * for the cleared parts, and the untouched parts.
@@ -310,19 +303,10 @@ void device_clear_render_targets(struct wined3d_device *device, UINT rt_count, c
         {
             struct wined3d_surface *rt = fb->render_targets[i];
             if (rt)
-                surface_load_location(rt, rt->draw_binding);
+                wined3d_resource_load_location(&rt->resource, context, rt->draw_binding);
         }
     }
 
-    context = context_acquire(device, target);
-    if (!context->valid)
-    {
-        context_release(context);
-        WARN("Invalid context, skipping clear.\n");
-        return;
-    }
-    gl_info = context->gl_info;
-
     if (target)
     {
         render_offscreen = context->render_offscreen;
@@ -339,8 +323,8 @@ void device_clear_render_targets(struct wined3d_device *device, UINT rt_count, c
     {
         DWORD location = render_offscreen ? fb->depth_stencil->draw_binding : WINED3D_LOCATION_DRAWABLE;
 
-        if (!render_offscreen && fb->depth_stencil != device->onscreen_depth_stencil)
-            device_switch_onscreen_ds(device, context, fb->depth_stencil);
+        if (!render_offscreen && fb->depth_stencil != device->cs->onscreen_depth_stencil)
+            wined3d_cs_switch_onscreen_ds(device->cs, context, fb->depth_stencil);
         prepare_ds_clear(fb->depth_stencil, context, location,
                 draw_rect, rect_count, clear_rect, &ds_rect);
     }
@@ -388,8 +372,8 @@ void device_clear_render_targets(struct wined3d_device *device, UINT rt_count, c
 
             if (rt)
             {
-                surface_validate_location(rt, rt->draw_binding);
-                surface_invalidate_location(rt, ~rt->draw_binding);
+                wined3d_resource_validate_location(&rt->resource, rt->draw_binding);
+                wined3d_resource_invalidate_location(&rt->resource, ~rt->draw_binding);
             }
         }
 
@@ -618,7 +602,7 @@ out:
 }
 
 /* Context activation is done by the caller. */
-static void create_dummy_textures(struct wined3d_device *device, struct wined3d_context *context)
+void device_create_dummy_textures(struct wined3d_device *device, struct wined3d_context *context)
 {
     const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
     unsigned int i, j, count;
@@ -845,7 +829,7 @@ static void device_init_swapchain_state(struct wined3d_device *device, struct wi
     BOOL ds_enable = !!swapchain->desc.enable_auto_depth_stencil;
     unsigned int i;
 
-    if (device->fb.render_targets)
+    if (device->state.fb.render_targets)
     {
         for (i = 0; i < device->adapter->gl_info.limits.buffers; ++i)
         {
@@ -863,9 +847,7 @@ HRESULT CDECL wined3d_device_init_3d(struct wined3d_device *device,
         struct wined3d_swapchain_desc *swapchain_desc)
 {
     static const struct wined3d_color black = {0.0f, 0.0f, 0.0f, 0.0f};
-    const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
     struct wined3d_swapchain *swapchain = NULL;
-    struct wined3d_context *context;
     DWORD clear_flags = 0;
     HRESULT hr;
 
@@ -876,9 +858,6 @@ HRESULT CDECL wined3d_device_init_3d(struct wined3d_device *device,
     if (device->wined3d->flags & WINED3D_NO3D)
         return WINED3DERR_INVALIDCALL;
 
-    device->fb.render_targets = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
-            sizeof(*device->fb.render_targets) * gl_info->limits.buffers);
-
     if (FAILED(hr = device->shader_backend->shader_alloc_private(device,
             device->adapter->vertex_pipe, device->adapter->fragment_pipe)))
     {
@@ -911,9 +890,7 @@ HRESULT CDECL wined3d_device_init_3d(struct wined3d_device *device,
     device->swapchains[0] = swapchain;
     device_init_swapchain_state(device, swapchain);
 
-    context = context_acquire(device, swapchain->front_buffer);
-
-    create_dummy_textures(device, context);
+    wined3d_cs_emit_create_dummy_textures(device->cs);
 
     device->contexts[0]->last_was_rhw = 0;
 
@@ -925,7 +902,7 @@ HRESULT CDECL wined3d_device_init_3d(struct wined3d_device *device,
 
         case ORM_BACKBUFFER:
         {
-            if (context_get_current()->aux_buffers > 0)
+            if (device->contexts[0]->aux_buffers > 0)
             {
                 TRACE("Using auxiliary buffer for offscreen rendering\n");
                 device->offscreenBuffer = GL_AUX0;
@@ -937,11 +914,10 @@ HRESULT CDECL wined3d_device_init_3d(struct wined3d_device *device,
             }
         }
     }
+    device->contexts[0]->offscreenBuffer = device->offscreenBuffer;
 
     TRACE("All defaults now set up, leaving 3D init.\n");
 
-    context_release(context);
-
     /* Clear the screen */
     if (swapchain->back_buffers && swapchain->back_buffers[0])
         clear_flags |= WINED3DCLEAR_TARGET;
@@ -957,7 +933,6 @@ HRESULT CDECL wined3d_device_init_3d(struct wined3d_device *device,
     return WINED3D_OK;
 
 err_out:
-    HeapFree(GetProcessHeap(), 0, device->fb.render_targets);
     HeapFree(GetProcessHeap(), 0, device->swapchains);
     device->swapchain_count = 0;
     if (swapchain)
@@ -1006,8 +981,6 @@ err_out:
 HRESULT CDECL wined3d_device_uninit_3d(struct wined3d_device *device)
 {
     struct wined3d_resource *resource, *cursor;
-    const struct wined3d_gl_info *gl_info;
-    struct wined3d_context *context;
     struct wined3d_surface *surface;
     UINT i;
 
@@ -1016,58 +989,25 @@ HRESULT CDECL wined3d_device_uninit_3d(struct wined3d_device *device)
     if (!device->d3d_initialized)
         return WINED3DERR_INVALIDCALL;
 
-    /* I don't think that the interface guarantees that the device is destroyed from the same thread
-     * it was created. Thus make sure a context is active for the glDelete* calls
-     */
-    context = context_acquire(device, NULL);
-    gl_info = context->gl_info;
+    if (wined3d_settings.cs_multithreaded)
+        device->cs->ops->finish(device->cs);
 
     if (device->logo_texture)
         wined3d_texture_decref(device->logo_texture);
-    if (device->cursor_texture)
-        wined3d_texture_decref(device->cursor_texture);
-
-    state_unbind_resources(&device->state);
-
-    /* Unload resources */
-    LIST_FOR_EACH_ENTRY_SAFE(resource, cursor, &device->resources, struct wined3d_resource, resource_list_entry)
-    {
-        TRACE("Unloading resource %p.\n", resource);
-
-        resource->resource_ops->resource_unload(resource);
-    }
-
-    /* Destroy the depth blt resources, they will be invalid after the reset. Also free shader
-     * private data, it might contain opengl pointers
-     */
-    if (device->depth_blt_texture)
-    {
-        gl_info->gl_ops.gl.p_glDeleteTextures(1, &device->depth_blt_texture);
-        device->depth_blt_texture = 0;
-    }
-
-    /* Destroy the shader backend. Note that this has to happen after all shaders are destroyed. */
-    device->blitter->free_private(device);
-    device->shader_backend->shader_free_private(device);
-    destroy_dummy_textures(device, gl_info);
 
-    /* Release the buffers (with sanity checks)*/
-    if (device->onscreen_depth_stencil)
+    /* Release the buffers (with sanity checks).
+     * FIXME: Move this move into a separate patch. I think the idea
+     * behind this is that those surfaces should be freed before unloading
+     * remaining resources below.
+     * FIXME 2: Shouldn't the cs take care of onscreen_depth_stencil? */
+    if (device->cs->onscreen_depth_stencil)
     {
-        surface = device->onscreen_depth_stencil;
-        device->onscreen_depth_stencil = NULL;
+        surface = device->cs->onscreen_depth_stencil;
+        device->cs->onscreen_depth_stencil = NULL;
         wined3d_surface_decref(surface);
     }
 
-    if (device->fb.depth_stencil)
-    {
-        surface = device->fb.depth_stencil;
-
-        TRACE("Releasing depth/stencil buffer %p.\n", surface);
-
-        device->fb.depth_stencil = NULL;
-        wined3d_surface_decref(surface);
-    }
+    state_unbind_resources(&device->state);
 
     if (device->auto_depth_stencil)
     {
@@ -1077,12 +1017,14 @@ HRESULT CDECL wined3d_device_uninit_3d(struct wined3d_device *device)
             FIXME("Something's still holding the auto depth stencil buffer (%p).\n", surface);
     }
 
-    for (i = 0; i < gl_info->limits.buffers; ++i)
+    /* Unload resources */
+    LIST_FOR_EACH_ENTRY_SAFE(resource, cursor, &device->resources, struct wined3d_resource, resource_list_entry)
     {
-        wined3d_device_set_render_target(device, i, NULL, FALSE);
+        TRACE("Unloading resource %p.\n", resource);
+        wined3d_cs_emit_evict_resource(device->cs, resource);
     }
 
-    context_release(context);
+    wined3d_cs_emit_delete_opengl_contexts(device->cs, device->swapchains[0]);
 
     for (i = 0; i < device->swapchain_count; ++i)
     {
@@ -1095,9 +1037,6 @@ HRESULT CDECL wined3d_device_uninit_3d(struct wined3d_device *device)
     device->swapchains = NULL;
     device->swapchain_count = 0;
 
-    HeapFree(GetProcessHeap(), 0, device->fb.render_targets);
-    device->fb.render_targets = NULL;
-
     device->d3d_initialized = FALSE;
 
     return WINED3D_OK;
@@ -1462,14 +1401,6 @@ HRESULT CDECL wined3d_device_set_light(struct wined3d_device *device,
     TRACE("... Range(%f), Falloff(%f), Theta(%f), Phi(%f)\n",
             light->range, light->falloff, light->theta, light->phi);
 
-    /* Update the live definitions if the light is currently assigned a glIndex. */
-    if (object->glIndex != -1 && !device->recording)
-    {
-        if (object->OriginalParms.type != light->type)
-            device_invalidate_state(device, STATE_LIGHT_TYPE);
-        device_invalidate_state(device, STATE_ACTIVELIGHT(object->glIndex));
-    }
-
     /* Save away the information. */
     object->OriginalParms = *light;
 
@@ -1542,6 +1473,9 @@ HRESULT CDECL wined3d_device_set_light(struct wined3d_device *device,
             FIXME("Unrecognized light type %#x.\n", light->type);
     }
 
+    if (!device->recording)
+        wined3d_cs_emit_set_light(device->cs, object);
+
     return WINED3D_OK;
 }
 
@@ -1614,12 +1548,6 @@ HRESULT CDECL wined3d_device_set_light_enable(struct wined3d_device *device, UIN
     {
         if (light_info->glIndex != -1)
         {
-            if (!device->recording)
-            {
-                device_invalidate_state(device, STATE_LIGHT_TYPE);
-                device_invalidate_state(device, STATE_ACTIVELIGHT(light_info->glIndex));
-            }
-
             device->update_state->lights[light_info->glIndex] = NULL;
             light_info->glIndex = -1;
         }
@@ -1661,16 +1589,12 @@ HRESULT CDECL wined3d_device_set_light_enable(struct wined3d_device *device, UIN
                 WARN("Too many concurrently active lights\n");
                 return WINED3D_OK;
             }
-
-            /* i == light_info->glIndex */
-            if (!device->recording)
-            {
-                device_invalidate_state(device, STATE_LIGHT_TYPE);
-                device_invalidate_state(device, STATE_ACTIVELIGHT(i));
-            }
         }
     }
 
+    if (!device->recording)
+        wined3d_cs_emit_set_light_enable(device->cs, light_idx, enable);
+
     return WINED3D_OK;
 }
 
@@ -1844,6 +1768,9 @@ void CDECL wined3d_device_set_base_vertex_index(struct wined3d_device *device, I
     TRACE("device %p, base_index %d.\n", device, base_index);
 
     device->update_state->base_vertex_index = base_index;
+
+    if (!device->recording)
+        wined3d_cs_emit_set_base_vertex_index(device->cs, base_index);
 }
 
 INT CDECL wined3d_device_get_base_vertex_index(const struct wined3d_device *device)
@@ -1888,7 +1815,7 @@ static void resolve_depth_buffer(struct wined3d_state *state)
             || !(texture->resource.format->flags & WINED3DFMT_FLAG_DEPTH))
         return;
     surface = surface_from_resource(texture->sub_resources[0]);
-    depth_stencil = state->fb->depth_stencil;
+    depth_stencil = state->fb.depth_stencil;
     if (!depth_stencil)
         return;
 
@@ -2163,7 +2090,7 @@ struct wined3d_sampler * CDECL wined3d_device_get_vs_sampler(const struct wined3
     return device->state.sampler[WINED3D_SHADER_TYPE_VERTEX][idx];
 }
 
-static void device_invalidate_shader_constants(const struct wined3d_device *device, DWORD mask)
+void device_invalidate_shader_constants(const struct wined3d_device *device, DWORD mask)
 {
     UINT i;
 
@@ -2196,7 +2123,8 @@ HRESULT CDECL wined3d_device_set_vs_consts_b(struct wined3d_device *device,
     }
     else
     {
-        device_invalidate_shader_constants(device, WINED3D_SHADER_CONST_VS_B);
+        wined3d_cs_emit_set_consts_b(device->cs, start_register, constants,
+                bool_count, WINED3D_SHADER_TYPE_VERTEX);
     }
 
     return WINED3D_OK;
@@ -2243,7 +2171,8 @@ HRESULT CDECL wined3d_device_set_vs_consts_i(struct wined3d_device *device,
     }
     else
     {
-        device_invalidate_shader_constants(device, WINED3D_SHADER_CONST_VS_I);
+        wined3d_cs_emit_set_consts_i(device->cs, start_register, constants,
+                vector4i_count, WINED3D_SHADER_TYPE_VERTEX);
     }
 
     return WINED3D_OK;
@@ -2294,8 +2223,8 @@ HRESULT CDECL wined3d_device_set_vs_consts_f(struct wined3d_device *device,
         memset(device->recording->changed.vertexShaderConstantsF + start_register, 1,
                 sizeof(*device->recording->changed.vertexShaderConstantsF) * vector4f_count);
     else
-        device->shader_backend->shader_update_float_vertex_constants(device, start_register, vector4f_count);
-
+        wined3d_cs_emit_set_consts_f(device->cs, start_register, constants, vector4f_count,
+                WINED3D_SHADER_TYPE_VERTEX);
 
     return WINED3D_OK;
 }
@@ -2408,7 +2337,8 @@ HRESULT CDECL wined3d_device_set_ps_consts_b(struct wined3d_device *device,
     }
     else
     {
-        device_invalidate_shader_constants(device, WINED3D_SHADER_CONST_PS_B);
+        wined3d_cs_emit_set_consts_b(device->cs, start_register, constants,
+                bool_count, WINED3D_SHADER_TYPE_PIXEL);
     }
 
     return WINED3D_OK;
@@ -2455,7 +2385,8 @@ HRESULT CDECL wined3d_device_set_ps_consts_i(struct wined3d_device *device,
     }
     else
     {
-        device_invalidate_shader_constants(device, WINED3D_SHADER_CONST_PS_I);
+        wined3d_cs_emit_set_consts_i(device->cs, start_register, constants,
+                vector4i_count, WINED3D_SHADER_TYPE_PIXEL);
     }
 
     return WINED3D_OK;
@@ -2507,7 +2438,8 @@ HRESULT CDECL wined3d_device_set_ps_consts_f(struct wined3d_device *device,
         memset(device->recording->changed.pixelShaderConstantsF + start_register, 1,
                 sizeof(*device->recording->changed.pixelShaderConstantsF) * vector4f_count);
     else
-        device->shader_backend->shader_update_float_pixel_constants(device, start_register, vector4f_count);
+        wined3d_cs_emit_set_consts_f(device->cs, start_register, constants, vector4f_count,
+                WINED3D_SHADER_TYPE_PIXEL);
 
     return WINED3D_OK;
 }
@@ -2645,6 +2577,13 @@ static HRESULT process_vertices_strided(const struct wined3d_device *device, DWO
         return hr;
     }
 
+    if (wined3d_settings.cs_multithreaded)
+    {
+        FIXME("Waiting for cs.\n");
+        wined3d_cs_emit_glfinish(device->cs);
+        device->cs->ops->finish(device->cs);
+    }
+
     wined3d_device_get_transform(device, WINED3D_TS_VIEW, &view_mat);
     wined3d_device_get_transform(device, WINED3D_TS_PROJECTION, &proj_mat);
     wined3d_device_get_transform(device, WINED3D_TS_WORLD_MATRIX(0), &world_mat);
@@ -3144,8 +3083,6 @@ HRESULT CDECL wined3d_device_begin_scene(struct wined3d_device *device)
 
 HRESULT CDECL wined3d_device_end_scene(struct wined3d_device *device)
 {
-    struct wined3d_context *context;
-
     TRACE("device %p.\n", device);
 
     if (!device->inScene)
@@ -3154,13 +3091,6 @@ HRESULT CDECL wined3d_device_end_scene(struct wined3d_device *device)
         return WINED3DERR_INVALIDCALL;
     }
 
-    context = context_acquire(device, NULL);
-    /* We only have to do this if we need to read the, swapbuffers performs a flush for us */
-    context->gl_info->gl_ops.gl.p_glFlush();
-    /* No checkGLcall here to avoid locking the lock just for checking a call that hardly ever
-     * fails. */
-    context_release(context);
-
     device->inScene = FALSE;
     return WINED3D_OK;
 }
@@ -3186,6 +3116,8 @@ HRESULT CDECL wined3d_device_present(const struct wined3d_device *device, const
 HRESULT CDECL wined3d_device_clear(struct wined3d_device *device, DWORD rect_count,
         const RECT *rects, DWORD flags, const struct wined3d_color *color, float depth, DWORD stencil)
 {
+    const struct wined3d_fb_state *fb = &device->state.fb;
+
     TRACE("device %p, rect_count %u, rects %p, flags %#x, color {%.8e, %.8e, %.8e, %.8e}, depth %.8e, stencil %u.\n",
             device, rect_count, rects, flags, color->r, color->g, color->b, color->a, depth, stencil);
 
@@ -3194,10 +3126,12 @@ HRESULT CDECL wined3d_device_clear(struct wined3d_device *device, DWORD rect_cou
         WARN("Rects is %p, but rect_count is 0, ignoring clear\n", rects);
         return WINED3D_OK;
     }
+    if (rect_count && !rects)
+        rect_count = 0;
 
     if (flags & (WINED3DCLEAR_ZBUFFER | WINED3DCLEAR_STENCIL))
     {
-        struct wined3d_surface *ds = device->fb.depth_stencil;
+        struct wined3d_surface *ds = fb->depth_stencil;
         if (!ds)
         {
             WARN("Clearing depth and/or stencil without a depth stencil buffer attached, returning WINED3DERR_INVALIDCALL\n");
@@ -3206,8 +3140,8 @@ HRESULT CDECL wined3d_device_clear(struct wined3d_device *device, DWORD rect_cou
         }
         else if (flags & WINED3DCLEAR_TARGET)
         {
-            if (ds->resource.width < device->fb.render_targets[0]->resource.width
-                    || ds->resource.height < device->fb.render_targets[0]->resource.height)
+            if (ds->resource.width < fb->render_targets[0]->resource.width
+                    || ds->resource.height < fb->render_targets[0]->resource.height)
             {
                 WARN("Silently ignoring depth and target clear with mismatching sizes\n");
                 return WINED3D_OK;
@@ -3224,7 +3158,6 @@ void CDECL wined3d_device_set_primitive_type(struct wined3d_device *device,
         enum wined3d_primitive_type primitive_type)
 {
     GLenum gl_primitive_type, prev;
-
     TRACE("device %p, primitive_type %s\n", device, debug_d3dprimitivetype(primitive_type));
 
     gl_primitive_type = gl_primitive_type_from_d3d(primitive_type);
@@ -3232,8 +3165,8 @@ void CDECL wined3d_device_set_primitive_type(struct wined3d_device *device,
     device->update_state->gl_primitive_type = gl_primitive_type;
     if (device->recording)
         device->recording->changed.primitive_type = TRUE;
-    else if (gl_primitive_type != prev && (gl_primitive_type == GL_POINTS || prev == GL_POINTS))
-        device_invalidate_state(device, STATE_POINT_SIZE_ENABLE);
+    else if (gl_primitive_type != prev)
+        wined3d_cs_emit_set_primitive_type(device->cs, gl_primitive_type);
 }
 
 void CDECL wined3d_device_get_primitive_type(const struct wined3d_device *device,
@@ -3256,12 +3189,6 @@ HRESULT CDECL wined3d_device_draw_primitive(struct wined3d_device *device, UINT
         return WINED3DERR_INVALIDCALL;
     }
 
-    if (device->state.load_base_vertex_index)
-    {
-        device->state.load_base_vertex_index = 0;
-        device_invalidate_state(device, STATE_BASEVERTEXINDEX);
-    }
-
     wined3d_cs_emit_draw(device->cs, start_vertex, vertex_count, 0, 0, FALSE);
 
     return WINED3D_OK;
@@ -3269,8 +3196,6 @@ HRESULT CDECL wined3d_device_draw_primitive(struct wined3d_device *device, UINT
 
 HRESULT CDECL wined3d_device_draw_indexed_primitive(struct wined3d_device *device, UINT start_idx, UINT index_count)
 {
-    const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
-
     TRACE("device %p, start_idx %u, index_count %u.\n", device, start_idx, index_count);
 
     if (!device->state.index_buffer)
@@ -3289,13 +3214,6 @@ HRESULT CDECL wined3d_device_draw_indexed_primitive(struct wined3d_device *devic
         return WINED3DERR_INVALIDCALL;
     }
 
-    if (!gl_info->supported[ARB_DRAW_ELEMENTS_BASE_VERTEX] &&
-        device->state.load_base_vertex_index != device->state.base_vertex_index)
-    {
-        device->state.load_base_vertex_index = device->state.base_vertex_index;
-        device_invalidate_state(device, STATE_BASEVERTEXINDEX);
-    }
-
     wined3d_cs_emit_draw(device->cs, start_idx, index_count, 0, 0, TRUE);
 
     return WINED3D_OK;
@@ -3310,16 +3228,14 @@ void CDECL wined3d_device_draw_indexed_primitive_instanced(struct wined3d_device
 }
 
 /* This is a helper function for UpdateTexture, there is no UpdateVolume method in D3D. */
-static HRESULT device_update_volume(struct wined3d_device *device,
+static HRESULT device_update_volume(struct wined3d_context *context,
         struct wined3d_volume *src_volume, struct wined3d_volume *dst_volume)
 {
-    struct wined3d_map_desc src;
     HRESULT hr;
     struct wined3d_bo_address data;
-    struct wined3d_context *context;
 
-    TRACE("device %p, src_volume %p, dst_volume %p.\n",
-            device, src_volume, dst_volume);
+    TRACE("src_volume %p, dst_volume %p.\n",
+            src_volume, dst_volume);
 
     if (src_volume->resource.format != dst_volume->resource.format)
     {
@@ -3334,73 +3250,24 @@ static HRESULT device_update_volume(struct wined3d_device *device,
         return WINED3DERR_INVALIDCALL;
     }
 
-    if (FAILED(hr = wined3d_volume_map(src_volume, &src, NULL, WINED3D_MAP_READONLY)))
-        return hr;
-
-    context = context_acquire(device, NULL);
-
     wined3d_volume_load(dst_volume, context, FALSE);
-
-    data.buffer_object = 0;
-    data.addr = src.data;
+    wined3d_resource_get_memory(&src_volume->resource, src_volume->resource.map_binding, &data);
     wined3d_volume_upload_data(dst_volume, context, &data);
-    wined3d_volume_invalidate_location(dst_volume, ~WINED3D_LOCATION_TEXTURE_RGB);
-
-    context_release(context);
-
-    hr = wined3d_volume_unmap(src_volume);
+    wined3d_resource_invalidate_location(&dst_volume->resource, ~WINED3D_LOCATION_TEXTURE_RGB);
 
     return hr;
 }
 
-HRESULT CDECL wined3d_device_update_texture(struct wined3d_device *device,
-        struct wined3d_texture *src_texture, struct wined3d_texture *dst_texture)
+/* Context activation is done by the caller */
+void device_exec_update_texture(struct wined3d_context *context, struct wined3d_texture *src_texture,
+        struct wined3d_texture *dst_texture)
 {
-    enum wined3d_resource_type type;
-    unsigned int level_count, i;
-    HRESULT hr;
-    struct wined3d_context *context;
-
-    TRACE("device %p, src_texture %p, dst_texture %p.\n", device, src_texture, dst_texture);
-
-    /* Verify that the source and destination textures are non-NULL. */
-    if (!src_texture || !dst_texture)
-    {
-        WARN("Source and destination textures must be non-NULL, returning WINED3DERR_INVALIDCALL.\n");
-        return WINED3DERR_INVALIDCALL;
-    }
-
-    if (src_texture->resource.pool != WINED3D_POOL_SYSTEM_MEM)
-    {
-        WARN("Source texture not in WINED3D_POOL_SYSTEM_MEM, returning WINED3DERR_INVALIDCALL.\n");
-        return WINED3DERR_INVALIDCALL;
-    }
-    if (dst_texture->resource.pool != WINED3D_POOL_DEFAULT)
-    {
-        WARN("Destination texture not in WINED3D_POOL_DEFAULT, returning WINED3DERR_INVALIDCALL.\n");
-        return WINED3DERR_INVALIDCALL;
-    }
-
-    /* Verify that the source and destination textures are the same type. */
-    type = src_texture->resource.type;
-    if (dst_texture->resource.type != type)
-    {
-        WARN("Source and destination have different types, returning WINED3DERR_INVALIDCALL.\n");
-        return WINED3DERR_INVALIDCALL;
-    }
-
-    /* Check that both textures have the identical numbers of levels. */
-    level_count = wined3d_texture_get_level_count(src_texture);
-    if (wined3d_texture_get_level_count(dst_texture) != level_count)
-    {
-        WARN("Source and destination have different level counts, returning WINED3DERR_INVALIDCALL.\n");
-        return WINED3DERR_INVALIDCALL;
-    }
+    enum wined3d_resource_type type = src_texture->resource.type;
+    unsigned int level_count = wined3d_texture_get_level_count(src_texture);
+    unsigned int i;
 
     /* Make sure that the destination texture is loaded. */
-    context = context_acquire(device, NULL);
     wined3d_texture_load(dst_texture, context, FALSE);
-    context_release(context);
 
     /* Update every surface level of the texture. */
     switch (type)
@@ -3414,12 +3281,7 @@ HRESULT CDECL wined3d_device_update_texture(struct wined3d_device *device,
             {
                 src_surface = surface_from_resource(wined3d_texture_get_sub_resource(src_texture, i));
                 dst_surface = surface_from_resource(wined3d_texture_get_sub_resource(dst_texture, i));
-                hr = wined3d_device_update_surface(device, src_surface, NULL, dst_surface, NULL);
-                if (FAILED(hr))
-                {
-                    WARN("Failed to update surface, hr %#x.\n", hr);
-                    return hr;
-                }
+                surface_upload_from_surface(dst_surface, NULL, src_surface, NULL);
             }
             break;
         }
@@ -3433,12 +3295,7 @@ HRESULT CDECL wined3d_device_update_texture(struct wined3d_device *device,
             {
                 src_surface = surface_from_resource(wined3d_texture_get_sub_resource(src_texture, i));
                 dst_surface = surface_from_resource(wined3d_texture_get_sub_resource(dst_texture, i));
-                hr = wined3d_device_update_surface(device, src_surface, NULL, dst_surface, NULL);
-                if (FAILED(hr))
-                {
-                    WARN("Failed to update surface, hr %#x.\n", hr);
-                    return hr;
-                }
+                surface_upload_from_surface(dst_surface, NULL, src_surface, NULL);
             }
             break;
         }
@@ -3447,13 +3304,14 @@ HRESULT CDECL wined3d_device_update_texture(struct wined3d_device *device,
         {
             for (i = 0; i < level_count; ++i)
             {
-                hr = device_update_volume(device,
+                HRESULT hr;
+                hr = device_update_volume(context,
                         volume_from_resource(wined3d_texture_get_sub_resource(src_texture, i)),
                         volume_from_resource(wined3d_texture_get_sub_resource(dst_texture, i)));
                 if (FAILED(hr))
                 {
                     WARN("Failed to update volume, hr %#x.\n", hr);
-                    return hr;
+                    return;
                 }
             }
             break;
@@ -3461,9 +3319,54 @@ HRESULT CDECL wined3d_device_update_texture(struct wined3d_device *device,
 
         default:
             FIXME("Unsupported texture type %#x.\n", type);
-            return WINED3DERR_INVALIDCALL;
+            return;
+    }
+}
+
+HRESULT CDECL wined3d_device_update_texture(struct wined3d_device *device,
+        struct wined3d_texture *src_texture, struct wined3d_texture *dst_texture)
+{
+    enum wined3d_resource_type type;
+    unsigned int level_count;
+
+    TRACE("device %p, src_texture %p, dst_texture %p.\n", device, src_texture, dst_texture);
+
+    /* Verify that the source and destination textures are non-NULL. */
+    if (!src_texture || !dst_texture)
+    {
+        WARN("Source and destination textures must be non-NULL, returning WINED3DERR_INVALIDCALL.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    if (src_texture->resource.pool != WINED3D_POOL_SYSTEM_MEM)
+    {
+        WARN("Source texture not in WINED3D_POOL_SYSTEM_MEM, returning WINED3DERR_INVALIDCALL.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+    if (dst_texture->resource.pool != WINED3D_POOL_DEFAULT)
+    {
+        WARN("Destination texture not in WINED3D_POOL_DEFAULT, returning WINED3DERR_INVALIDCALL.\n");
+        return WINED3DERR_INVALIDCALL;
     }
 
+    /* Verify that the source and destination textures are the same type. */
+    type = src_texture->resource.type;
+    if (dst_texture->resource.type != type)
+    {
+        WARN("Source and destination have different types, returning WINED3DERR_INVALIDCALL.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    /* Check that both textures have the identical numbers of levels. */
+    level_count = wined3d_texture_get_level_count(src_texture);
+    if (wined3d_texture_get_level_count(dst_texture) != level_count)
+    {
+        WARN("Source and destination have different level counts, returning WINED3DERR_INVALIDCALL.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    wined3d_cs_emit_update_texture(device->cs, src_texture, dst_texture);
+
     return WINED3D_OK;
 }
 
@@ -3525,8 +3428,8 @@ HRESULT CDECL wined3d_device_validate_device(const struct wined3d_device *device
     if (state->render_states[WINED3D_RS_ZENABLE] || state->render_states[WINED3D_RS_ZWRITEENABLE]
             || state->render_states[WINED3D_RS_STENCILENABLE])
     {
-        struct wined3d_surface *ds = device->fb.depth_stencil;
-        struct wined3d_surface *target = device->fb.render_targets[0];
+        struct wined3d_surface *ds = state->fb.depth_stencil;
+        struct wined3d_surface *target = state->fb.render_targets[0];
 
         if(ds && target
                 && (ds->resource.width < target->resource.width || ds->resource.height < target->resource.height))
@@ -3624,6 +3527,13 @@ HRESULT CDECL wined3d_device_update_surface(struct wined3d_device *device,
         struct wined3d_surface *src_surface, const RECT *src_rect,
         struct wined3d_surface *dst_surface, const POINT *dst_point)
 {
+    const struct wined3d_format *src_format = src_surface->resource.format;
+    const struct wined3d_format *dst_format = dst_surface->resource.format;
+    UINT update_w, update_h;
+    UINT dst_w, dst_h;
+    RECT r, dst_rect;
+    POINT p;
+
     TRACE("device %p, src_surface %p, src_rect %s, dst_surface %p, dst_point %s.\n",
             device, src_surface, wine_dbgstr_rect(src_rect),
             dst_surface, wine_dbgstr_point(dst_point));
@@ -3635,7 +3545,68 @@ HRESULT CDECL wined3d_device_update_surface(struct wined3d_device *device,
         return WINED3DERR_INVALIDCALL;
     }
 
-    return surface_upload_from_surface(dst_surface, dst_point, src_surface, src_rect);
+    if (src_format->id != dst_format->id)
+    {
+        WARN("Source and destination surfaces should have the same format.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    if (!dst_point)
+    {
+        p.x = 0;
+        p.y = 0;
+        dst_point = &p;
+    }
+    else if (dst_point->x < 0 || dst_point->y < 0)
+    {
+        WARN("Invalid destination point.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    if (!src_rect)
+    {
+        r.left = 0;
+        r.top = 0;
+        r.right = src_surface->resource.width;
+        r.bottom = src_surface->resource.height;
+        src_rect = &r;
+    }
+    else if (src_rect->left < 0 || src_rect->left >= src_rect->right
+            || src_rect->top < 0 || src_rect->top >= src_rect->bottom)
+    {
+        WARN("Invalid source rectangle.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    dst_w = dst_surface->resource.width;
+    dst_h = dst_surface->resource.height;
+
+    update_w = src_rect->right - src_rect->left;
+    update_h = src_rect->bottom - src_rect->top;
+
+    if (update_w > dst_w || dst_point->x > dst_w - update_w
+            || update_h > dst_h || dst_point->y > dst_h - update_h)
+    {
+        WARN("Destination out of bounds.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    if ((src_format->flags & WINED3DFMT_FLAG_BLOCKS) && !surface_check_block_align(src_surface, src_rect))
+    {
+        WARN("Source rectangle not block-aligned.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    SetRect(&dst_rect, dst_point->x, dst_point->y, dst_point->x + update_w, dst_point->y + update_h);
+    if ((dst_format->flags & WINED3DFMT_FLAG_BLOCKS) && !surface_check_block_align(dst_surface, &dst_rect))
+    {
+        WARN("Destination rectangle not block-aligned.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    wined3d_cs_emit_update_surface(device->cs, src_surface, src_rect, dst_surface, dst_point);
+
+    return WINED3D_OK;
 }
 
 HRESULT CDECL wined3d_device_color_fill(struct wined3d_device *device,
@@ -3659,7 +3630,9 @@ HRESULT CDECL wined3d_device_color_fill(struct wined3d_device *device,
         rect = &r;
     }
 
-    return surface_color_fill(surface, rect, color);
+    wined3d_cs_emit_color_fill(device->cs, surface, rect, color);
+
+    return WINED3D_OK;
 }
 
 void CDECL wined3d_device_clear_rendertarget_view(struct wined3d_device *device,
@@ -3676,6 +3649,13 @@ void CDECL wined3d_device_clear_rendertarget_view(struct wined3d_device *device,
         return;
     }
 
+    if (wined3d_settings.cs_multithreaded)
+    {
+        FIXME("Waiting for cs.\n");
+        wined3d_cs_emit_glfinish(device->cs);
+        device->cs->ops->finish(device->cs);
+    }
+
     SetRect(&rect, 0, 0, resource->width, resource->height);
     hr = surface_color_fill(surface_from_resource(resource), &rect, color);
     if (FAILED(hr)) ERR("Color fill failed, hr %#x.\n", hr);
@@ -3692,20 +3672,21 @@ struct wined3d_surface * CDECL wined3d_device_get_render_target(const struct win
         return NULL;
     }
 
-    return device->fb.render_targets[render_target_idx];
+    return device->state.fb.render_targets[render_target_idx];
 }
 
 struct wined3d_surface * CDECL wined3d_device_get_depth_stencil(const struct wined3d_device *device)
 {
     TRACE("device %p.\n", device);
 
-    return device->fb.depth_stencil;
+    return device->state.fb.depth_stencil;
 }
 
 HRESULT CDECL wined3d_device_set_render_target(struct wined3d_device *device,
         UINT render_target_idx, struct wined3d_surface *render_target, BOOL set_viewport)
 {
     struct wined3d_surface *prev;
+    struct wined3d_fb_state *fb = &device->state.fb;
 
     TRACE("device %p, render_target_idx %u, render_target %p, set_viewport %#x.\n",
             device, render_target_idx, render_target, set_viewport);
@@ -3745,13 +3726,13 @@ HRESULT CDECL wined3d_device_set_render_target(struct wined3d_device *device,
     }
 
 
-    prev = device->fb.render_targets[render_target_idx];
+    prev = fb->render_targets[render_target_idx];
     if (render_target == prev)
         return WINED3D_OK;
 
     if (render_target)
         wined3d_surface_incref(render_target);
-    device->fb.render_targets[render_target_idx] = render_target;
+    fb->render_targets[render_target_idx] = render_target;
     wined3d_cs_emit_set_render_target(device->cs, render_target_idx, render_target);
     /* Release after the assignment, to prevent device_resource_released()
      * from seeing the surface as still in use. */
@@ -3763,7 +3744,8 @@ HRESULT CDECL wined3d_device_set_render_target(struct wined3d_device *device,
 
 void CDECL wined3d_device_set_depth_stencil(struct wined3d_device *device, struct wined3d_surface *depth_stencil)
 {
-    struct wined3d_surface *prev = device->fb.depth_stencil;
+    struct wined3d_fb_state *fb = &device->state.fb;
+    struct wined3d_surface *prev = fb->depth_stencil;
 
     TRACE("device %p, depth_stencil %p, old depth_stencil %p.\n",
             device, depth_stencil, prev);
@@ -3774,7 +3756,7 @@ void CDECL wined3d_device_set_depth_stencil(struct wined3d_device *device, struc
         return;
     }
 
-    device->fb.depth_stencil = depth_stencil;
+    fb->depth_stencil = depth_stencil;
     if (depth_stencil)
         wined3d_surface_incref(depth_stencil);
     wined3d_cs_emit_set_depth_stencil(device->cs, depth_stencil);
@@ -3782,77 +3764,12 @@ void CDECL wined3d_device_set_depth_stencil(struct wined3d_device *device, struc
         wined3d_surface_decref(prev);
 }
 
-static struct wined3d_texture *wined3d_device_create_cursor_texture(struct wined3d_device *device,
-        struct wined3d_surface *cursor_image)
-{
-    struct wined3d_resource_desc desc;
-    struct wined3d_map_desc map_desc;
-    struct wined3d_texture *texture;
-    struct wined3d_surface *surface;
-    BYTE *src_data, *dst_data;
-    unsigned int src_pitch;
-    unsigned int i;
-
-    if (FAILED(wined3d_surface_map(cursor_image, &map_desc, NULL, WINED3D_MAP_READONLY)))
-    {
-        ERR("Failed to map source surface.\n");
-        return NULL;
-    }
-
-    src_pitch = map_desc.row_pitch;
-    src_data = map_desc.data;
-
-    desc.resource_type = WINED3D_RTYPE_TEXTURE;
-    desc.format = WINED3DFMT_B8G8R8A8_UNORM;
-    desc.multisample_type = WINED3D_MULTISAMPLE_NONE;
-    desc.multisample_quality = 0;
-    desc.usage = WINED3DUSAGE_DYNAMIC;
-    desc.pool = WINED3D_POOL_DEFAULT;
-    desc.width = cursor_image->resource.width;
-    desc.height = cursor_image->resource.height;
-    desc.depth = 1;
-    desc.size = 0;
-
-    if (FAILED(wined3d_texture_create(device, &desc, 1, WINED3D_SURFACE_MAPPABLE,
-            NULL, &wined3d_null_parent_ops, &texture)))
-    {
-        ERR("Failed to create cursor texture.\n");
-        wined3d_surface_unmap(cursor_image);
-        return NULL;
-    }
-
-    surface = surface_from_resource(wined3d_texture_get_sub_resource(texture, 0));
-    if (FAILED(wined3d_surface_map(surface, &map_desc, NULL, WINED3D_MAP_DISCARD)))
-    {
-        ERR("Failed to map destination surface.\n");
-        wined3d_texture_decref(texture);
-        wined3d_surface_unmap(cursor_image);
-        return NULL;
-    }
-
-    dst_data = map_desc.data;
-
-    for (i = 0; i < desc.height; ++i)
-        memcpy(&dst_data[map_desc.row_pitch * i], &src_data[src_pitch * i], desc.width * 4);
-
-    wined3d_surface_unmap(surface);
-    wined3d_surface_unmap(cursor_image);
-
-    return texture;
-}
-
 HRESULT CDECL wined3d_device_set_cursor_properties(struct wined3d_device *device,
         UINT x_hotspot, UINT y_hotspot, struct wined3d_surface *cursor_image)
 {
     TRACE("device %p, x_hotspot %u, y_hotspot %u, cursor_image %p.\n",
             device, x_hotspot, y_hotspot, cursor_image);
 
-    if (device->cursor_texture)
-    {
-        wined3d_texture_decref(device->cursor_texture);
-        device->cursor_texture = NULL;
-    }
-
     if (cursor_image)
     {
         struct wined3d_display_mode mode;
@@ -3887,11 +3804,8 @@ HRESULT CDECL wined3d_device_set_cursor_properties(struct wined3d_device *device
          * release it after setting the cursor image. Windows doesn't
          * addref the set surface, so we can't do this either without
          * creating circular refcount dependencies. */
-        if (!(device->cursor_texture = wined3d_device_create_cursor_texture(device, cursor_image)))
-        {
-            ERR("Failed to create cursor texture.\n");
-            return WINED3DERR_INVALIDCALL;
-        }
+        device->cursorWidth = cursor_image->resource.width;
+        device->cursorHeight = cursor_image->resource.height;
 
         device->cursorWidth = cursor_image->resource.width;
         device->cursorHeight = cursor_image->resource.height;
@@ -3991,10 +3905,6 @@ BOOL CDECL wined3d_device_show_cursor(struct wined3d_device *device, BOOL show)
         else
             SetCursor(NULL);
     }
-    else if (device->cursor_texture)
-    {
-        device->bCursorVisible = show;
-    }
 
     return oldVisible;
 }
@@ -4005,6 +3915,8 @@ void CDECL wined3d_device_evict_managed_resources(struct wined3d_device *device)
 
     TRACE("device %p.\n", device);
 
+    /* The resource list is manged by the main thread, iterate here and emit commands for
+     * each resource */
     LIST_FOR_EACH_ENTRY_SAFE(resource, cursor, &device->resources, struct wined3d_resource, resource_list_entry)
     {
         TRACE("Checking resource %p for eviction.\n", resource);
@@ -4012,36 +3924,25 @@ void CDECL wined3d_device_evict_managed_resources(struct wined3d_device *device)
         if (resource->pool == WINED3D_POOL_MANAGED && !resource->map_count)
         {
             TRACE("Evicting %p.\n", resource);
-            resource->resource_ops->resource_unload(resource);
+            wined3d_cs_emit_evict_resource(device->cs, resource);
         }
     }
-
-    /* Invalidate stream sources, the buffer(s) may have been evicted. */
-    device_invalidate_state(device, STATE_STREAMSRC);
 }
 
-static void delete_opengl_contexts(struct wined3d_device *device, struct wined3d_swapchain *swapchain)
+void device_delete_opengl_contexts_cs(struct wined3d_device *device, struct wined3d_swapchain *swapchain)
 {
-    struct wined3d_resource *resource, *cursor;
     const struct wined3d_gl_info *gl_info;
     struct wined3d_context *context;
     struct wined3d_shader *shader;
 
-    context = context_acquire(device, NULL);
-    gl_info = context->gl_info;
-
-    LIST_FOR_EACH_ENTRY_SAFE(resource, cursor, &device->resources, struct wined3d_resource, resource_list_entry)
-    {
-        TRACE("Unloading resource %p.\n", resource);
-
-        resource->resource_ops->resource_unload(resource);
-    }
-
     LIST_FOR_EACH_ENTRY(shader, &device->shaders, struct wined3d_shader, shader_list_entry)
     {
         device->shader_backend->shader_destroy(shader);
     }
 
+    context = context_acquire(device, NULL);
+    gl_info = context->gl_info;
+
     if (device->depth_blt_texture)
     {
         gl_info->gl_ops.gl.p_glDeleteTextures(1, &device->depth_blt_texture);
@@ -4061,12 +3962,25 @@ static void delete_opengl_contexts(struct wined3d_device *device, struct wined3d
 
     HeapFree(GetProcessHeap(), 0, swapchain->context);
     swapchain->context = NULL;
+    swapchain->num_contexts = 0;
+}
+
+static void delete_opengl_contexts(struct wined3d_device *device, struct wined3d_swapchain *swapchain)
+{
+    struct wined3d_resource *resource, *cursor;
+
+    LIST_FOR_EACH_ENTRY_SAFE(resource, cursor, &device->resources, struct wined3d_resource, resource_list_entry)
+    {
+        TRACE("Unloading resource %p.\n", resource);
+
+        wined3d_cs_emit_evict_resource(device->cs, resource);
+    }
+
+    wined3d_cs_emit_delete_opengl_contexts(device->cs, swapchain);
 }
 
 static HRESULT create_primary_opengl_context(struct wined3d_device *device, struct wined3d_swapchain *swapchain)
 {
-    struct wined3d_context *context;
-    struct wined3d_surface *target;
     HRESULT hr;
 
     if (FAILED(hr = device->shader_backend->shader_alloc_private(device,
@@ -4083,30 +3997,15 @@ static HRESULT create_primary_opengl_context(struct wined3d_device *device, stru
         return hr;
     }
 
-    /* Recreate the primary swapchain's context */
-    swapchain->context = HeapAlloc(GetProcessHeap(), 0, sizeof(*swapchain->context));
-    if (!swapchain->context)
-    {
-        ERR("Failed to allocate memory for swapchain context array.\n");
-        device->blitter->free_private(device);
-        device->shader_backend->shader_free_private(device);
-        return E_OUTOFMEMORY;
-    }
-
-    target = swapchain->back_buffers ? swapchain->back_buffers[0] : swapchain->front_buffer;
-    if (!(context = context_create(swapchain, target, swapchain->ds_format)))
+    hr = wined3d_cs_emit_create_swapchain_context(device->cs, swapchain);
+    if (FAILED(hr))
     {
         WARN("Failed to create context.\n");
         device->blitter->free_private(device);
         device->shader_backend->shader_free_private(device);
-        HeapFree(GetProcessHeap(), 0, swapchain->context);
-        return E_FAIL;
+        return hr;
     }
-
-    swapchain->context[0] = context;
-    swapchain->num_contexts = 1;
-    create_dummy_textures(device, context);
-    context_release(context);
+    wined3d_cs_emit_create_dummy_textures(device->cs);
 
     return WINED3D_OK;
 }
@@ -4127,6 +4026,13 @@ HRESULT CDECL wined3d_device_reset(struct wined3d_device *device,
 
     TRACE("device %p, swapchain_desc %p, mode %p, callback %p.\n", device, swapchain_desc, mode, callback);
 
+    if (wined3d_settings.cs_multithreaded)
+    {
+        FIXME("Waiting for cs.\n");
+        wined3d_cs_emit_glfinish(device->cs);
+        device->cs->ops->finish(device->cs);
+    }
+
     if (!(swapchain = wined3d_device_get_swapchain(device, 0)))
     {
         ERR("Failed to get the first implicit swapchain.\n");
@@ -4140,29 +4046,28 @@ HRESULT CDECL wined3d_device_reset(struct wined3d_device *device,
             wined3d_texture_decref(device->logo_texture);
             device->logo_texture = NULL;
         }
-        if (device->cursor_texture)
-        {
-            wined3d_texture_decref(device->cursor_texture);
-            device->cursor_texture = NULL;
-        }
         state_unbind_resources(&device->state);
     }
 
-    if (device->fb.render_targets)
+    if (device->state.fb.render_targets)
     {
         for (i = 0; i < device->adapter->gl_info.limits.buffers; ++i)
         {
             wined3d_device_set_render_target(device, i, NULL, FALSE);
         }
-        if (swapchain->back_buffers && swapchain->back_buffers[0])
-            wined3d_device_set_render_target(device, 0, swapchain->back_buffers[0], FALSE);
     }
+
     wined3d_device_set_depth_stencil(device, NULL);
 
-    if (device->onscreen_depth_stencil)
+    if (reset_state)
     {
-        wined3d_surface_decref(device->onscreen_depth_stencil);
-        device->onscreen_depth_stencil = NULL;
+        state_unbind_resources(&device->state);
+    }
+
+    if (device->cs->onscreen_depth_stencil)
+    {
+        wined3d_surface_decref(device->cs->onscreen_depth_stencil);
+        device->cs->onscreen_depth_stencil = NULL;
     }
 
     if (reset_state)
@@ -4249,10 +4154,6 @@ HRESULT CDECL wined3d_device_reset(struct wined3d_device *device,
         }
     }
 
-    /* Reset the depth stencil */
-    if (swapchain_desc->enable_auto_depth_stencil)
-        wined3d_device_set_depth_stencil(device, device->auto_depth_stencil);
-
     if (mode)
     {
         DisplayModeChanged = TRUE;
@@ -4417,11 +4318,12 @@ HRESULT CDECL wined3d_device_reset(struct wined3d_device *device,
         }
         wined3d_cs_emit_reset_state(device->cs);
         state_cleanup(&device->state);
+        memset(&device->state, 0, sizeof(device->state));
 
         if (device->d3d_initialized)
             delete_opengl_contexts(device, swapchain);
 
-        if (FAILED(hr = state_init(&device->state, &device->fb, &device->adapter->gl_info,
+        if (FAILED(hr = state_init(&device->state, &device->adapter->gl_info,
                 &device->adapter->d3d_info, WINED3D_STATE_INIT_DEFAULT)))
             ERR("Failed to initialize device state, hr %#x.\n", hr);
         device->update_state = &device->state;
@@ -4430,23 +4332,29 @@ HRESULT CDECL wined3d_device_reset(struct wined3d_device *device,
     }
     else
     {
-        struct wined3d_surface *rt = device->fb.render_targets[0];
         struct wined3d_state *state = &device->state;
 
         /* Note the min_z / max_z is not reset. */
         state->viewport.x = 0;
         state->viewport.y = 0;
-        state->viewport.width = rt->resource.width;
-        state->viewport.height = rt->resource.height;
+        state->viewport.width = swapchain->desc.backbuffer_width;
+        state->viewport.height = swapchain->desc.backbuffer_height;
         wined3d_cs_emit_set_viewport(device->cs, &state->viewport);
 
         state->scissor_rect.top = 0;
         state->scissor_rect.left = 0;
-        state->scissor_rect.right = rt->resource.width;
-        state->scissor_rect.bottom = rt->resource.height;
+        state->scissor_rect.right = swapchain->desc.backbuffer_width;
+        state->scissor_rect.bottom = swapchain->desc.backbuffer_height;
         wined3d_cs_emit_set_scissor_rect(device->cs, &state->scissor_rect);
     }
 
+    if (swapchain->back_buffers && swapchain->back_buffers[0])
+        wined3d_device_set_render_target(device, 0, swapchain->back_buffers[0], FALSE);
+
+    /* Reset the depth stencil */
+    if (swapchain_desc->enable_auto_depth_stencil)
+        wined3d_device_set_depth_stencil(device, device->auto_depth_stencil);
+
     swapchain_update_render_to_fbo(swapchain);
     swapchain_update_draw_bindings(swapchain);
 
@@ -4534,17 +4442,17 @@ void device_resource_released(struct wined3d_device *device, struct wined3d_reso
 
                 for (i = 0; i < device->adapter->gl_info.limits.buffers; ++i)
                 {
-                    if (device->fb.render_targets[i] == surface)
+                    if (device->state.fb.render_targets[i] == surface)
                     {
                         ERR("Surface %p is still in use as render target %u.\n", surface, i);
-                        device->fb.render_targets[i] = NULL;
+                        device->state.fb.render_targets[i] = NULL;
                     }
                 }
 
-                if (device->fb.depth_stencil == surface)
+                if (device->state.fb.depth_stencil == surface)
                 {
                     ERR("Surface %p is still in use as depth/stencil buffer.\n", surface);
-                    device->fb.depth_stencil = NULL;
+                    device->state.fb.depth_stencil = NULL;
                 }
             }
             break;
@@ -4685,7 +4593,7 @@ HRESULT device_init(struct wined3d_device *device, struct wined3d *wined3d,
 
     device->blitter = adapter->blitter;
 
-    if (FAILED(hr = state_init(&device->state, &device->fb, &adapter->gl_info,
+    if (FAILED(hr = state_init(&device->state, &adapter->gl_info,
             &adapter->d3d_info, WINED3D_STATE_INIT_DEFAULT)))
     {
         ERR("Failed to initialize device state, hr %#x.\n", hr);
@@ -4781,3 +4689,56 @@ LRESULT device_process_message(struct wined3d_device *device, HWND window, BOOL
     else
         return CallWindowProcA(proc, window, message, wparam, lparam);
 }
+
+/* Context activation is done by the caller */
+struct wined3d_gl_bo *wined3d_device_get_bo(struct wined3d_device *device, UINT size, GLenum gl_usage,
+        GLenum type_hint, struct wined3d_context *context)
+{
+    struct wined3d_gl_bo *ret;
+    const struct wined3d_gl_info *gl_info;
+
+    TRACE("device %p, size %u, gl_usage %u, type_hint %u\n", device, size, gl_usage,
+            type_hint);
+
+    ret = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*ret));
+    if(!ret)
+        return NULL;
+    ret->type_hint = type_hint;
+    ret->size = size;
+    ret->usage = gl_usage;
+
+    gl_info = context->gl_info;
+
+    GL_EXTCALL(glGenBuffersARB(1, &ret->name));
+    if (type_hint == GL_ELEMENT_ARRAY_BUFFER_ARB)
+        context_invalidate_state(context, STATE_INDEXBUFFER);
+    GL_EXTCALL(glBindBufferARB(type_hint, ret->name));
+    GL_EXTCALL(glBufferDataARB(type_hint, size, NULL, gl_usage));
+    GL_EXTCALL(glBindBufferARB(type_hint, 0));
+    checkGLcall("Create buffer object");
+
+    TRACE("Successfully created and set up buffer %u\n", ret->name);
+    return ret;
+}
+
+/* Context activation is done by the caller */
+static void wined3d_device_destroy_bo(struct wined3d_device *device, const struct wined3d_context *context,
+        struct wined3d_gl_bo *bo)
+{
+    const struct wined3d_gl_info *gl_info = context->gl_info;
+    TRACE("device %p, bo %p, GL bo %u\n", device, bo, bo->name);
+
+    GL_EXTCALL(glDeleteBuffersARB(1, &bo->name));
+    checkGLcall("glDeleteBuffersARB");
+
+    HeapFree(GetProcessHeap(), 0, bo);
+}
+
+/* Context activation is done by the caller */
+void wined3d_device_release_bo(struct wined3d_device *device, struct wined3d_gl_bo *bo,
+        const struct wined3d_context *context)
+{
+    TRACE("device %p, bo %p, GL bo %u\n", device, bo, bo->name);
+
+    wined3d_device_destroy_bo(device, context, bo);
+}
diff --git a/dlls/wined3d/directx.c b/dlls/wined3d/directx.c
index ef81278..5c8117e 100644
--- a/dlls/wined3d/directx.c
+++ b/dlls/wined3d/directx.c
@@ -301,11 +301,16 @@ static void wined3d_caps_gl_ctx_create_attribs(struct wined3d_caps_gl_ctx *caps_
         return;
     }
 
+    wglMakeCurrent(NULL, NULL);
+
     if (!wglMakeCurrent(caps_gl_ctx->dc, new_ctx))
     {
         ERR("Failed to make new context current, last error %#x.\n", GetLastError());
         if (!wglDeleteContext(new_ctx))
             ERR("Failed to delete new context, last error %#x.\n", GetLastError());
+
+        wglMakeCurrent(caps_gl_ctx->dc, caps_gl_ctx->gl_ctx);
+
         gl_info->p_wglCreateContextAttribsARB = NULL;
         return;
     }
@@ -4755,7 +4760,7 @@ static void WINE_GLAPI invalid_texcoord_func(GLenum unit, const void *data)
 }
 
 /* Helper functions for providing vertex data to opengl. The arrays are initialized based on
- * the extension detection and are used in drawStridedSlow
+ * the extension detection and are used in draw_strided_slow
  */
 static void WINE_GLAPI position_d3dcolor(const void *data)
 {
diff --git a/dlls/wined3d/drawprim.c b/dlls/wined3d/drawprim.c
index 43c4e17..cb2d05a 100644
--- a/dlls/wined3d/drawprim.c
+++ b/dlls/wined3d/drawprim.c
@@ -36,7 +36,7 @@ WINE_DECLARE_DEBUG_CHANNEL(d3d_perf);
 #include <math.h>
 
 /* Context activation is done by the caller. */
-static void drawStridedFast(const struct wined3d_gl_info *gl_info, GLenum primitive_type, UINT count, UINT idx_size,
+static void draw_strided_fast(const struct wined3d_gl_info *gl_info, GLenum primitive_type, UINT count, UINT idx_size,
         const void *idx_data, UINT start_idx, INT base_vertex_index, UINT start_instance, UINT instance_count)
 {
     if (idx_size)
@@ -92,7 +92,7 @@ static void drawStridedFast(const struct wined3d_gl_info *gl_info, GLenum primit
  */
 
 /* Context activation is done by the caller. */
-static void drawStridedSlow(const struct wined3d_device *device, struct wined3d_context *context,
+static void draw_strided_slow(const struct wined3d_state *state, struct wined3d_context *context,
         const struct wined3d_stream_info *si, UINT NumVertexes, GLenum glPrimType,
         const void *idxData, UINT idxSize, UINT startIdx)
 {
@@ -100,7 +100,6 @@ static void drawStridedSlow(const struct wined3d_device *device, struct wined3d_
     const WORD                *pIdxBufS     = NULL;
     const DWORD               *pIdxBufL     = NULL;
     UINT vx_index;
-    const struct wined3d_state *state = &device->state;
     LONG SkipnStrides = startIdx;
     BOOL pixelShader = use_ps(state);
     BOOL specular_fog = FALSE;
@@ -450,7 +449,7 @@ static inline void send_attribute(const struct wined3d_gl_info *gl_info,
 }
 
 /* Context activation is done by the caller. */
-static void drawStridedSlowVs(struct wined3d_context *context, const struct wined3d_state *state,
+static void draw_strided_slow_vs(struct wined3d_context *context, const struct wined3d_state *state,
         const struct wined3d_stream_info *si, UINT numberOfVertices, GLenum glPrimitiveType,
         const void *idxData, UINT idxSize, UINT startIdx)
 {
@@ -507,7 +506,7 @@ static void drawStridedSlowVs(struct wined3d_context *context, const struct wine
 }
 
 /* Context activation is done by the caller. */
-static void drawStridedInstanced(struct wined3d_context *context, const struct wined3d_state *state,
+static void draw_strided_instanced(struct wined3d_context *context, const struct wined3d_state *state,
         const struct wined3d_stream_info *si, UINT numberOfVertices, GLenum glPrimitiveType,
         const void *idxData, UINT idxSize, UINT startIdx, UINT base_vertex_index, UINT instance_count)
 {
@@ -592,10 +591,10 @@ static void remove_vbos(struct wined3d_context *context,
 }
 
 /* Routine common to the draw primitive and draw indexed primitive routines */
-void draw_primitive(struct wined3d_device *device, UINT start_idx, UINT index_count,
-        UINT start_instance, UINT instance_count, BOOL indexed)
+void draw_primitive(struct wined3d_device *device, const struct wined3d_state *state,
+        UINT start_idx, UINT index_count, UINT start_instance, UINT instance_count,
+        BOOL indexed)
 {
-    const struct wined3d_state *state = &device->state;
     const struct wined3d_stream_info *stream_info;
     struct wined3d_event_query *ib_query = NULL;
     struct wined3d_stream_info si_emulated;
@@ -608,30 +607,30 @@ void draw_primitive(struct wined3d_device *device, UINT start_idx, UINT index_co
 
     if (!index_count) return;
 
+    context = context_acquire(device, state->fb.render_targets[0]);
+    if (!context->valid)
+    {
+        context_release(context);
+        WARN("Invalid context, skipping draw.\n");
+        return;
+    }
+    gl_info = context->gl_info;
+
     if (state->render_states[WINED3D_RS_COLORWRITEENABLE])
     {
         /* Invalidate the back buffer memory so LockRect will read it the next time */
         for (i = 0; i < device->adapter->gl_info.limits.buffers; ++i)
         {
-            struct wined3d_surface *target = device->fb.render_targets[i];
+            struct wined3d_surface *target = state->fb.render_targets[i];
             if (target)
             {
-                surface_load_location(target, target->draw_binding);
-                surface_invalidate_location(target, ~target->draw_binding);
+                wined3d_resource_load_location(&target->resource, context, target->draw_binding);
+                wined3d_resource_invalidate_location(&target->resource, ~target->draw_binding);
             }
         }
     }
 
-    context = context_acquire(device, device->fb.render_targets[0]);
-    if (!context->valid)
-    {
-        context_release(context);
-        WARN("Invalid context, skipping draw.\n");
-        return;
-    }
-    gl_info = context->gl_info;
-
-    if (device->fb.depth_stencil)
+    if (state->fb.depth_stencil)
     {
         /* Note that this depends on the context_acquire() call above to set
          * context->render_offscreen properly. We don't currently take the
@@ -639,16 +638,16 @@ void draw_primitive(struct wined3d_device *device, UINT start_idx, UINT index_co
          * depthstencil for D3DCMP_NEVER and D3DCMP_ALWAYS as well. Also note
          * that we never copy the stencil data.*/
         DWORD location = context->render_offscreen ?
-                device->fb.depth_stencil->draw_binding : WINED3D_LOCATION_DRAWABLE;
+                state->fb.depth_stencil->draw_binding : WINED3D_LOCATION_DRAWABLE;
         if (state->render_states[WINED3D_RS_ZWRITEENABLE] || state->render_states[WINED3D_RS_ZENABLE])
         {
-            struct wined3d_surface *ds = device->fb.depth_stencil;
+            struct wined3d_surface *ds = state->fb.depth_stencil;
             RECT current_rect, draw_rect, r;
 
-            if (!context->render_offscreen && ds != device->onscreen_depth_stencil)
-                device_switch_onscreen_ds(device, context, ds);
+            if (!context->render_offscreen && ds != device->cs->onscreen_depth_stencil)
+                wined3d_cs_switch_onscreen_ds(device->cs, context, ds);
 
-            if (ds->locations & location)
+            if (ds->resource.locations & location)
                 SetRect(&current_rect, 0, 0, ds->ds_current_size.cx, ds->ds_current_size.cy);
             else
                 SetRectEmpty(&current_rect);
@@ -661,16 +660,16 @@ void draw_primitive(struct wined3d_device *device, UINT start_idx, UINT index_co
         }
     }
 
-    if (!context_apply_draw_state(context, device))
+    if (!context_apply_draw_state(context, device, state))
     {
         context_release(context);
         WARN("Unable to apply draw state, skipping draw.\n");
         return;
     }
 
-    if (device->fb.depth_stencil && state->render_states[WINED3D_RS_ZWRITEENABLE])
+    if (state->fb.depth_stencil && state->render_states[WINED3D_RS_ZWRITEENABLE])
     {
-        struct wined3d_surface *ds = device->fb.depth_stencil;
+        struct wined3d_surface *ds = state->fb.depth_stencil;
         DWORD location = context->render_offscreen ? ds->draw_binding : WINED3D_LOCATION_DRAWABLE;
 
         surface_modify_ds_location(ds, location, ds->ds_current_size.cx, ds->ds_current_size.cy);
@@ -753,24 +752,24 @@ void draw_primitive(struct wined3d_device *device, UINT start_idx, UINT index_co
             else
                 WARN_(d3d_perf)("Using immediate mode with vertex shaders for half float emulation.\n");
 
-            drawStridedSlowVs(context, state, stream_info, index_count,
+            draw_strided_slow_vs(context, state, stream_info, index_count,
                     state->gl_primitive_type, idx_data, idx_size, start_idx);
         }
         else
         {
-            drawStridedSlow(device, context, stream_info, index_count,
+            draw_strided_slow(state, context, stream_info, index_count,
                     state->gl_primitive_type, idx_data, idx_size, start_idx);
         }
     }
     else if (!gl_info->supported[ARB_INSTANCED_ARRAYS] && instance_count)
     {
         /* Instancing emulation by mixing immediate mode and arrays. */
-        drawStridedInstanced(context, state, stream_info, index_count, state->gl_primitive_type,
+        draw_strided_instanced(context, state, stream_info, index_count, state->gl_primitive_type,
                 idx_data, idx_size, start_idx, state->base_vertex_index, instance_count);
     }
     else
     {
-        drawStridedFast(gl_info, state->gl_primitive_type, index_count, idx_size, idx_data,
+        draw_strided_fast(gl_info, state->gl_primitive_type, index_count, idx_size, idx_data,
                 start_idx, state->base_vertex_index, start_instance, instance_count);
     }
 
diff --git a/dlls/wined3d/glsl_shader.c b/dlls/wined3d/glsl_shader.c
index 32ad9e7..55a5659 100644
--- a/dlls/wined3d/glsl_shader.c
+++ b/dlls/wined3d/glsl_shader.c
@@ -966,10 +966,8 @@ static void shader_generate_glsl_declarations(const struct wined3d_context *cont
         const struct wined3d_shader_reg_maps *reg_maps, const struct shader_glsl_ctx_priv *ctx_priv)
 {
     const struct wined3d_shader_version *version = &reg_maps->shader_version;
-    const struct wined3d_state *state = &shader->device->state;
     const struct ps_compile_args *ps_args = ctx_priv->cur_ps_args;
     const struct wined3d_gl_info *gl_info = context->gl_info;
-    const struct wined3d_fb_state *fb = &shader->device->fb;
     unsigned int i, extra_constants_needed = 0;
     const struct wined3d_shader_lconst *lconst;
     const char *prefix;
@@ -1194,7 +1192,7 @@ static void shader_generate_glsl_declarations(const struct wined3d_context *cont
         {
             UINT in_count = min(vec4_varyings(version->major, gl_info), shader->limits.packed_input);
 
-            if (use_vs(state))
+            if (ps_args->vp_mode == vertexshader)
                 shader_addline(buffer, "varying vec4 %s_in[%u];\n", prefix, in_count);
             else
                 /* TODO: Write a replacement shader for the fixed function
@@ -1241,21 +1239,14 @@ static void shader_generate_glsl_declarations(const struct wined3d_context *cont
             }
             else
             {
-                float ycorrection[] =
-                {
-                    context->render_offscreen ? 0.0f : fb->render_targets[0]->resource.height,
-                    context->render_offscreen ? 1.0f : -1.0f,
-                    0.0f,
-                    0.0f,
-                };
-
                 /* This happens because we do not have proper tracking of the
                  * constant registers that are actually used, only the max
-                 * limit of the shader version. */
+                 * limit of the shader version.
+                 *
+                 * FIXME 2: This is wrong, there's no need to do this. Get rid of
+                 * it and just create the uniform.
+                 */
                 FIXME("Cannot find a free uniform for vpos correction params\n");
-                shader_addline(buffer, "const vec4 ycorrection = ");
-                shader_glsl_append_imm_vec4(buffer, ycorrection);
-                shader_addline(buffer, ";\n");
             }
             shader_addline(buffer, "vec4 vpos;\n");
         }
diff --git a/dlls/wined3d/palette.c b/dlls/wined3d/palette.c
index e659952..5db6a46 100644
--- a/dlls/wined3d/palette.c
+++ b/dlls/wined3d/palette.c
@@ -78,15 +78,11 @@ HRESULT CDECL wined3d_palette_get_entries(const struct wined3d_palette *palette,
     return WINED3D_OK;
 }
 
-HRESULT CDECL wined3d_palette_set_entries(struct wined3d_palette *palette,
+void wined3d_exec_palette_set_entries(struct wined3d_palette *palette,
         DWORD flags, DWORD start, DWORD count, const PALETTEENTRY *entries)
 {
     struct wined3d_resource *resource;
 
-    TRACE("palette %p, flags %#x, start %u, count %u, entries %p.\n",
-            palette, flags, start, count, entries);
-    TRACE("Palette flags: %#x.\n", palette->flags);
-
     if (palette->flags & WINED3D_PALETTE_8BIT_ENTRIES)
     {
         const BYTE *entry = (const BYTE *)entries;
@@ -126,7 +122,18 @@ HRESULT CDECL wined3d_palette_set_entries(struct wined3d_palette *palette,
                 surface->surface_ops->surface_realize_palette(surface);
         }
     }
+}
+
+HRESULT CDECL wined3d_palette_set_entries(struct wined3d_palette *palette,
+        DWORD flags, DWORD start, DWORD count, const PALETTEENTRY *entries)
+{
+    struct wined3d_device *device = palette->device;
+
+    TRACE("palette %p, flags %#x, start %u, count %u, entries %p.\n",
+            palette, flags, start, count, entries);
+    TRACE("Palette flags: %#x.\n", palette->flags);
 
+    wined3d_cs_emit_palette_set_entries(device->cs, palette, flags, start, count, entries);
     return WINED3D_OK;
 }
 
diff --git a/dlls/wined3d/query.c b/dlls/wined3d/query.c
index a3a9246..e4b6cc8 100644
--- a/dlls/wined3d/query.c
+++ b/dlls/wined3d/query.c
@@ -233,6 +233,28 @@ ULONG CDECL wined3d_query_incref(struct wined3d_query *query)
     return refcount;
 }
 
+void wined3d_query_destroy(struct wined3d_query *query)
+{
+    /* Queries are specific to the GL context that created them. Not
+     * deleting the query will obviously leak it, but that's still better
+     * than potentially deleting a different query with the same id in this
+     * context, and (still) leaking the actual query. */
+    if (query->type == WINED3D_QUERY_TYPE_EVENT)
+    {
+        struct wined3d_event_query *event_query = query->extendedData;
+        if (event_query) wined3d_event_query_destroy(event_query);
+    }
+    else if (query->type == WINED3D_QUERY_TYPE_OCCLUSION)
+    {
+        struct wined3d_occlusion_query *oq = query->extendedData;
+
+        if (oq->context) context_free_occlusion_query(oq);
+        HeapFree(GetProcessHeap(), 0, query->extendedData);
+    }
+
+    HeapFree(GetProcessHeap(), 0, query);
+}
+
 ULONG CDECL wined3d_query_decref(struct wined3d_query *query)
 {
     ULONG refcount = InterlockedDecrement(&query->ref);
@@ -240,26 +262,7 @@ ULONG CDECL wined3d_query_decref(struct wined3d_query *query)
     TRACE("%p decreasing refcount to %u.\n", query, refcount);
 
     if (!refcount)
-    {
-        /* Queries are specific to the GL context that created them. Not
-         * deleting the query will obviously leak it, but that's still better
-         * than potentially deleting a different query with the same id in this
-         * context, and (still) leaking the actual query. */
-        if (query->type == WINED3D_QUERY_TYPE_EVENT)
-        {
-            struct wined3d_event_query *event_query = query->extendedData;
-            if (event_query) wined3d_event_query_destroy(event_query);
-        }
-        else if (query->type == WINED3D_QUERY_TYPE_OCCLUSION)
-        {
-            struct wined3d_occlusion_query *oq = query->extendedData;
-
-            if (oq->context) context_free_occlusion_query(oq);
-            HeapFree(GetProcessHeap(), 0, query->extendedData);
-        }
-
-        HeapFree(GetProcessHeap(), 0, query);
-    }
+        wined3d_cs_emit_query_destroy(query->device->cs, query);
 
     return refcount;
 }
@@ -284,25 +287,26 @@ HRESULT CDECL wined3d_query_issue(struct wined3d_query *query, DWORD flags)
 {
     TRACE("query %p, flags %#x.\n", query, flags);
 
-    return query->query_ops->query_issue(query, flags);
+    if (flags & WINED3DISSUE_END)
+        query->counter_main++;
+
+    wined3d_cs_emit_query_issue(query->device->cs, query, flags);
+
+    if (flags & WINED3DISSUE_BEGIN)
+        query->state = QUERY_BUILDING;
+    else
+        query->state = QUERY_SIGNALLED;
+
+    return WINED3D_OK;
 }
 
 static HRESULT wined3d_occlusion_query_ops_get_data(struct wined3d_query *query,
         void *pData, DWORD dwSize, DWORD flags)
 {
-    struct wined3d_occlusion_query *oq = query->extendedData;
     struct wined3d_device *device = query->device;
     const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
-    struct wined3d_context *context;
-    DWORD* data = pData;
-    GLuint available;
-    GLuint samples;
-    HRESULT res;
-
-    TRACE("(%p) : type D3DQUERY_OCCLUSION, pData %p, dwSize %#x, flags %#x.\n", query, pData, dwSize, flags);
-
-    if (!oq->context)
-        query->state = QUERY_CREATED;
+    struct wined3d_occlusion_query *oq = query->extendedData;
+    DWORD *data = pData;
 
     if (query->state == QUERY_CREATED)
     {
@@ -312,6 +316,8 @@ static HRESULT wined3d_occlusion_query_ops_get_data(struct wined3d_query *query,
         return S_OK;
     }
 
+    TRACE("(%p) : type D3DQUERY_OCCLUSION, pData %p, dwSize %#x, flags %#x.\n", query, pData, dwSize, flags);
+
     if (query->state == QUERY_BUILDING)
     {
         /* Msdn says this returns an error, but our tests show that S_FALSE is returned */
@@ -326,11 +332,37 @@ static HRESULT wined3d_occlusion_query_ops_get_data(struct wined3d_query *query,
         return S_OK;
     }
 
+    if (!wined3d_settings.cs_multithreaded)
+    {
+        if (!query->query_ops->query_poll(query))
+            return S_FALSE;
+    }
+    else if (query->counter_main != query->counter_retrieved)
+    {
+        return S_FALSE;
+    }
+
+    if (data)
+        *data = oq->samples;
+
+    return S_OK;
+}
+
+static BOOL wined3d_occlusion_query_ops_poll(struct wined3d_query *query)
+{
+    struct wined3d_occlusion_query *oq = query->extendedData;
+    struct wined3d_device *device = query->device;
+    const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
+    struct wined3d_context *context;
+    GLuint available;
+    GLuint samples;
+    BOOL ret;
+
     if (oq->context->tid != GetCurrentThreadId())
     {
         FIXME("%p Wrong thread, returning 1.\n", query);
-        *data = 1;
-        return S_OK;
+        oq->samples = 1;
+        return TRUE;
     }
 
     context = context_acquire(query->device, oq->context->current_rt);
@@ -341,64 +373,78 @@ static HRESULT wined3d_occlusion_query_ops_get_data(struct wined3d_query *query,
 
     if (available)
     {
-        if (data)
-        {
-            GL_EXTCALL(glGetQueryObjectuivARB(oq->id, GL_QUERY_RESULT_ARB, &samples));
-            checkGLcall("glGetQueryObjectuivARB(GL_QUERY_RESULT)");
-            TRACE("Returning %d samples.\n", samples);
-            *data = samples;
-        }
-        res = S_OK;
+        GL_EXTCALL(glGetQueryObjectuivARB(oq->id, GL_QUERY_RESULT_ARB, &samples));
+        checkGLcall("glGetQueryObjectuivARB(GL_QUERY_RESULT)");
+        TRACE("Returning %d samples.\n", samples);
+        oq->samples = samples;
+        ret = TRUE;
     }
     else
     {
-        res = S_FALSE;
+        ret = FALSE;
     }
 
     context_release(context);
 
-    return res;
+    return ret;
 }
 
-static HRESULT wined3d_event_query_ops_get_data(struct wined3d_query *query,
-        void *pData, DWORD dwSize, DWORD flags)
+static BOOL wined3d_event_query_ops_poll(struct wined3d_query *query)
 {
     struct wined3d_event_query *event_query = query->extendedData;
-    BOOL *data = pData;
     enum wined3d_event_query_result ret;
 
-    TRACE("query %p, pData %p, dwSize %#x, flags %#x.\n", query, pData, dwSize, flags);
-
-    if (!pData || !dwSize) return S_OK;
-    if (!event_query)
-    {
-        WARN("Event query not supported by GL, reporting GPU idle.\n");
-        *data = TRUE;
-        return S_OK;
-    }
-
     ret = wined3d_event_query_test(event_query, query->device);
     switch(ret)
     {
         case WINED3D_EVENT_QUERY_OK:
         case WINED3D_EVENT_QUERY_NOT_STARTED:
-            *data = TRUE;
-            break;
+            return TRUE;
 
         case WINED3D_EVENT_QUERY_WAITING:
-            *data = FALSE;
-            break;
+            return FALSE;
 
         case WINED3D_EVENT_QUERY_WRONG_THREAD:
             FIXME("(%p) Wrong thread, reporting GPU idle.\n", query);
-            *data = TRUE;
-            break;
+            return TRUE;
 
         case WINED3D_EVENT_QUERY_ERROR:
             ERR("The GL event query failed, returning D3DERR_INVALIDCALL\n");
-            return WINED3DERR_INVALIDCALL;
+            return TRUE;
+
+        default:
+            ERR("Unexpected wined3d_event_query_test result %u\n", ret);
+            return TRUE;
+    }
+}
+
+static HRESULT wined3d_event_query_ops_get_data(struct wined3d_query *query,
+        void *pData, DWORD dwSize, DWORD flags)
+{
+    struct wined3d_event_query *event_query = query->extendedData;
+    BOOL *data = pData;
+    enum wined3d_event_query_result ret;
+
+    TRACE("query %p, pData %p, dwSize %#x, flags %#x.\n", query, pData, dwSize, flags);
+
+    if (!pData || !dwSize) return S_OK;
+    if (!event_query)
+    {
+        WARN("Event query not supported by GL, reporting GPU idle.\n");
+        *data = TRUE;
+        return S_OK;
     }
 
+    if (!wined3d_settings.cs_multithreaded)
+        ret = query->query_ops->query_poll(query);
+    else if (query->counter_main != query->counter_retrieved)
+        ret = FALSE;
+    else
+        ret = TRUE;
+
+    if (data)
+        *data = ret;
+
     return S_OK;
 }
 
@@ -409,7 +455,7 @@ enum wined3d_query_type CDECL wined3d_query_get_type(const struct wined3d_query
     return query->type;
 }
 
-static HRESULT wined3d_event_query_ops_issue(struct wined3d_query *query, DWORD flags)
+static BOOL wined3d_event_query_ops_issue(struct wined3d_query *query, DWORD flags)
 {
     TRACE("query %p, flags %#x.\n", query, flags);
 
@@ -419,28 +465,24 @@ static HRESULT wined3d_event_query_ops_issue(struct wined3d_query *query, DWORD
         struct wined3d_event_query *event_query = query->extendedData;
 
         /* Faked event query support */
-        if (!event_query) return WINED3D_OK;
+        if (!event_query) return FALSE;
 
         wined3d_event_query_issue(event_query, query->device);
+        return TRUE;
     }
     else if (flags & WINED3DISSUE_BEGIN)
     {
         /* Started implicitly at device creation */
         ERR("Event query issued with START flag - what to do?\n");
     }
-
-    if (flags & WINED3DISSUE_BEGIN)
-        query->state = QUERY_BUILDING;
-    else
-        query->state = QUERY_SIGNALLED;
-
-    return WINED3D_OK;
+    return FALSE;
 }
 
-static HRESULT wined3d_occlusion_query_ops_issue(struct wined3d_query *query, DWORD flags)
+static BOOL wined3d_occlusion_query_ops_issue(struct wined3d_query *query, DWORD flags)
 {
     struct wined3d_device *device = query->device;
     const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
+    BOOL poll = FALSE;
 
     TRACE("query %p, flags %#x.\n", query, flags);
 
@@ -452,7 +494,7 @@ static HRESULT wined3d_occlusion_query_ops_issue(struct wined3d_query *query, DW
         /* This is allowed according to msdn and our tests. Reset the query and restart */
         if (flags & WINED3DISSUE_BEGIN)
         {
-            if (query->state == QUERY_BUILDING)
+            if (oq->started)
             {
                 if (oq->context->tid != GetCurrentThreadId())
                 {
@@ -481,6 +523,7 @@ static HRESULT wined3d_occlusion_query_ops_issue(struct wined3d_query *query, DW
             checkGLcall("glBeginQuery()");
 
             context_release(context);
+            oq->started = TRUE;
         }
         if (flags & WINED3DISSUE_END)
         {
@@ -488,7 +531,7 @@ static HRESULT wined3d_occlusion_query_ops_issue(struct wined3d_query *query, DW
              * our tests show that it returns OK. But OpenGL doesn't like it, so avoid
              * generating an error
              */
-            if (query->state == QUERY_BUILDING)
+            if (oq->started)
             {
                 if (oq->context->tid != GetCurrentThreadId())
                 {
@@ -502,8 +545,10 @@ static HRESULT wined3d_occlusion_query_ops_issue(struct wined3d_query *query, DW
                     checkGLcall("glEndQuery()");
 
                     context_release(context);
+                    poll = TRUE;
                 }
             }
+            oq->started = FALSE;
         }
     }
     else
@@ -511,23 +556,20 @@ static HRESULT wined3d_occlusion_query_ops_issue(struct wined3d_query *query, DW
         FIXME("%p Occlusion queries not supported.\n", query);
     }
 
-    if (flags & WINED3DISSUE_BEGIN)
-        query->state = QUERY_BUILDING;
-    else
-        query->state = QUERY_SIGNALLED;
-
-    return WINED3D_OK; /* can be WINED3DERR_INVALIDCALL.    */
+    return poll;
 }
 
 static const struct wined3d_query_ops event_query_ops =
 {
     wined3d_event_query_ops_get_data,
+    wined3d_event_query_ops_poll,
     wined3d_event_query_ops_issue,
 };
 
 static const struct wined3d_query_ops occlusion_query_ops =
 {
     wined3d_occlusion_query_ops_get_data,
+    wined3d_occlusion_query_ops_poll,
     wined3d_occlusion_query_ops_issue,
 };
 
@@ -546,13 +588,13 @@ static HRESULT query_init(struct wined3d_query *query, struct wined3d_device *de
             }
             query->query_ops = &occlusion_query_ops;
             query->data_size = sizeof(DWORD);
-            query->extendedData = HeapAlloc(GetProcessHeap(), 0, sizeof(struct wined3d_occlusion_query));
+            query->extendedData = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
+                    sizeof(struct wined3d_occlusion_query));
             if (!query->extendedData)
             {
                 ERR("Failed to allocate occlusion query extended data.\n");
                 return E_OUTOFMEMORY;
             }
-            ((struct wined3d_occlusion_query *)query->extendedData)->context = NULL;
             break;
 
         case WINED3D_QUERY_TYPE_EVENT:
@@ -596,6 +638,7 @@ static HRESULT query_init(struct wined3d_query *query, struct wined3d_device *de
     query->state = QUERY_CREATED;
     query->device = device;
     query->ref = 1;
+    list_init(&query->poll_list_entry);
 
     return WINED3D_OK;
 }
diff --git a/dlls/wined3d/resource.c b/dlls/wined3d/resource.c
index 43bd7ce..dfe977e 100644
--- a/dlls/wined3d/resource.c
+++ b/dlls/wined3d/resource.c
@@ -100,7 +100,6 @@ HRESULT resource_init(struct wined3d_resource *resource, struct wined3d_device *
     resource->parent = parent;
     resource->parent_ops = parent_ops;
     resource->resource_ops = resource_ops;
-    wined3d_private_store_init(&resource->private_store);
 
     if (size)
     {
@@ -109,6 +108,7 @@ HRESULT resource_init(struct wined3d_resource *resource, struct wined3d_device *
             ERR("Failed to allocate system memory.\n");
             return E_OUTOFMEMORY;
         }
+        resource->heap_memory = resource->map_heap_memory;
     }
     else
     {
@@ -132,6 +132,29 @@ HRESULT resource_init(struct wined3d_resource *resource, struct wined3d_device *
     return WINED3D_OK;
 }
 
+void wined3d_resource_free_bo(struct wined3d_resource *resource)
+{
+    struct wined3d_context *context = context_acquire(resource->device, NULL);
+
+    if (resource->buffer != resource->map_buffer)
+        ERR("Releasing resource buffer with buffer != map_buffer.\n");
+
+    wined3d_device_release_bo(resource->device, resource->buffer, context);
+    resource->buffer = NULL;
+    resource->map_buffer = NULL;
+
+    context_release(context);
+}
+
+void wined3d_resource_cleanup_cs(struct wined3d_resource *resource)
+{
+    if (resource->buffer)
+        wined3d_resource_free_bo(resource);
+
+    wined3d_resource_free_sysmem(resource);
+    resource->map_heap_memory = NULL;
+}
+
 void resource_cleanup(struct wined3d_resource *resource)
 {
     const struct wined3d *d3d = resource->device->wined3d;
@@ -144,9 +167,7 @@ void resource_cleanup(struct wined3d_resource *resource)
         adapter_adjust_memory(resource->device->adapter, 0 - resource->size);
     }
 
-    wined3d_private_store_cleanup(&resource->private_store);
-
-    wined3d_resource_free_sysmem(resource);
+    wined3d_cs_emit_resource_cleanup(resource->device->cs, resource);
 
     device_resource_released(resource->device, resource);
 }
@@ -156,65 +177,13 @@ void resource_unload(struct wined3d_resource *resource)
     if (resource->map_count)
         ERR("Resource %p is being unloaded while mapped.\n", resource);
 
+    if (resource->buffer)
+        wined3d_resource_free_bo(resource);
+
     context_resource_unloaded(resource->device,
             resource, resource->type);
 }
 
-HRESULT CDECL wined3d_resource_set_private_data(struct wined3d_resource *resource, REFGUID guid,
-        const void *data, DWORD data_size, DWORD flags)
-{
-    TRACE("resource %p, riid %s, data %p, data_size %u, flags %#x.\n",
-            resource, debugstr_guid(guid), data, data_size, flags);
-
-    return wined3d_private_store_set_private_data(&resource->private_store, guid, data, data_size, flags);
-}
-
-HRESULT CDECL wined3d_resource_get_private_data(const struct wined3d_resource *resource, REFGUID guid,
-        void *data, DWORD *data_size)
-{
-    const struct wined3d_private_data *d;
-    DWORD size_in;
-
-    TRACE("resource %p, guid %s, data %p, data_size %p.\n",
-            resource, debugstr_guid(guid), data, data_size);
-
-    d = wined3d_private_store_get_private_data(&resource->private_store, guid);
-    if (!d)
-        return WINED3DERR_NOTFOUND;
-
-    size_in = *data_size;
-    *data_size = d->size;
-    if (!data)
-        return WINED3D_OK;
-    if (size_in < d->size)
-        return WINED3DERR_MOREDATA;
-
-    if (d->flags & WINED3DSPD_IUNKNOWN)
-    {
-        *(IUnknown **)data = d->content.object;
-        IUnknown_AddRef(d->content.object);
-    }
-    else
-    {
-        memcpy(data, d->content.data, d->size);
-    }
-
-    return WINED3D_OK;
-}
-
-HRESULT CDECL wined3d_resource_free_private_data(struct wined3d_resource *resource, REFGUID guid)
-{
-    struct wined3d_private_data *entry;
-    TRACE("resource %p, guid %s.\n", resource, debugstr_guid(guid));
-
-    entry = wined3d_private_store_get_private_data(&resource->private_store, guid);
-    if (!entry)
-        return WINED3DERR_NOTFOUND;
-    wined3d_private_store_free_private_data(&resource->private_store, entry);
-
-    return WINED3D_OK;
-}
-
 DWORD resource_set_priority(struct wined3d_resource *resource, DWORD priority)
 {
     DWORD prev = resource->priority;
@@ -253,6 +222,21 @@ void CDECL wined3d_resource_get_desc(const struct wined3d_resource *resource, st
     desc->size = resource->size;
 }
 
+void *wined3d_resource_allocate_sysmem2(struct wined3d_resource *resource)
+{
+    void **p;
+    SIZE_T align = RESOURCE_ALIGNMENT - 1 + sizeof(*p);
+    void *mem;
+
+    if (!(mem = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, resource->size + align)))
+        return FALSE;
+
+    p = (void **)(((ULONG_PTR)mem + align) & ~(RESOURCE_ALIGNMENT - 1)) - 1;
+    *p = mem;
+
+    return ++p;
+}
+
 BOOL wined3d_resource_allocate_sysmem(struct wined3d_resource *resource)
 {
     void **p;
@@ -265,7 +249,7 @@ BOOL wined3d_resource_allocate_sysmem(struct wined3d_resource *resource)
     p = (void **)(((ULONG_PTR)mem + align) & ~(RESOURCE_ALIGNMENT - 1)) - 1;
     *p = mem;
 
-    resource->heap_memory = ++p;
+    resource->map_heap_memory = ++p;
 
     return TRUE;
 }
@@ -331,7 +315,7 @@ GLbitfield wined3d_resource_gl_map_flags(DWORD d3d_flags)
     return ret;
 }
 
-GLenum wined3d_resource_gl_legacy_map_flags(DWORD d3d_flags)
+static GLenum wined3d_resource_gl_legacy_map_flags(DWORD d3d_flags)
 {
     if (d3d_flags & WINED3D_MAP_READONLY)
         return GL_READ_ONLY_ARB;
@@ -339,3 +323,563 @@ GLenum wined3d_resource_gl_legacy_map_flags(DWORD d3d_flags)
         return GL_WRITE_ONLY_ARB;
     return GL_READ_WRITE_ARB;
 }
+
+void wined3d_resource_validate_location(struct wined3d_resource *resource, DWORD location)
+{
+    TRACE("Resource %p, setting %s.\n", resource, wined3d_debug_location(location));
+    resource->locations |= location;
+    TRACE("new location flags are %s.\n", wined3d_debug_location(resource->locations));
+}
+
+void wined3d_resource_invalidate_location(struct wined3d_resource *resource, DWORD location)
+{
+    TRACE("Resource %p, setting %s.\n", resource, wined3d_debug_location(location));
+    resource->locations &= ~location;
+    TRACE("new location flags are %s.\n", wined3d_debug_location(resource->locations));
+
+    resource->resource_ops->resource_location_invalidated(resource, location);
+}
+
+DWORD wined3d_resource_access_from_location(DWORD location)
+{
+    switch (location)
+    {
+        case WINED3D_LOCATION_DISCARDED:
+            return 0;
+
+        case WINED3D_LOCATION_SYSMEM:
+        case WINED3D_LOCATION_USER_MEMORY:
+        case WINED3D_LOCATION_DIB:
+            return WINED3D_RESOURCE_ACCESS_CPU;
+
+        case WINED3D_LOCATION_BUFFER:
+        case WINED3D_LOCATION_TEXTURE_RGB:
+        case WINED3D_LOCATION_TEXTURE_SRGB:
+        case WINED3D_LOCATION_DRAWABLE:
+        case WINED3D_LOCATION_RB_MULTISAMPLE:
+        case WINED3D_LOCATION_RB_RESOLVED:
+            return WINED3D_RESOURCE_ACCESS_GPU;
+
+        default:
+            FIXME("Unhandled location %#x.\n", location);
+            return 0;
+    }
+}
+
+void wined3d_resource_get_memory(const struct wined3d_resource *resource,
+        DWORD location, struct wined3d_bo_address *data)
+{
+    if (location & WINED3D_LOCATION_BUFFER)
+    {
+        data->buffer_object = resource->buffer->name;
+        data->addr = NULL;
+        return;
+    }
+    if (location & WINED3D_LOCATION_USER_MEMORY)
+    {
+        data->buffer_object = 0;
+        data->addr = resource->user_memory;
+        return;
+    }
+    if (location & WINED3D_LOCATION_DIB)
+    {
+        data->buffer_object = 0;
+        data->addr = resource->bitmap_data;
+        return;
+    }
+    if (location & WINED3D_LOCATION_SYSMEM)
+    {
+        data->buffer_object = 0;
+        data->addr = resource->heap_memory;
+        return;
+    }
+    ERR("Unexpected location %s.\n", wined3d_debug_location(location));
+}
+
+/* Context activation is optionally by the caller. Context may be NULL. */
+static void wined3d_resource_copy_simple_location(struct wined3d_resource *resource,
+        struct wined3d_context *context, DWORD location)
+{
+    const struct wined3d_gl_info *gl_info;
+    struct wined3d_bo_address dst, src;
+    UINT size = resource->size;
+
+    wined3d_resource_get_memory(resource, location, &dst);
+    wined3d_resource_get_memory(resource, resource->locations, &src);
+
+    if (dst.buffer_object)
+    {
+        gl_info = context->gl_info;
+        GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, dst.buffer_object));
+        GL_EXTCALL(glBufferSubDataARB(GL_PIXEL_UNPACK_BUFFER_ARB, 0, size, src.addr));
+        GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, 0));
+        checkGLcall("Upload PBO");
+        return;
+    }
+    if (src.buffer_object)
+    {
+        gl_info = context->gl_info;
+        GL_EXTCALL(glBindBufferARB(GL_PIXEL_PACK_BUFFER_ARB, src.buffer_object));
+        GL_EXTCALL(glGetBufferSubDataARB(GL_PIXEL_PACK_BUFFER_ARB, 0, size, dst.addr));
+        GL_EXTCALL(glBindBufferARB(GL_PIXEL_PACK_BUFFER_ARB, 0));
+        checkGLcall("Download PBO");
+        return;
+    }
+    memcpy(dst.addr, src.addr, size);
+}
+
+/* Context activation is optionally by the caller. Context may be NULL. */
+void wined3d_resource_load_location(struct wined3d_resource *resource,
+        struct wined3d_context *context, DWORD location)
+{
+    DWORD required_access = wined3d_resource_access_from_location(location);
+    DWORD simple_locations = WINED3D_LOCATION_SYSMEM | WINED3D_LOCATION_USER_MEMORY
+            | WINED3D_LOCATION_DIB | WINED3D_LOCATION_BUFFER;
+
+    if ((resource->locations & location) == location)
+    {
+        TRACE("Location(s) already up to date.\n");
+        return;
+    }
+
+    /* Keep this a WARN for now until surfaces are cleaned up. */
+    if ((resource->access_flags & required_access) != required_access)
+        WARN("Operation requires %#x access, but resource only has %#x.\n",
+                required_access, resource->access_flags);
+
+    if (location & simple_locations)
+    {
+        if (resource->locations & WINED3D_LOCATION_DISCARDED)
+        {
+            TRACE("Resource was discarded, nothing to do.\n");
+            resource->locations |= location;
+            return;
+        }
+        if (resource->locations & simple_locations)
+        {
+            wined3d_resource_copy_simple_location(resource, context, location);
+            resource->locations |= location;
+            return;
+        }
+    }
+
+    /* Context is NULL in ddraw-only operation without OpenGL. */
+    if (!context)
+        ERR("A context is required for non-sysmem operation.\n");
+
+    resource->resource_ops->resource_load_location(resource, context, location);
+}
+
+BYTE *wined3d_resource_get_map_ptr(const struct wined3d_resource *resource,
+        const struct wined3d_context *context, DWORD flags)
+{
+    const struct wined3d_gl_info *gl_info;
+    BYTE *ptr;
+
+    switch (resource->map_binding)
+    {
+        case WINED3D_LOCATION_SYSMEM:
+            return resource->map_heap_memory;
+
+        case WINED3D_LOCATION_USER_MEMORY:
+            return resource->user_memory;
+
+        case WINED3D_LOCATION_DIB:
+            return resource->bitmap_data;
+
+        case WINED3D_LOCATION_BUFFER:
+            gl_info = context->gl_info;
+            GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, resource->map_buffer->name));
+
+            if (gl_info->supported[ARB_MAP_BUFFER_RANGE])
+            {
+                GLbitfield mapflags = wined3d_resource_gl_map_flags(flags);
+                mapflags &= ~GL_MAP_FLUSH_EXPLICIT_BIT;
+                ptr = GL_EXTCALL(glMapBufferRange(GL_PIXEL_UNPACK_BUFFER_ARB,
+                        0, resource->size, mapflags));
+            }
+            else
+            {
+                GLenum access = wined3d_resource_gl_legacy_map_flags(flags);
+                ptr = GL_EXTCALL(glMapBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, access));
+            }
+
+            GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, 0));
+            checkGLcall("Map GL buffer");
+            return ptr;
+
+        default:
+            ERR("Unexpected map binding %s.\n", wined3d_debug_location(resource->map_binding));
+            return NULL;
+    }
+}
+
+void wined3d_resource_release_map_ptr(const struct wined3d_resource *resource,
+        const struct wined3d_context *context)
+{
+    const struct wined3d_gl_info *gl_info;
+
+    switch (resource->map_binding)
+    {
+        case WINED3D_LOCATION_BUFFER:
+            gl_info = context->gl_info;
+            GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, resource->map_buffer->name));
+            GL_EXTCALL(glUnmapBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB));
+            GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, 0));
+            checkGLcall("Unmap GL buffer");
+            return;
+
+        case WINED3D_LOCATION_SYSMEM:
+        case WINED3D_LOCATION_DIB:
+        case WINED3D_LOCATION_USER_MEMORY:
+            return;
+
+        default:
+            ERR("Unexpected map binding %s.\n", wined3d_debug_location(resource->map_binding));
+            return;
+    }
+}
+
+/* Context activation is done by the caller. */
+static void wined3d_resource_prepare_bo(struct wined3d_resource *resource, struct wined3d_context *context)
+{
+    if (resource->buffer)
+        return;
+
+    resource->buffer = wined3d_device_get_bo(resource->device, resource->size,
+            GL_STREAM_DRAW_ARB, GL_PIXEL_UNPACK_BUFFER_ARB, context);
+    resource->map_buffer = resource->buffer;
+    TRACE("Created GL buffer %u for resource %p.\n", resource->buffer->name, resource);
+}
+
+BOOL wined3d_resource_prepare_system_memory(struct wined3d_resource *resource)
+{
+    if (resource->heap_memory)
+        return TRUE;
+
+    if (!wined3d_resource_allocate_sysmem(resource))
+    {
+        ERR("Failed to allocate system memory.\n");
+        return FALSE;
+    }
+    resource->heap_memory = resource->map_heap_memory;
+    return TRUE;
+}
+
+/* Context activation is done by the caller. */
+BOOL wined3d_resource_prepare_map_memory(struct wined3d_resource *resource, struct wined3d_context *context)
+{
+    switch (resource->map_binding)
+    {
+        case WINED3D_LOCATION_BUFFER:
+            wined3d_resource_prepare_bo(resource, context);
+            return TRUE;
+
+        case WINED3D_LOCATION_SYSMEM:
+            return wined3d_resource_prepare_system_memory(resource);
+
+        case WINED3D_LOCATION_USER_MEMORY:
+            if (!resource->user_memory)
+                ERR("Map binding is set to WINED3D_LOCATION_USER_MEMORY but resource->user_memory is NULL.\n");
+            return TRUE;
+
+        case WINED3D_LOCATION_DIB:
+            if (!resource->bitmap_data)
+                ERR("Map binding is set to WINED3D_LOCATION_DIB but resource->bitmap_data is NULL.\n");
+            return TRUE;
+
+        default:
+            ERR("Unexpected map binding %s.\n", wined3d_debug_location(resource->map_binding));
+            return FALSE;
+    }
+}
+
+void CDECL wined3d_resource_get_pitch(const struct wined3d_resource *resource, UINT *row_pitch,
+        UINT *slice_pitch)
+{
+    const struct wined3d_format *format = resource->format;
+
+    if (resource->custom_row_pitch)
+    {
+        *row_pitch = resource->custom_row_pitch;
+        *slice_pitch = resource->custom_slice_pitch;
+        return;
+    }
+
+    if (format->flags & WINED3DFMT_FLAG_BLOCKS)
+    {
+        /* Since compressed formats are block based, pitch means the amount of
+         * bytes to the next row of block rather than the next row of pixels. */
+        UINT row_block_count = (resource->width + format->block_width - 1) / format->block_width;
+        UINT slice_block_count = (resource->height + format->block_height - 1) / format->block_height;
+        *row_pitch = row_block_count * format->block_byte_count;
+        *slice_pitch = *row_pitch * slice_block_count;
+    }
+    else
+    {
+        unsigned char alignment = resource->device->surface_alignment;
+        *row_pitch = format->byte_count * resource->width;  /* Bytes / row */
+        *row_pitch = (*row_pitch + alignment - 1) & ~(alignment - 1);
+        *slice_pitch = *row_pitch * resource->height;
+    }
+
+    TRACE("Returning row pitch %u, slice pitch %u.\n", *row_pitch, *slice_pitch);
+}
+
+BOOL wined3d_resource_check_block_align(const struct wined3d_resource *resource,
+        const struct wined3d_box *box)
+{
+    UINT width_mask, height_mask;
+    const struct wined3d_format *format = resource->format;
+
+    if (!box)
+        return TRUE;
+
+    /* This assumes power of two block sizes, but NPOT block sizes would be
+     * silly anyway.
+     *
+     * This also assumes that the format's block depth is 1. */
+    width_mask = format->block_width - 1;
+    height_mask = format->block_height - 1;
+
+    if (box->left & width_mask)
+        return FALSE;
+    if (box->top & height_mask)
+        return FALSE;
+    if (box->right & width_mask && box->right != resource->width)
+        return FALSE;
+    if (box->bottom & height_mask && box->bottom != resource->height)
+        return FALSE;
+
+    return TRUE;
+}
+
+void *wined3d_resource_map_internal(struct wined3d_resource *resource, DWORD flags)
+{
+    struct wined3d_device *device = resource->device;
+    struct wined3d_context *context = NULL;
+    void *mem;
+
+    if (device->d3d_initialized)
+        context = context_acquire(device, NULL);
+
+    if (!wined3d_resource_prepare_map_memory(resource, context))
+    {
+        WARN("Out of memory.\n");
+        context_release(context);
+        return NULL;
+    }
+
+    if (flags & WINED3D_MAP_DISCARD)
+    {
+        switch (resource->map_binding)
+        {
+            case WINED3D_LOCATION_BUFFER:
+                resource->map_buffer = wined3d_device_get_bo(device, resource->size,
+                        GL_STREAM_DRAW_ARB, GL_PIXEL_UNPACK_BUFFER_ARB, context);
+                break;
+
+            case WINED3D_LOCATION_SYSMEM:
+                wined3d_resource_allocate_sysmem(resource);
+                break;
+
+            default:
+                if (resource->access_fence)
+                    ERR("Location %s does not support DISCARD maps.\n", 
+                            wined3d_debug_location(resource->map_binding));
+                if (resource->pool != WINED3D_POOL_DEFAULT)
+                    FIXME("Discard used on %s pool resource.\n", debug_d3dpool(resource->pool));
+        }
+        wined3d_resource_validate_location(resource, resource->map_binding);
+    }
+    else
+    {
+        wined3d_resource_load_location(resource, context, resource->map_binding);
+    }
+
+    mem = wined3d_resource_get_map_ptr(resource, context, flags);
+
+    if (context)
+        context_release(context);
+
+    return mem;
+}
+
+static void wined3d_resource_sync(struct wined3d_resource *resource)
+{
+    struct wined3d_resource *real_res = resource;
+    struct wined3d_surface *surface;
+    struct wined3d_volume *volume;
+
+    switch (resource->type)
+    {
+        case WINED3D_RTYPE_SURFACE:
+            surface = surface_from_resource(resource);
+            if (surface->container)
+                real_res = &surface->container->resource;
+            break;
+
+        case WINED3D_RTYPE_VOLUME:
+            volume = volume_from_resource(resource);
+            real_res = &volume->container->resource;
+            break;
+
+        default:
+            break;
+    }
+    wined3d_resource_wait_fence(real_res);
+}
+
+HRESULT wined3d_resource_map(struct wined3d_resource *resource,
+        struct wined3d_map_desc *map_desc, const struct wined3d_box *box, DWORD flags)
+{
+    struct wined3d_device *device = resource->device;
+    BYTE *base_memory;
+    const struct wined3d_format *format = resource->format;
+
+    TRACE("resource %p, map_desc %p, box %p, flags %#x.\n",
+            resource, map_desc, box, flags);
+
+    if (resource->map_count)
+    {
+        WARN("Volume is already mapped.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    flags = wined3d_resource_sanitize_map_flags(resource, flags);
+
+    if (flags & WINED3D_MAP_NOOVERWRITE)
+        FIXME("WINED3D_MAP_NOOVERWRITE are not implemented yet.\n");
+
+    if (flags & WINED3D_MAP_DISCARD)
+    {
+        switch (resource->map_binding)
+        {
+            case WINED3D_LOCATION_BUFFER:
+            case WINED3D_LOCATION_SYSMEM:
+                break;
+
+            default:
+                FIXME("Implement discard maps with %s map binding.\n",
+                        wined3d_debug_location(resource->map_binding));
+                wined3d_resource_sync(resource);
+        }
+    }
+    else
+        wined3d_resource_sync(resource);
+
+    base_memory = wined3d_cs_emit_resource_map(device->cs, resource, flags);
+    if (!base_memory)
+    {
+        WARN("Map failed.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    TRACE("Base memory pointer %p.\n", base_memory);
+
+    if (format->flags & WINED3DFMT_FLAG_BROKEN_PITCH)
+    {
+        map_desc->row_pitch = resource->width * format->byte_count;
+        map_desc->slice_pitch = map_desc->row_pitch * resource->height;
+    }
+    else
+    {
+        wined3d_resource_get_pitch(resource, &map_desc->row_pitch, &map_desc->slice_pitch);
+    }
+
+    if (!box)
+    {
+        TRACE("No box supplied - all is ok\n");
+        map_desc->data = base_memory;
+    }
+    else
+    {
+        TRACE("Lock Box (%p) = l %u, t %u, r %u, b %u, fr %u, ba %u\n",
+                box, box->left, box->top, box->right, box->bottom, box->front, box->back);
+
+        if ((format->flags & (WINED3DFMT_FLAG_BLOCKS | WINED3DFMT_FLAG_BROKEN_PITCH)) == WINED3DFMT_FLAG_BLOCKS)
+        {
+            /* Compressed textures are block based, so calculate the offset of
+             * the block that contains the top-left pixel of the locked rectangle. */
+            map_desc->data = base_memory
+                    + (box->front * map_desc->slice_pitch)
+                    + ((box->top / format->block_height) * map_desc->row_pitch)
+                    + ((box->left / format->block_width) * format->block_byte_count);
+        }
+        else
+        {
+            map_desc->data = base_memory
+                    + (map_desc->slice_pitch * box->front)
+                    + (map_desc->row_pitch * box->top)
+                    + (box->left * format->byte_count);
+        }
+    }
+
+    if (!(flags & WINED3D_MAP_READONLY))
+        resource->unmap_dirtify = TRUE;
+
+    resource->map_count++;
+
+    TRACE("Returning memory %p, row pitch %d, slice pitch %d.\n",
+            map_desc->data, map_desc->row_pitch, map_desc->slice_pitch);
+
+    return WINED3D_OK;
+}
+
+void wined3d_resource_unmap_internal(struct wined3d_resource *resource)
+{
+    struct wined3d_device *device = resource->device;
+    struct wined3d_context *context = NULL;
+
+    if (device->d3d_initialized)
+        context = context_acquire(device, NULL);
+    wined3d_resource_release_map_ptr(resource, context);
+    if (context)
+        context_release(context);
+}
+
+HRESULT wined3d_resource_unmap(struct wined3d_resource *resource)
+{
+    struct wined3d_device *device = resource->device;
+    TRACE("resource %p.\n", resource);
+
+    if (!resource->map_count)
+    {
+        WARN("Trying to unlock an unlocked resource %p.\n", resource);
+        return WINEDDERR_NOTLOCKED;
+    }
+
+    wined3d_cs_emit_resource_unmap(device->cs, resource);
+
+    if (resource->unmap_dirtify)
+    {
+        wined3d_cs_emit_resource_changed(device->cs, resource,
+                resource->map_buffer, resource->map_heap_memory);
+    }
+    resource->unmap_dirtify = FALSE;
+
+    resource->map_count--;
+
+    return WINED3D_OK;
+}
+
+void wined3d_resource_changed(struct wined3d_resource *resource, struct wined3d_gl_bo *swap_buffer,
+        void *swap_heap_memory)
+{
+    struct wined3d_device *device = resource->device;
+
+    if (swap_buffer && swap_buffer != resource->buffer)
+    {
+        struct wined3d_context *context = context_acquire(device, NULL);
+        wined3d_device_release_bo(device, resource->buffer, context);
+        context_release(context);
+        resource->buffer = swap_buffer;
+    }
+    if (swap_heap_memory && swap_heap_memory != resource->heap_memory)
+    {
+        wined3d_resource_free_sysmem(resource);
+        resource->heap_memory = swap_heap_memory;
+    }
+
+    wined3d_resource_invalidate_location(resource, ~resource->map_binding);
+}
diff --git a/dlls/wined3d/shader.c b/dlls/wined3d/shader.c
index 3a1fc12..e3093eb 100644
--- a/dlls/wined3d/shader.c
+++ b/dlls/wined3d/shader.c
@@ -1486,7 +1486,7 @@ static void shader_trace_init(const struct wined3d_shader_frontend *fe, void *fe
     }
 }
 
-static void shader_cleanup(struct wined3d_shader *shader)
+void shader_cleanup(struct wined3d_shader *shader)
 {
     shader->device->shader_backend->shader_destroy(shader);
     HeapFree(GetProcessHeap(), 0, shader->reg_maps.constf);
@@ -1740,9 +1740,10 @@ ULONG CDECL wined3d_shader_decref(struct wined3d_shader *shader)
 
     if (!refcount)
     {
-        shader_cleanup(shader);
+        const struct wined3d_device *device = shader->device;
+
         shader->parent_ops->wined3d_object_destroyed(shader->parent);
-        HeapFree(GetProcessHeap(), 0, shader);
+        wined3d_cs_emit_shader_cleanup(device->cs, shader);
     }
 
     return refcount;
@@ -2034,7 +2035,7 @@ void find_ps_compile_args(const struct wined3d_state *state, const struct wined3
     memset(args, 0, sizeof(*args)); /* FIXME: Make sure all bits are set. */
     if (!gl_info->supported[ARB_FRAMEBUFFER_SRGB] && state->render_states[WINED3D_RS_SRGBWRITEENABLE])
     {
-        const struct wined3d_surface *rt = state->fb->render_targets[0];
+        const struct wined3d_surface *rt = state->fb.render_targets[0];
         if (rt->resource.format->flags & WINED3DFMT_FLAG_SRGB_WRITE)
         {
             static unsigned int warned = 0;
diff --git a/dlls/wined3d/state.c b/dlls/wined3d/state.c
index f450f20..1c1adf2 100644
--- a/dlls/wined3d/state.c
+++ b/dlls/wined3d/state.c
@@ -106,7 +106,7 @@ static void state_zenable(struct wined3d_context *context, const struct wined3d_
     static UINT once;
 
     /* No z test without depth stencil buffers */
-    if (!state->fb->depth_stencil)
+    if (!state->fb.depth_stencil)
     {
         TRACE("No Z buffer - disabling depth test\n");
         zenable = WINED3D_ZB_FALSE;
@@ -381,7 +381,7 @@ static GLenum gl_blend_factor(enum wined3d_blend factor, const struct wined3d_fo
 
 static void state_blend(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
 {
-    const struct wined3d_surface *target = state->fb->render_targets[0];
+    const struct wined3d_surface *target = state->fb.render_targets[0];
     const struct wined3d_gl_info *gl_info = context->gl_info;
     GLenum srcBlend, dstBlend;
     enum wined3d_blend d3d_blend;
@@ -829,7 +829,7 @@ static void state_stencil(struct wined3d_context *context, const struct wined3d_
     GLint depthFail_ccw;
 
     /* No stencil test without a stencil buffer. */
-    if (!state->fb->depth_stencil)
+    if (!state->fb.depth_stencil)
     {
         gl_info->gl_ops.gl.p_glDisable(GL_STENCIL_TEST);
         checkGLcall("glDisable GL_STENCIL_TEST");
@@ -915,7 +915,7 @@ static void state_stencil(struct wined3d_context *context, const struct wined3d_
 
 static void state_stencilwrite2s(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
 {
-    DWORD mask = state->fb->depth_stencil ? state->render_states[WINED3D_RS_STENCILWRITEMASK] : 0;
+    DWORD mask = state->fb.depth_stencil ? state->render_states[WINED3D_RS_STENCILWRITEMASK] : 0;
     const struct wined3d_gl_info *gl_info = context->gl_info;
 
     GL_EXTCALL(glActiveStencilFaceEXT(GL_BACK));
@@ -929,7 +929,7 @@ static void state_stencilwrite2s(struct wined3d_context *context, const struct w
 
 static void state_stencilwrite(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
 {
-    DWORD mask = state->fb->depth_stencil ? state->render_states[WINED3D_RS_STENCILWRITEMASK] : 0;
+    DWORD mask = state->fb.depth_stencil ? state->render_states[WINED3D_RS_STENCILWRITEMASK] : 0;
     const struct wined3d_gl_info *gl_info = context->gl_info;
 
     gl_info->gl_ops.gl.p_glStencilMask(mask);
@@ -1171,7 +1171,7 @@ void state_fog_fragpart(struct wined3d_context *context, const struct wined3d_st
 
                 case WINED3D_FOG_NONE:
                     /* Both are none? According to msdn the alpha channel of the specular
-                     * color contains a fog factor. Set it in drawStridedSlow.
+                     * color contains a fog factor. Set it in draw_strided_slow.
                      * Same happens with Vertexfog on transformed vertices
                      */
                     new_source = FOGSOURCE_COORD;
@@ -1768,7 +1768,7 @@ static void state_depthbias(struct wined3d_context *context, const struct wined3
     if (state->render_states[WINED3D_RS_SLOPESCALEDEPTHBIAS]
             || state->render_states[WINED3D_RS_DEPTHBIAS])
     {
-        const struct wined3d_surface *depth = state->fb->depth_stencil;
+        const struct wined3d_surface *depth = state->fb.depth_stencil;
         float scale;
 
         union
@@ -4280,7 +4280,7 @@ static void load_vertex_data(struct wined3d_context *context,
                 }
             }
         } else {
-            /* TODO: support blends in drawStridedSlow
+            /* TODO: support blends in draw_strided_slow
              * No need to write a FIXME here, this is done after the general vertex decl decoding
              */
             WARN("unsupported blending in openGl\n");
@@ -4637,7 +4637,7 @@ void vertexdeclaration(struct wined3d_context *context, const struct wined3d_sta
 
 static void viewport_miscpart(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
 {
-    const struct wined3d_surface *target = state->fb->render_targets[0];
+    const struct wined3d_surface *target = state->fb.render_targets[0];
     const struct wined3d_gl_info *gl_info = context->gl_info;
     struct wined3d_viewport vp = state->viewport;
 
@@ -4817,7 +4817,7 @@ static void scissorrect(struct wined3d_context *context, const struct wined3d_st
     }
     else
     {
-        const struct wined3d_surface *target = state->fb->render_targets[0];
+        const struct wined3d_surface *target = state->fb.render_targets[0];
         UINT height;
         UINT width;
 
@@ -4885,7 +4885,7 @@ static void psorigin(struct wined3d_context *context, const struct wined3d_state
 void state_srgbwrite(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
 {
     const struct wined3d_gl_info *gl_info = context->gl_info;
-    const struct wined3d_surface *rt = state->fb->render_targets[0];
+    const struct wined3d_surface *rt = state->fb.render_targets[0];
 
     TRACE("context %p, state %p, state_id %#x.\n", context, state, state_id);
 
diff --git a/dlls/wined3d/stateblock.c b/dlls/wined3d/stateblock.c
index f991362..87e6e88 100644
--- a/dlls/wined3d/stateblock.c
+++ b/dlls/wined3d/stateblock.c
@@ -463,6 +463,7 @@ void state_unbind_resources(struct wined3d_state *state)
     struct wined3d_texture *texture;
     struct wined3d_buffer *buffer;
     struct wined3d_shader *shader;
+    struct wined3d_surface *surface;
     unsigned int i, j;
 
     if ((decl = state->vertex_declaration))
@@ -530,6 +531,31 @@ void state_unbind_resources(struct wined3d_state *state)
             }
         }
     }
+
+    if (state->fb.depth_stencil)
+    {
+        surface = state->fb.depth_stencil;
+
+        TRACE("Releasing depth/stencil buffer %p.\n", surface);
+
+        state->fb.depth_stencil = NULL;
+        wined3d_surface_decref(surface);
+    }
+
+    if (state->fb.render_targets)
+    {
+        for (i = 0; i < state->fb.rt_size; i++)
+        {
+            surface = state->fb.render_targets[i];
+            TRACE("Setting rendertarget %u to NULL\n", i);
+            state->fb.render_targets[i] = NULL;
+            if (surface)
+            {
+                TRACE("Releasing the render target at %p\n", surface);
+                wined3d_surface_decref(surface);
+            }
+        }
+    }
 }
 
 void state_cleanup(struct wined3d_state *state)
@@ -552,6 +578,7 @@ void state_cleanup(struct wined3d_state *state)
 
     HeapFree(GetProcessHeap(), 0, state->vs_consts_f);
     HeapFree(GetProcessHeap(), 0, state->ps_consts_f);
+    HeapFree(GetProcessHeap(), 0, state->fb.render_targets);
 }
 
 ULONG CDECL wined3d_stateblock_decref(struct wined3d_stateblock *stateblock)
@@ -1033,8 +1060,8 @@ void CDECL wined3d_stateblock_apply(const struct wined3d_stateblock *stateblock)
         gl_primitive_type = stateblock->state.gl_primitive_type;
         prev = device->update_state->gl_primitive_type;
         device->update_state->gl_primitive_type = gl_primitive_type;
-        if (gl_primitive_type != prev && (gl_primitive_type == GL_POINTS || prev == GL_POINTS))
-            device_invalidate_state(device, STATE_POINT_SIZE_ENABLE);
+        if (gl_primitive_type != prev)
+            wined3d_cs_emit_set_primitive_type(device->cs, gl_primitive_type);
     }
 
     if (stateblock->changed.indices)
@@ -1295,17 +1322,23 @@ static void state_init_default(struct wined3d_state *state, const struct wined3d
         state->sampler_states[i][WINED3D_SAMP_ELEMENT_INDEX] = 0;
         /* TODO: Vertex offset in the presampled displacement map. */
         state->sampler_states[i][WINED3D_SAMP_DMAP_OFFSET] = 0;
+        state->textures[i] = NULL;
     }
+
+    state->index_buffer = NULL;
+    for (i = 0; i < sizeof(state->streams) / sizeof(*state->streams); i++)
+        memset(&state->streams[i], 0, sizeof(state->streams[i]));
+
+    state->shader[WINED3D_SHADER_TYPE_VERTEX] = NULL;
+    state->shader[WINED3D_SHADER_TYPE_PIXEL] = NULL;
 }
 
-HRESULT state_init(struct wined3d_state *state, struct wined3d_fb_state *fb,
-        const struct wined3d_gl_info *gl_info, const struct wined3d_d3d_info *d3d_info,
-        DWORD flags)
+HRESULT state_init(struct wined3d_state *state, const struct wined3d_gl_info *gl_info,
+        const struct wined3d_d3d_info *d3d_info, DWORD flags)
 {
     unsigned int i;
 
     state->flags = flags;
-    state->fb = fb;
 
     for (i = 0; i < LIGHTMAP_SIZE; i++)
     {
@@ -1323,6 +1356,15 @@ HRESULT state_init(struct wined3d_state *state, struct wined3d_fb_state *fb,
         return E_OUTOFMEMORY;
     }
 
+    if (!(state->fb.render_targets = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
+            sizeof(*state->fb.render_targets) * gl_info->limits.buffers)))
+    {
+        HeapFree(GetProcessHeap(), 0, state->ps_consts_f);
+        HeapFree(GetProcessHeap(), 0, state->vs_consts_f);
+        return E_OUTOFMEMORY;
+    }
+    state->fb.rt_size = gl_info->limits.buffers;
+
     if (flags & WINED3D_STATE_INIT_DEFAULT)
         state_init_default(state, gl_info);
 
@@ -1333,12 +1375,13 @@ static HRESULT stateblock_init(struct wined3d_stateblock *stateblock,
         struct wined3d_device *device, enum wined3d_stateblock_type type)
 {
     HRESULT hr;
+    const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
     const struct wined3d_d3d_info *d3d_info = &device->adapter->d3d_info;
 
     stateblock->ref = 1;
     stateblock->device = device;
 
-    if (FAILED(hr = state_init(&stateblock->state, NULL, &device->adapter->gl_info, d3d_info, 0)))
+    if (FAILED(hr = state_init(&stateblock->state, gl_info, d3d_info, 0)))
         return hr;
 
     if (FAILED(hr = stateblock_allocate_shader_constants(stateblock)))
diff --git a/dlls/wined3d/surface.c b/dlls/wined3d/surface.c
index 7c5f053..92a5edb 100644
--- a/dlls/wined3d/surface.c
+++ b/dlls/wined3d/surface.c
@@ -36,18 +36,9 @@ WINE_DECLARE_DEBUG_CHANNEL(d3d);
 
 #define MAXLOCKCOUNT 50 /* After this amount of locks do not free the sysmem copy. */
 
-static const DWORD surface_simple_locations =
-        WINED3D_LOCATION_SYSMEM | WINED3D_LOCATION_USER_MEMORY
-        | WINED3D_LOCATION_DIB | WINED3D_LOCATION_BUFFER;
-
-static void surface_cleanup(struct wined3d_surface *surface)
+void wined3d_surface_cleanup_cs(struct wined3d_surface *surface)
 {
-    struct wined3d_surface *overlay, *cur;
-
-    TRACE("surface %p.\n", surface);
-
-    if (surface->pbo || surface->rb_multisample
-            || surface->rb_resolved || !list_empty(&surface->renderbuffers))
+    if (surface->rb_multisample || surface->rb_resolved || !list_empty(&surface->renderbuffers))
     {
         struct wined3d_renderbuffer_entry *entry, *entry2;
         const struct wined3d_gl_info *gl_info;
@@ -56,12 +47,6 @@ static void surface_cleanup(struct wined3d_surface *surface)
         context = context_acquire(surface->resource.device, NULL);
         gl_info = context->gl_info;
 
-        if (surface->pbo)
-        {
-            TRACE("Deleting PBO %u.\n", surface->pbo);
-            GL_EXTCALL(glDeleteBuffersARB(1, &surface->pbo));
-        }
-
         if (surface->rb_multisample)
         {
             TRACE("Deleting multisample renderbuffer %u.\n", surface->rb_multisample);
@@ -88,9 +73,19 @@ static void surface_cleanup(struct wined3d_surface *surface)
     {
         DeleteDC(surface->hDC);
         DeleteObject(surface->dib.DIBsection);
-        surface->dib.bitmap_data = NULL;
+        surface->resource.bitmap_data = NULL;
     }
 
+    TRACE("Destroyed surface %p.\n", surface);
+    HeapFree(GetProcessHeap(), 0, surface);
+}
+
+static void surface_cleanup(struct wined3d_surface *surface)
+{
+    struct wined3d_surface *overlay, *cur;
+
+    TRACE("surface %p.\n", surface);
+
     if (surface->overlay_dest)
         list_remove(&surface->overlay_entry);
 
@@ -101,6 +96,7 @@ static void surface_cleanup(struct wined3d_surface *surface)
     }
 
     resource_cleanup(&surface->resource);
+    wined3d_cs_emit_surface_cleanup(surface->resource.device->cs, surface);
 }
 
 void surface_update_draw_binding(struct wined3d_surface *surface)
@@ -391,6 +387,7 @@ static HRESULT surface_create_dib_section(struct wined3d_surface *surface)
     BITMAPINFO *b_info;
     int extraline = 0;
     DWORD *masks;
+    UINT row_pitch, slice_pitch;
 
     TRACE("surface %p.\n", surface);
 
@@ -436,10 +433,11 @@ static HRESULT surface_create_dib_section(struct wined3d_surface *surface)
 
     b_info->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
     /* TODO: Is there a nicer way to force a specific alignment? (8 byte for ddraw) */
-    b_info->bmiHeader.biWidth = wined3d_surface_get_pitch(surface) / format->byte_count;
+    wined3d_resource_get_pitch(&surface->resource, &row_pitch, &slice_pitch);
+    b_info->bmiHeader.biWidth = row_pitch / format->byte_count;
     b_info->bmiHeader.biHeight = 0 - surface->resource.height - extraline;
     b_info->bmiHeader.biSizeImage = (surface->resource.height + extraline)
-            * wined3d_surface_get_pitch(surface);
+            * row_pitch;
     b_info->bmiHeader.biPlanes = 1;
     b_info->bmiHeader.biBitCount = format->byte_count * 8;
 
@@ -481,7 +479,7 @@ static HRESULT surface_create_dib_section(struct wined3d_surface *surface)
     TRACE("Creating a DIB section with size %dx%dx%d, size=%d.\n",
             b_info->bmiHeader.biWidth, b_info->bmiHeader.biHeight,
             b_info->bmiHeader.biBitCount, b_info->bmiHeader.biSizeImage);
-    surface->dib.DIBsection = CreateDIBSection(0, b_info, DIB_RGB_COLORS, &surface->dib.bitmap_data, 0, 0);
+    surface->dib.DIBsection = CreateDIBSection(0, b_info, DIB_RGB_COLORS, &surface->resource.bitmap_data, 0, 0);
 
     if (!surface->dib.DIBsection)
     {
@@ -490,7 +488,7 @@ static HRESULT surface_create_dib_section(struct wined3d_surface *surface)
         return HRESULT_FROM_WIN32(GetLastError());
     }
 
-    TRACE("DIBSection at %p.\n", surface->dib.bitmap_data);
+    TRACE("DIBSection at %p.\n", surface->resource.bitmap_data);
     surface->dib.bitmap_size = b_info->bmiHeader.biSizeImage;
 
     HeapFree(GetProcessHeap(), 0, b_info);
@@ -506,121 +504,14 @@ static HRESULT surface_create_dib_section(struct wined3d_surface *surface)
     return WINED3D_OK;
 }
 
-static void surface_get_memory(const struct wined3d_surface *surface, struct wined3d_bo_address *data,
-        DWORD location)
-{
-    if (location & WINED3D_LOCATION_BUFFER)
-    {
-        data->addr = NULL;
-        data->buffer_object = surface->pbo;
-        return;
-    }
-    if (location & WINED3D_LOCATION_USER_MEMORY)
-    {
-        data->addr = surface->user_memory;
-        data->buffer_object = 0;
-        return;
-    }
-    if (location & WINED3D_LOCATION_DIB)
-    {
-        data->addr = surface->dib.bitmap_data;
-        data->buffer_object = 0;
-        return;
-    }
-    if (location & WINED3D_LOCATION_SYSMEM)
-    {
-        data->addr = surface->resource.heap_memory;
-        data->buffer_object = 0;
-        return;
-    }
-
-    ERR("Unexpected locations %s.\n", wined3d_debug_location(location));
-    data->addr = NULL;
-    data->buffer_object = 0;
-}
-
-static void surface_prepare_buffer(struct wined3d_surface *surface)
-{
-    struct wined3d_context *context;
-    GLenum error;
-    const struct wined3d_gl_info *gl_info;
-
-    if (surface->pbo)
-        return;
-
-    context = context_acquire(surface->resource.device, NULL);
-    gl_info = context->gl_info;
-
-    GL_EXTCALL(glGenBuffersARB(1, &surface->pbo));
-    error = gl_info->gl_ops.gl.p_glGetError();
-    if (!surface->pbo || error != GL_NO_ERROR)
-        ERR("Failed to create a PBO with error %s (%#x).\n", debug_glerror(error), error);
-
-    TRACE("Binding PBO %u.\n", surface->pbo);
-
-    GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, surface->pbo));
-    checkGLcall("glBindBufferARB");
-
-    GL_EXTCALL(glBufferDataARB(GL_PIXEL_UNPACK_BUFFER_ARB, surface->resource.size + 4,
-            NULL, GL_STREAM_DRAW_ARB));
-    checkGLcall("glBufferDataARB");
-
-    GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, 0));
-    checkGLcall("glBindBufferARB");
-
-    context_release(context);
-}
-
-static void surface_prepare_system_memory(struct wined3d_surface *surface)
-{
-    TRACE("surface %p.\n", surface);
-
-    if (surface->resource.heap_memory)
-        return;
-
-    /* Whatever surface we have, make sure that there is memory allocated
-     * for the downloaded copy, or a PBO to map. */
-    if (!wined3d_resource_allocate_sysmem(&surface->resource))
-        ERR("Failed to allocate system memory.\n");
-
-    if (surface->locations & WINED3D_LOCATION_SYSMEM)
-        ERR("Surface without system memory has WINED3D_LOCATION_SYSMEM set.\n");
-}
-
-void surface_prepare_map_memory(struct wined3d_surface *surface)
-{
-    switch (surface->map_binding)
-    {
-        case WINED3D_LOCATION_SYSMEM:
-            surface_prepare_system_memory(surface);
-            break;
-
-        case WINED3D_LOCATION_USER_MEMORY:
-            if (!surface->user_memory)
-                ERR("Map binding is set to WINED3D_LOCATION_USER_MEMORY but surface->user_memory is NULL.\n");
-            break;
-
-        case WINED3D_LOCATION_DIB:
-            if (!surface->dib.bitmap_data)
-                ERR("Map binding is set to WINED3D_LOCATION_DIB but surface->dib.bitmap_data is NULL.\n");
-            break;
-
-        case WINED3D_LOCATION_BUFFER:
-            surface_prepare_buffer(surface);
-            break;
-
-        default:
-            ERR("Unexpected map binding %s.\n", wined3d_debug_location(surface->map_binding));
-    }
-}
-
 static void surface_evict_sysmem(struct wined3d_surface *surface)
 {
     if (surface->resource.map_count || surface->flags & SFLAG_DONOTFREE)
         return;
 
     wined3d_resource_free_sysmem(&surface->resource);
-    surface_invalidate_location(surface, WINED3D_LOCATION_SYSMEM);
+    surface->resource.map_heap_memory = NULL;
+    wined3d_resource_invalidate_location(&surface->resource, WINED3D_LOCATION_SYSMEM);
 }
 
 static void surface_force_reload(struct wined3d_surface *surface)
@@ -628,30 +519,6 @@ static void surface_force_reload(struct wined3d_surface *surface)
     surface->flags &= ~(SFLAG_ALLOCATED | SFLAG_SRGBALLOCATED);
 }
 
-static void surface_release_client_storage(struct wined3d_surface *surface)
-{
-    struct wined3d_context *context = context_acquire(surface->resource.device, NULL);
-    const struct wined3d_gl_info *gl_info = context->gl_info;
-
-    if (surface->container->texture_rgb.name)
-    {
-        wined3d_texture_bind_and_dirtify(surface->container, context, FALSE);
-        gl_info->gl_ops.gl.p_glTexImage2D(surface->texture_target, surface->texture_level,
-                GL_RGB, 1, 1, 0, GL_RGB, GL_UNSIGNED_BYTE, NULL);
-    }
-    if (surface->container->texture_srgb.name)
-    {
-        wined3d_texture_bind_and_dirtify(surface->container, context, TRUE);
-        gl_info->gl_ops.gl.p_glTexImage2D(surface->texture_target, surface->texture_level,
-                GL_RGB, 1, 1, 0, GL_RGB, GL_UNSIGNED_BYTE, NULL);
-    }
-
-    context_release(context);
-
-    surface_invalidate_location(surface, WINED3D_LOCATION_TEXTURE_RGB | WINED3D_LOCATION_TEXTURE_SRGB);
-    surface_force_reload(surface);
-}
-
 static BOOL surface_use_pbo(const struct wined3d_surface *surface)
 {
     const struct wined3d_gl_info *gl_info = &surface->resource.device->adapter->gl_info;
@@ -749,44 +616,50 @@ static HRESULT surface_private_setup(struct wined3d_surface *surface)
     }
 
     if (surface->resource.usage & WINED3DUSAGE_DEPTHSTENCIL)
-        surface->locations = WINED3D_LOCATION_DISCARDED;
+        surface->resource.locations = WINED3D_LOCATION_DISCARDED;
 
     if (surface_use_pbo(surface))
-        surface->map_binding = WINED3D_LOCATION_BUFFER;
+        surface->resource.map_binding = WINED3D_LOCATION_BUFFER;
 
     return WINED3D_OK;
 }
 
 static void surface_realize_palette(struct wined3d_surface *surface)
 {
+    struct wined3d_context *context;
     struct wined3d_palette *palette = surface->palette;
 
     TRACE("surface %p.\n", surface);
 
     if (!palette) return;
 
-    if (surface->resource.format->id == WINED3DFMT_P8_UINT
+    context = context_acquire(surface->resource.device, NULL);
+
+    if ((surface->resource.format->id == WINED3DFMT_P8_UINT
             || surface->resource.format->id == WINED3DFMT_P8_UINT_A8_UNORM)
+            && !(surface->resource.locations & WINED3D_LOCATION_DISCARDED))
     {
         if (surface->resource.usage & WINED3DUSAGE_RENDERTARGET)
         {
+            /* FIXME: This codepath should be dead */
+
             /* Make sure the texture is up to date. This call doesn't do
              * anything if the texture is already up to date. */
-            surface_load_location(surface, WINED3D_LOCATION_TEXTURE_RGB);
+            wined3d_resource_load_location(&surface->resource, context, WINED3D_LOCATION_TEXTURE_RGB);
 
             /* We want to force a palette refresh, so mark the drawable as not being up to date */
             if (!surface_is_offscreen(surface))
-                surface_invalidate_location(surface, WINED3D_LOCATION_DRAWABLE);
+                wined3d_resource_invalidate_location(&surface->resource, WINED3D_LOCATION_DRAWABLE);
         }
         else
         {
-            if (!(surface->locations & surface->map_binding))
+            if (!(surface->resource.locations & surface->resource.map_binding))
             {
                 TRACE("Palette changed with surface that does not have an up to date system memory copy.\n");
-                surface_prepare_map_memory(surface);
-                surface_load_location(surface, surface->map_binding);
+                wined3d_resource_prepare_map_memory(&surface->resource, context);
+                wined3d_resource_load_location(&surface->resource, context, surface->resource.map_binding);
             }
-            surface_invalidate_location(surface, ~surface->map_binding);
+            wined3d_resource_invalidate_location(&surface->resource, ~surface->resource.map_binding);
         }
     }
 
@@ -809,51 +682,27 @@ static void surface_realize_palette(struct wined3d_surface *surface)
 
     /* Propagate the changes to the drawable when we have a palette. */
     if (surface->resource.usage & WINED3DUSAGE_RENDERTARGET)
-        surface_load_location(surface, surface->draw_binding);
+        wined3d_resource_load_location(&surface->resource, context, surface->draw_binding);
+
+    context_release(context);
 }
 
-static void surface_unmap(struct wined3d_surface *surface)
+static void surface_frontbuffer_updated(struct wined3d_surface *surface)
 {
+    struct wined3d_context *context = NULL;
     struct wined3d_device *device = surface->resource.device;
-    const struct wined3d_gl_info *gl_info;
-    struct wined3d_context *context;
-
-    TRACE("surface %p.\n", surface);
-
-    memset(&surface->lockedRect, 0, sizeof(surface->lockedRect));
-
-    switch (surface->map_binding)
-    {
-        case WINED3D_LOCATION_SYSMEM:
-        case WINED3D_LOCATION_USER_MEMORY:
-        case WINED3D_LOCATION_DIB:
-            break;
-
-        case WINED3D_LOCATION_BUFFER:
-            context = context_acquire(device, NULL);
-            gl_info = context->gl_info;
-
-            GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, surface->pbo));
-            GL_EXTCALL(glUnmapBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB));
-            GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, 0));
-            checkGLcall("glUnmapBufferARB");
-            context_release(context);
-            break;
 
-        default:
-            ERR("Unexpected map binding %s.\n", wined3d_debug_location(surface->map_binding));
-    }
-
-    if (surface->locations & (WINED3D_LOCATION_DRAWABLE | WINED3D_LOCATION_TEXTURE_RGB))
+    if (surface->resource.locations & WINED3D_LOCATION_DRAWABLE)
     {
         TRACE("Not dirtified, nothing to do.\n");
         return;
     }
 
-    if (surface->swapchain && surface->swapchain->front_buffer == surface)
-        surface_load_location(surface, surface->draw_binding);
-    else if (surface->resource.format->flags & (WINED3DFMT_FLAG_DEPTH | WINED3DFMT_FLAG_STENCIL))
-        FIXME("Depth / stencil buffer locking is not implemented.\n");
+    if (device->d3d_initialized)
+        context = context_acquire(surface->resource.device, NULL);
+    wined3d_resource_load_location(&surface->resource, context, surface->draw_binding);
+    if (context)
+        context_release(context);
 }
 
 static BOOL surface_is_full_rect(const struct wined3d_surface *surface, const RECT *r)
@@ -904,12 +753,6 @@ static void surface_depth_blt_fbo(const struct wined3d_device *device,
     if (src_mask & WINED3DFMT_FLAG_STENCIL)
         gl_mask |= GL_STENCIL_BUFFER_BIT;
 
-    /* Make sure the locations are up-to-date. Loading the destination
-     * surface isn't required if the entire surface is overwritten. */
-    surface_load_location(src_surface, src_location);
-    if (!surface_is_full_rect(dst_surface, dst_rect))
-        surface_load_location(dst_surface, dst_location);
-
     context = context_acquire(device, NULL);
     if (!context->valid)
     {
@@ -918,6 +761,12 @@ static void surface_depth_blt_fbo(const struct wined3d_device *device,
         return;
     }
 
+    /* Make sure the locations are up-to-date. Loading the destination
+     * surface isn't required if the entire surface is overwritten. */
+    wined3d_resource_load_location(&src_surface->resource, context, src_location);
+    if (!surface_is_full_rect(dst_surface, dst_rect))
+        wined3d_resource_load_location(&dst_surface->resource, context, dst_location);
+
     gl_info = context->gl_info;
 
     context_apply_fbo_state_blit(context, GL_READ_FRAMEBUFFER, NULL, src_surface, src_location);
@@ -958,13 +807,15 @@ static void surface_depth_blt_fbo(const struct wined3d_device *device,
 }
 
 /* Blit between surface locations. Onscreen on different swapchains is not supported.
- * Depth / stencil is not supported. */
-static void surface_blt_fbo(const struct wined3d_device *device, enum wined3d_texture_filter_type filter,
+ * Depth / stencil is not supported. Context activation is done by the caller. */
+static void surface_blt_fbo(const struct wined3d_device *device,
+        struct wined3d_context *old_ctx, enum wined3d_texture_filter_type filter,
         struct wined3d_surface *src_surface, DWORD src_location, const RECT *src_rect_in,
         struct wined3d_surface *dst_surface, DWORD dst_location, const RECT *dst_rect_in)
 {
     const struct wined3d_gl_info *gl_info;
     struct wined3d_context *context;
+    struct wined3d_surface *required_rt, *restore_rt;
     RECT src_rect, dst_rect;
     GLenum gl_filter;
     GLenum buffer;
@@ -1003,13 +854,24 @@ static void surface_blt_fbo(const struct wined3d_device *device, enum wined3d_te
      * surface isn't required if the entire surface is overwritten. (And is
      * in fact harmful if we're being called by surface_load_location() with
      * the purpose of loading the destination surface.) */
-    surface_load_location(src_surface, src_location);
+    wined3d_resource_load_location(&src_surface->resource, old_ctx, src_location);
     if (!surface_is_full_rect(dst_surface, &dst_rect))
-        surface_load_location(dst_surface, dst_location);
+        wined3d_resource_load_location(&dst_surface->resource, old_ctx, dst_location);
 
-    if (src_location == WINED3D_LOCATION_DRAWABLE) context = context_acquire(device, src_surface);
-    else if (dst_location == WINED3D_LOCATION_DRAWABLE) context = context_acquire(device, dst_surface);
-    else context = context_acquire(device, NULL);
+    if (src_location == WINED3D_LOCATION_DRAWABLE) required_rt = src_surface;
+    else if (dst_location == WINED3D_LOCATION_DRAWABLE) required_rt = dst_surface;
+    else required_rt = NULL;
+
+    if (required_rt && required_rt != old_ctx->current_rt)
+    {
+        restore_rt = context->current_rt;
+        context = context_acquire(device, required_rt);
+    }
+    else
+    {
+        restore_rt = NULL;
+        context = old_ctx;
+    }
 
     if (!context->valid)
     {
@@ -1072,7 +934,12 @@ static void surface_blt_fbo(const struct wined3d_device *device, enum wined3d_te
             && dst_surface->swapchain->front_buffer == dst_surface))
         gl_info->gl_ops.gl.p_glFlush();
 
-    context_release(context);
+    if (restore_rt)
+    {
+        context_release(context);
+        context = context_acquire(device, restore_rt);
+        context_release(context);
+    }
 }
 
 static BOOL fbo_blit_supported(const struct wined3d_gl_info *gl_info, enum wined3d_blit_op blit_op,
@@ -1247,16 +1114,6 @@ HRESULT CDECL wined3d_surface_get_render_target_data(struct wined3d_surface *sur
     return wined3d_surface_blt(surface, NULL, render_target, NULL, 0, NULL, WINED3D_TEXF_POINT);
 }
 
-/* Context activation is done by the caller. */
-static void surface_remove_pbo(struct wined3d_surface *surface, const struct wined3d_gl_info *gl_info)
-{
-    GL_EXTCALL(glDeleteBuffersARB(1, &surface->pbo));
-    checkGLcall("glDeleteBuffersARB(1, &surface->pbo)");
-
-    surface->pbo = 0;
-    surface_invalidate_location(surface, WINED3D_LOCATION_BUFFER);
-}
-
 static void surface_unload(struct wined3d_resource *resource)
 {
     struct wined3d_surface *surface = surface_from_resource(resource);
@@ -1267,21 +1124,17 @@ static void surface_unload(struct wined3d_resource *resource)
 
     TRACE("surface %p.\n", surface);
 
+    context = context_acquire(device, NULL);
+    gl_info = context->gl_info;
+
     if (resource->pool == WINED3D_POOL_DEFAULT)
     {
         /* Default pool resources are supposed to be destroyed before Reset is called.
          * Implicit resources stay however. So this means we have an implicit render target
          * or depth stencil. The content may be destroyed, but we still have to tear down
-         * opengl resources, so we cannot leave early.
-         *
-         * Put the surfaces into sysmem, and reset the content. The D3D content is undefined,
-         * but we can't set the sysmem INDRAWABLE because when we're rendering the swapchain
-         * or the depth stencil into an FBO the texture or render buffer will be removed
-         * and all flags get lost */
-        surface_prepare_system_memory(surface);
-        memset(surface->resource.heap_memory, 0, surface->resource.size);
-        surface_validate_location(surface, WINED3D_LOCATION_SYSMEM);
-        surface_invalidate_location(surface, ~WINED3D_LOCATION_SYSMEM);
+         * opengl resources, so we cannot leave early. */
+        wined3d_resource_validate_location(&surface->resource, WINED3D_LOCATION_DISCARDED);
+        wined3d_resource_invalidate_location(&surface->resource, ~WINED3D_LOCATION_DISCARDED);
 
         /* We also get here when the ddraw swapchain is destroyed, for example
          * for a mode switch. In this case this surface won't necessarily be
@@ -1291,19 +1144,12 @@ static void surface_unload(struct wined3d_resource *resource)
     }
     else
     {
-        surface_prepare_map_memory(surface);
-        surface_load_location(surface, surface->map_binding);
-        surface_invalidate_location(surface, ~surface->map_binding);
+        wined3d_resource_prepare_map_memory(&surface->resource, context);
+        wined3d_resource_load_location(&surface->resource, context, surface->resource.map_binding);
+        wined3d_resource_invalidate_location(&surface->resource, ~surface->resource.map_binding);
     }
     surface->flags &= ~(SFLAG_ALLOCATED | SFLAG_SRGBALLOCATED);
 
-    context = context_acquire(device, NULL);
-    gl_info = context->gl_info;
-
-    /* Destroy PBOs, but load them into real sysmem before */
-    if (surface->pbo)
-        surface_remove_pbo(surface, gl_info);
-
     /* Destroy fbo render buffers. This is needed for implicit render targets, for
      * all application-created targets the application has to release the surface
      * before calling _Reset
@@ -1333,16 +1179,22 @@ static void surface_unload(struct wined3d_resource *resource)
     resource_unload(resource);
 }
 
-static const struct wined3d_resource_ops surface_resource_ops =
+static void wined3d_surface_location_invalidated(struct wined3d_resource *resource, DWORD location)
 {
-    surface_unload,
-};
+    struct wined3d_surface *surface = surface_from_resource(resource);
+
+    if (location & (WINED3D_LOCATION_TEXTURE_RGB | WINED3D_LOCATION_TEXTURE_SRGB))
+        wined3d_texture_set_dirty(surface->container);
+
+    if (surface->swapchain && surface == surface->swapchain->front_buffer)
+        surface->surface_ops->surface_frontbuffer_updated(surface);
+}
 
 static const struct wined3d_surface_ops surface_ops =
 {
     surface_private_setup,
     surface_realize_palette,
-    surface_unmap,
+    surface_frontbuffer_updated,
 };
 
 /*****************************************************************************
@@ -1377,7 +1229,7 @@ static HRESULT gdi_surface_private_setup(struct wined3d_surface *surface)
     hr = surface_create_dib_section(surface);
     if (FAILED(hr))
         return hr;
-    surface->map_binding = WINED3D_LOCATION_DIB;
+    surface->resource.map_binding = WINED3D_LOCATION_DIB;
 
     /* We don't mind the nonpow2 stuff in GDI. */
     surface->pow2Width = surface->resource.width;
@@ -1418,22 +1270,16 @@ static void gdi_surface_realize_palette(struct wined3d_surface *surface)
         x11_copy_to_screen(surface->swapchain, NULL);
 }
 
-static void gdi_surface_unmap(struct wined3d_surface *surface)
+static void gdi_surface_frontbuffer_updated(struct wined3d_surface *surface)
 {
-    TRACE("surface %p.\n", surface);
-
-    /* Tell the swapchain to update the screen. */
-    if (surface->swapchain && surface == surface->swapchain->front_buffer)
-        x11_copy_to_screen(surface->swapchain, &surface->lockedRect);
-
-    memset(&surface->lockedRect, 0, sizeof(RECT));
+    x11_copy_to_screen(surface->swapchain, &surface->lockedRect);
 }
 
 static const struct wined3d_surface_ops gdi_surface_ops =
 {
     gdi_surface_private_setup,
     gdi_surface_realize_palette,
-    gdi_surface_unmap,
+    gdi_surface_frontbuffer_updated,
 };
 
 void surface_set_texture_target(struct wined3d_surface *surface, GLenum target, GLint level)
@@ -1472,7 +1318,7 @@ static void surface_download_data(struct wined3d_surface *surface, const struct
         return;
     }
 
-    surface_get_memory(surface, &data, dst_location);
+    wined3d_resource_get_memory(&surface->resource, dst_location, &data);
 
     if (format->flags & WINED3DFMT_FLAG_COMPRESSED)
     {
@@ -1500,8 +1346,8 @@ static void surface_download_data(struct wined3d_surface *surface, const struct
         void *mem;
         GLenum gl_format = format->glFormat;
         GLenum gl_type = format->glType;
-        int src_pitch = 0;
-        int dst_pitch = 0;
+        UINT src_pitch = 0;
+        UINT dst_row_pitch, dst_slice_pitch;
 
         /* In case of P8 the index is stored in the alpha component if the primary render target uses P8. */
         if (format->id == WINED3DFMT_P8_UINT && swapchain_is_p8(surface->resource.device->swapchains[0]))
@@ -1514,7 +1360,7 @@ static void surface_download_data(struct wined3d_surface *surface, const struct
         {
             unsigned char alignment = surface->resource.device->surface_alignment;
             src_pitch = format->byte_count * surface->pow2Width;
-            dst_pitch = wined3d_surface_get_pitch(surface);
+            wined3d_resource_get_pitch(&surface->resource, &dst_row_pitch, &dst_slice_pitch);
             src_pitch = (src_pitch + alignment - 1) & ~(alignment - 1);
             mem = HeapAlloc(GetProcessHeap(), 0, src_pitch * surface->pow2Height);
         }
@@ -1601,12 +1447,12 @@ static void surface_download_data(struct wined3d_surface *surface, const struct
              * and doesn't have to be re-read. */
             src_data = mem;
             dst_data = data.addr;
-            TRACE("(%p) : Repacking the surface data from pitch %d to pitch %d\n", surface, src_pitch, dst_pitch);
+            TRACE("(%p) : Repacking the surface data from pitch %d to pitch %d\n", surface, src_pitch, dst_row_pitch);
             for (y = 0; y < surface->resource.height; ++y)
             {
-                memcpy(dst_data, src_data, dst_pitch);
+                memcpy(dst_data, src_data, dst_row_pitch);
                 src_data += src_pitch;
-                dst_data += dst_pitch;
+                dst_data += dst_row_pitch;
             }
 
             HeapFree(GetProcessHeap(), 0, mem);
@@ -1855,25 +1701,20 @@ static HRESULT d3dfmt_get_conv(const struct wined3d_surface *surface, BOOL need_
     return WINED3D_OK;
 }
 
-static BOOL surface_check_block_align(struct wined3d_surface *surface, const RECT *rect)
+BOOL surface_check_block_align(struct wined3d_surface *surface, const RECT *rect)
 {
-    UINT width_mask, height_mask;
-
-    if (!rect->left && !rect->top
-            && rect->right == surface->resource.width
-            && rect->bottom == surface->resource.height)
-        return TRUE;
-
-    /* This assumes power of two block sizes, but NPOT block sizes would be
-     * silly anyway. */
-    width_mask = surface->resource.format->block_width - 1;
-    height_mask = surface->resource.format->block_height - 1;
+    struct wined3d_box box;
 
-    if (!(rect->left & width_mask) && !(rect->top & height_mask)
-            && !(rect->right & width_mask) && !(rect->bottom & height_mask))
-        return TRUE;
-
-    return FALSE;
+    if (!rect)
+        return wined3d_resource_check_block_align(&surface->resource, NULL);
+
+    box.left = rect->left;
+    box.top = rect->top;
+    box.front = 0;
+    box.right = rect->right;
+    box.bottom = rect->bottom;
+    box.back = 1;
+    return wined3d_resource_check_block_align(&surface->resource, &box);
 }
 
 HRESULT surface_upload_from_surface(struct wined3d_surface *dst_surface, const POINT *dst_point,
@@ -1889,7 +1730,7 @@ HRESULT surface_upload_from_surface(struct wined3d_surface *dst_surface, const P
     UINT update_w, update_h;
     UINT dst_w, dst_h;
     RECT r, dst_rect;
-    UINT src_pitch;
+    UINT src_row_pitch, src_slice_pitch;
     POINT p;
 
     TRACE("dst_surface %p, dst_point %s, src_surface %p, src_rect %s.\n",
@@ -1972,20 +1813,20 @@ HRESULT surface_upload_from_surface(struct wined3d_surface *dst_surface, const P
     if (update_w == dst_w && update_h == dst_h)
         surface_prepare_texture(dst_surface, context, FALSE);
     else
-        surface_load_location(dst_surface, WINED3D_LOCATION_TEXTURE_RGB);
+        wined3d_resource_load_location(&dst_surface->resource, context, WINED3D_LOCATION_TEXTURE_RGB);
     wined3d_texture_bind(dst_surface->container, context, FALSE);
 
-    surface_get_memory(src_surface, &data, src_surface->locations);
-    src_pitch = wined3d_surface_get_pitch(src_surface);
+    wined3d_resource_get_memory(&src_surface->resource, src_surface->resource.locations, &data);
+    wined3d_resource_get_pitch(&src_surface->resource, &src_row_pitch, &src_slice_pitch);
 
-    surface_upload_data(dst_surface, gl_info, src_format, src_rect, src_pitch, dst_point, FALSE, &data);
+    surface_upload_data(dst_surface, gl_info, src_format, src_rect, src_row_pitch, dst_point, FALSE, &data);
 
     context_invalidate_active_texture(context);
 
     context_release(context);
 
-    surface_validate_location(dst_surface, WINED3D_LOCATION_TEXTURE_RGB);
-    surface_invalidate_location(dst_surface, ~WINED3D_LOCATION_TEXTURE_RGB);
+    wined3d_resource_validate_location(&dst_surface->resource, WINED3D_LOCATION_TEXTURE_RGB);
+    wined3d_resource_invalidate_location(&dst_surface->resource, ~WINED3D_LOCATION_TEXTURE_RGB);
 
     return WINED3D_OK;
 }
@@ -2030,19 +1871,16 @@ static void surface_allocate_surface(struct wined3d_surface *surface, const stru
 
     if (gl_info->supported[APPLE_CLIENT_STORAGE])
     {
-        if (surface->flags & (SFLAG_NONPOW2 | SFLAG_DIBSECTION | SFLAG_CONVERTED)
-                || !surface->resource.heap_memory)
+        if (surface->flags & (SFLAG_NONPOW2 | SFLAG_CONVERTED))
         {
             /* In some cases we want to disable client storage.
              * SFLAG_NONPOW2 has a bigger opengl texture than the client memory, and different pitches
-             * SFLAG_DIBSECTION: Dibsections may have read / write protections on the memory. Avoid issues...
-             * SFLAG_CONVERTED: The conversion destination memory is freed after loading the surface
-             * heap_memory == NULL: Not defined in the extension. Seems to disable client storage effectively
-             */
+             * SFLAG_CONVERTED: The conversion destination memory is freed after loading the surface */
             surface->flags &= ~SFLAG_CLIENT;
         }
         else
         {
+            wined3d_resource_prepare_system_memory(&surface->resource);
             surface->flags |= SFLAG_CLIENT;
             mem = surface->resource.heap_memory;
 
@@ -2171,7 +2009,8 @@ GLenum surface_get_gl_buffer(const struct wined3d_surface *surface)
     return GL_BACK;
 }
 
-void surface_load(struct wined3d_surface *surface, BOOL srgb)
+/* Context activation is done by the caller. */
+void surface_load(struct wined3d_surface *surface, struct wined3d_context *context, BOOL srgb)
 {
     DWORD location = srgb ? WINED3D_LOCATION_TEXTURE_SRGB : WINED3D_LOCATION_TEXTURE_RGB;
     BOOL ck_changed;
@@ -2195,14 +2034,14 @@ void surface_load(struct wined3d_surface *surface, BOOL srgb)
         /* To perform the color key conversion we need a sysmem copy of
          * the surface. Make sure we have it. */
 
-        surface_prepare_map_memory(surface);
-        surface_load_location(surface, surface->map_binding);
-        surface_invalidate_location(surface, ~surface->map_binding);
+        wined3d_resource_prepare_map_memory(&surface->resource, context);
+        wined3d_resource_load_location(&surface->resource, context, surface->resource.map_binding);
+        wined3d_resource_invalidate_location(&surface->resource, ~surface->resource.map_binding);
         /* Switching color keying on / off may change the internal format. */
         if (ck_changed)
             surface_force_reload(surface);
     }
-    else if (!(surface->locations & location))
+    else if (!(surface->resource.locations & location))
     {
         TRACE("Reloading because surface is dirty.\n");
     }
@@ -2212,7 +2051,7 @@ void surface_load(struct wined3d_surface *surface, BOOL srgb)
         return;
     }
 
-    surface_load_location(surface, location);
+    wined3d_resource_load_location(&surface->resource, context, location);
     surface_evict_sysmem(surface);
 }
 
@@ -2316,11 +2155,8 @@ ULONG CDECL wined3d_surface_decref(struct wined3d_surface *surface)
 
     if (!refcount)
     {
-        surface_cleanup(surface);
         surface->resource.parent_ops->wined3d_object_destroyed(surface->resource.parent);
-
-        TRACE("Destroyed surface %p.\n", surface);
-        HeapFree(GetProcessHeap(), 0, surface);
+        surface_cleanup(surface);
     }
 
     return refcount;
@@ -2338,15 +2174,16 @@ DWORD CDECL wined3d_surface_get_priority(const struct wined3d_surface *surface)
 
 void CDECL wined3d_surface_preload(struct wined3d_surface *surface)
 {
+    const struct wined3d_device *device = surface->resource.device;
     TRACE("surface %p.\n", surface);
 
-    if (!surface->resource.device->d3d_initialized)
+    if (!device->d3d_initialized)
     {
         ERR("D3D not initialized.\n");
         return;
     }
 
-    wined3d_texture_preload(surface->container);
+    wined3d_cs_emit_surface_preload(device->cs, surface);
 }
 
 void * CDECL wined3d_surface_get_parent(const struct wined3d_surface *surface)
@@ -2413,6 +2250,8 @@ HRESULT CDECL wined3d_surface_restore(struct wined3d_surface *surface)
 
 void CDECL wined3d_surface_set_palette(struct wined3d_surface *surface, struct wined3d_palette *palette)
 {
+    struct wined3d_device *device = surface->resource.device;
+
     TRACE("surface %p, palette %p.\n", surface, palette);
 
     if (surface->palette == palette)
@@ -2421,9 +2260,7 @@ void CDECL wined3d_surface_set_palette(struct wined3d_surface *surface, struct w
         return;
     }
 
-    surface->palette = palette;
-    if (palette)
-        surface->surface_ops->surface_realize_palette(surface);
+    wined3d_cs_emit_set_palette(device->cs, surface, palette);
 }
 
 struct wined3d_palette * CDECL wined3d_surface_get_palette(const struct wined3d_surface *surface)
@@ -2433,35 +2270,6 @@ struct wined3d_palette * CDECL wined3d_surface_get_palette(const struct wined3d_
     return surface->palette;
 }
 
-DWORD CDECL wined3d_surface_get_pitch(const struct wined3d_surface *surface)
-{
-    const struct wined3d_format *format = surface->resource.format;
-    DWORD pitch;
-
-    TRACE("surface %p.\n", surface);
-
-    if (surface->pitch)
-        return surface->pitch;
-
-    if (format->flags & WINED3DFMT_FLAG_BLOCKS)
-    {
-        /* Since compressed formats are block based, pitch means the amount of
-         * bytes to the next row of block rather than the next row of pixels. */
-        UINT row_block_count = (surface->resource.width + format->block_width - 1) / format->block_width;
-        pitch = row_block_count * format->block_byte_count;
-    }
-    else
-    {
-        unsigned char alignment = surface->resource.device->surface_alignment;
-        pitch = surface->resource.format->byte_count * surface->resource.width;  /* Bytes / row */
-        pitch = (pitch + alignment - 1) & ~(alignment - 1);
-    }
-
-    TRACE("Returning %u.\n", pitch);
-
-    return pitch;
-}
-
 HRESULT CDECL wined3d_surface_set_overlay_position(struct wined3d_surface *surface, LONG x, LONG y)
 {
     LONG w, h;
@@ -2619,19 +2427,23 @@ HRESULT CDECL wined3d_surface_update_desc(struct wined3d_surface *surface,
     }
 
     if (device->d3d_initialized)
-        surface->resource.resource_ops->resource_unload(&surface->resource);
+    {
+        wined3d_cs_emit_evict_resource(device->cs, &surface->resource);
+        device->cs->ops->finish(device->cs);
+    }
 
     if (surface->flags & SFLAG_DIBSECTION)
     {
         DeleteDC(surface->hDC);
         DeleteObject(surface->dib.DIBsection);
-        surface->dib.bitmap_data = NULL;
+        surface->resource.bitmap_data = NULL;
         surface->flags &= ~SFLAG_DIBSECTION;
         create_dib = TRUE;
     }
 
-    surface->locations = 0;
+    surface->resource.locations = 0;
     wined3d_resource_free_sysmem(&surface->resource);
+    surface->resource.map_heap_memory = NULL;
 
     surface->resource.width = width;
     surface->resource.height = height;
@@ -2655,18 +2467,19 @@ HRESULT CDECL wined3d_surface_update_desc(struct wined3d_surface *surface,
     else
         surface->flags &= ~SFLAG_NONPOW2;
 
-    surface->user_memory = mem;
-    if (surface->user_memory)
+    surface->resource.user_memory = mem;
+    if (surface->resource.user_memory)
     {
-        surface->map_binding = WINED3D_LOCATION_USER_MEMORY;
+        surface->resource.map_binding = WINED3D_LOCATION_USER_MEMORY;
         valid_location = WINED3D_LOCATION_USER_MEMORY;
     }
-    surface->pitch = pitch;
+    surface->resource.custom_row_pitch = pitch;
+    surface->resource.custom_slice_pitch = pitch * surface->resource.height;
     surface->resource.format = format;
     surface->resource.multisample_type = multisample_type;
     surface->resource.multisample_quality = multisample_quality;
-    if (surface->pitch)
-        surface->resource.size = height * surface->pitch;
+    if (surface->resource.custom_row_pitch)
+        surface->resource.size = height * surface->resource.custom_row_pitch;
     else
         surface->resource.size = resource_size;
 
@@ -2674,8 +2487,8 @@ HRESULT CDECL wined3d_surface_update_desc(struct wined3d_surface *surface,
      * If the surface didn't use PBOs previously but could now, don't
      * change it - whatever made us not use PBOs might come back, e.g.
      * color keys. */
-    if (surface->map_binding == WINED3D_LOCATION_BUFFER && !surface_use_pbo(surface))
-        surface->map_binding = create_dib ? WINED3D_LOCATION_DIB : WINED3D_LOCATION_SYSMEM;
+    if (surface->resource.map_binding == WINED3D_LOCATION_BUFFER && !surface_use_pbo(surface))
+        surface->resource.map_binding = create_dib ? WINED3D_LOCATION_DIB : WINED3D_LOCATION_SYSMEM;
 
     if (create_dib)
     {
@@ -2690,11 +2503,11 @@ HRESULT CDECL wined3d_surface_update_desc(struct wined3d_surface *surface,
 
     if (!valid_location)
     {
-        surface_prepare_system_memory(surface);
+        wined3d_resource_prepare_system_memory(&surface->resource);
         valid_location = WINED3D_LOCATION_SYSMEM;
     }
 
-    surface_validate_location(surface, valid_location);
+    wined3d_resource_validate_location(&surface->resource, valid_location);
 
     return WINED3D_OK;
 }
@@ -2900,11 +2713,14 @@ static inline const struct d3dfmt_converter_desc *find_converter(enum wined3d_fo
 
 static struct wined3d_texture *surface_convert_format(struct wined3d_surface *source, enum wined3d_format_id to_fmt)
 {
-    struct wined3d_map_desc src_map, dst_map;
+    void *dst_data = NULL, *src_data = NULL;
+    UINT src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch;
     const struct d3dfmt_converter_desc *conv;
     struct wined3d_texture *ret = NULL;
     struct wined3d_resource_desc desc;
     struct wined3d_surface *dst;
+    struct wined3d_context *context = NULL;
+    struct wined3d_device *device = source->resource.device;
 
     conv = find_converter(source->resource.format->id, to_fmt);
     if (!conv)
@@ -2928,30 +2744,46 @@ static struct wined3d_texture *surface_convert_format(struct wined3d_surface *so
     }
     dst = surface_from_resource(wined3d_texture_get_sub_resource(ret, 0));
 
-    memset(&src_map, 0, sizeof(src_map));
-    memset(&dst_map, 0, sizeof(dst_map));
+    wined3d_resource_get_pitch(&source->resource, &src_row_pitch, &src_slice_pitch);
+    wined3d_resource_get_pitch(&ret->resource, &dst_row_pitch, &dst_slice_pitch);
 
-    if (FAILED(wined3d_surface_map(source, &src_map, NULL, WINED3D_MAP_READONLY)))
-    {
-        ERR("Failed to lock the source surface.\n");
-        wined3d_texture_decref(ret);
-        return NULL;
-    }
-    if (FAILED(wined3d_surface_map(dst, &dst_map, NULL, 0)))
-    {
-        ERR("Failed to lock the destination surface.\n");
-        wined3d_surface_unmap(source);
-        wined3d_texture_decref(ret);
-        return NULL;
-    }
+    if (device->d3d_initialized)
+        context = context_acquire(device, NULL);
 
-    conv->convert(src_map.data, dst_map.data, src_map.row_pitch, dst_map.row_pitch,
+    wined3d_resource_load_location(&source->resource, context, source->resource.map_binding);
+    src_data = wined3d_resource_get_map_ptr(&source->resource, context, WINED3D_MAP_READONLY);
+    if (!src_data)
+        goto error;
+
+    if (!wined3d_resource_prepare_map_memory(&dst->resource, context))
+        goto error;
+    dst_data = wined3d_resource_get_map_ptr(&dst->resource, context, 0);
+    if (!dst_data)
+        goto error;
+
+    conv->convert(src_data, dst_data, src_row_pitch, dst_row_pitch,
             source->resource.width, source->resource.height);
 
-    wined3d_surface_unmap(dst);
-    wined3d_surface_unmap(source);
+    wined3d_resource_release_map_ptr(&dst->resource, context);
+    wined3d_resource_release_map_ptr(&source->resource, context);
+
+    if (context)
+        context_release(context);
 
     return ret;
+
+error:
+    ERR("Surface conversion failed.\n");
+
+    if (src_data)
+        wined3d_resource_release_map_ptr(&source->resource, context);
+    if (dst_data)
+        wined3d_resource_release_map_ptr(&ret->resource, context);
+    if (ret)
+        wined3d_texture_decref(ret);
+    if (context)
+        context_release(context);
+    return NULL;
 }
 
 static HRESULT _Blt_ColorFill(BYTE *buf, unsigned int width, unsigned int height,
@@ -3019,37 +2851,23 @@ struct wined3d_surface * CDECL wined3d_surface_from_resource(struct wined3d_reso
 
 HRESULT CDECL wined3d_surface_unmap(struct wined3d_surface *surface)
 {
+    HRESULT hr;
     TRACE("surface %p.\n", surface);
 
-    if (!surface->resource.map_count)
-    {
-        WARN("Trying to unmap unmapped surface.\n");
-        return WINEDDERR_NOTLOCKED;
-    }
-    --surface->resource.map_count;
+    hr = wined3d_resource_unmap(&surface->resource);
+    if (FAILED(hr))
+        return hr;
 
-    surface->surface_ops->surface_unmap(surface);
+    memset(&surface->lockedRect, 0, sizeof(surface->lockedRect));
 
-    return WINED3D_OK;
+    return hr;
 }
 
 HRESULT CDECL wined3d_surface_map(struct wined3d_surface *surface,
         struct wined3d_map_desc *map_desc, const RECT *rect, DWORD flags)
 {
+    struct wined3d_box box;
     const struct wined3d_format *format = surface->resource.format;
-    struct wined3d_device *device = surface->resource.device;
-    struct wined3d_context *context;
-    const struct wined3d_gl_info *gl_info;
-    BYTE *base_memory;
-
-    TRACE("surface %p, map_desc %p, rect %s, flags %#x.\n",
-            surface, map_desc, wine_dbgstr_rect(rect), flags);
-
-    if (surface->resource.map_count)
-    {
-        WARN("Surface is already mapped.\n");
-        return WINED3DERR_INVALIDCALL;
-    }
 
     if ((format->flags & WINED3DFMT_FLAG_BLOCKS) && rect
             && !surface_check_block_align(surface, rect))
@@ -3061,16 +2879,11 @@ HRESULT CDECL wined3d_surface_map(struct wined3d_surface *surface,
             return WINED3DERR_INVALIDCALL;
     }
 
-    ++surface->resource.map_count;
-
-    if (!(surface->resource.access_flags & WINED3D_RESOURCE_ACCESS_CPU))
-        WARN("Trying to lock unlockable surface.\n");
-
     /* Performance optimization: Count how often a surface is mapped, if it is
      * mapped regularly do not throw away the system memory copy. This avoids
      * the need to download the surface from OpenGL all the time. The surface
      * is still downloaded if the OpenGL texture is changed. */
-    if (!(surface->flags & SFLAG_DYNLOCK) && surface->map_binding == WINED3D_LOCATION_SYSMEM)
+    if (!(surface->flags & SFLAG_DYNLOCK) && surface->resource.map_binding == WINED3D_LOCATION_SYSMEM)
     {
         if (++surface->lockCount > MAXLOCKCOUNT)
         {
@@ -3079,130 +2892,48 @@ HRESULT CDECL wined3d_surface_map(struct wined3d_surface *surface,
         }
     }
 
-    surface_prepare_map_memory(surface);
-    if (flags & WINED3D_MAP_DISCARD)
-    {
-        TRACE("WINED3D_MAP_DISCARD flag passed, marking %s as up to date.\n",
-                wined3d_debug_location(surface->map_binding));
-        surface_validate_location(surface, surface->map_binding);
-    }
-    else
+    if (rect)
     {
-        if (surface->resource.usage & WINED3DUSAGE_DYNAMIC)
-            WARN_(d3d_perf)("Mapping a dynamic surface without WINED3D_MAP_DISCARD.\n");
-
-        surface_load_location(surface, surface->map_binding);
+        box.left = rect->left;
+        box.top = rect->top;
+        box.front = 0;
+        box.right = rect->right;
+        box.bottom = rect->bottom;
+        box.back = 1;
     }
 
-    if (!(flags & (WINED3D_MAP_NO_DIRTY_UPDATE | WINED3D_MAP_READONLY)))
-        surface_invalidate_location(surface, ~surface->map_binding);
+    return wined3d_resource_map(&surface->resource, map_desc, rect ? &box : NULL, flags);
+}
 
-    switch (surface->map_binding)
-    {
-        case WINED3D_LOCATION_SYSMEM:
-            base_memory = surface->resource.heap_memory;
-            break;
+void wined3d_surface_getdc_cs(struct wined3d_surface *surface)
+{
+    struct wined3d_device *device = surface->resource.device;
+    struct wined3d_context *context = NULL;
 
-        case WINED3D_LOCATION_USER_MEMORY:
-            base_memory = surface->user_memory;
-            break;
-
-        case WINED3D_LOCATION_DIB:
-            base_memory = surface->dib.bitmap_data;
-            break;
-
-        case WINED3D_LOCATION_BUFFER:
-            context = context_acquire(device, NULL);
-            gl_info = context->gl_info;
-
-            GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, surface->pbo));
-            base_memory = GL_EXTCALL(glMapBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, GL_READ_WRITE_ARB));
-            GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, 0));
-            checkGLcall("map PBO");
-
-            context_release(context);
-            break;
-
-        default:
-            ERR("Unexpected map binding %s.\n", wined3d_debug_location(surface->map_binding));
-            base_memory = NULL;
-    }
-
-    if (format->flags & WINED3DFMT_FLAG_BROKEN_PITCH)
-        map_desc->row_pitch = surface->resource.width * format->byte_count;
-    else
-        map_desc->row_pitch = wined3d_surface_get_pitch(surface);
-    map_desc->slice_pitch = 0;
-
-    if (!rect)
-    {
-        map_desc->data = base_memory;
-        surface->lockedRect.left = 0;
-        surface->lockedRect.top = 0;
-        surface->lockedRect.right = surface->resource.width;
-        surface->lockedRect.bottom = surface->resource.height;
-    }
-    else
-    {
-        if ((format->flags & (WINED3DFMT_FLAG_BLOCKS | WINED3DFMT_FLAG_BROKEN_PITCH)) == WINED3DFMT_FLAG_BLOCKS)
-        {
-            /* Compressed textures are block based, so calculate the offset of
-             * the block that contains the top-left pixel of the locked rectangle. */
-            map_desc->data = base_memory
-                    + ((rect->top / format->block_height) * map_desc->row_pitch)
-                    + ((rect->left / format->block_width) * format->block_byte_count);
-        }
-        else
-        {
-            map_desc->data = base_memory
-                    + (map_desc->row_pitch * rect->top)
-                    + (rect->left * format->byte_count);
-        }
-        surface->lockedRect.left = rect->left;
-        surface->lockedRect.top = rect->top;
-        surface->lockedRect.right = rect->right;
-        surface->lockedRect.bottom = rect->bottom;
-    }
-
-    TRACE("Locked rect %s.\n", wine_dbgstr_rect(&surface->lockedRect));
-    TRACE("Returning memory %p, pitch %u.\n", map_desc->data, map_desc->row_pitch);
-
-    return WINED3D_OK;
-}
-
-HRESULT CDECL wined3d_surface_getdc(struct wined3d_surface *surface, HDC *dc)
-{
-    HRESULT hr;
-
-    TRACE("surface %p, dc %p.\n", surface, dc);
-
-    /* Give more detailed info for ddraw. */
-    if (surface->flags & SFLAG_DCINUSE)
-        return WINEDDERR_DCALREADYCREATED;
-
-    /* Can't GetDC if the surface is locked. */
-    if (surface->resource.map_count)
-        return WINED3DERR_INVALIDCALL;
+    if (device->d3d_initialized)
+        context = context_acquire(surface->resource.device, NULL);
 
     /* Create a DIB section if there isn't a dc yet. */
     if (!surface->hDC)
     {
-        if (surface->flags & SFLAG_CLIENT)
+        HRESULT hr = surface_create_dib_section(surface);
+        if (FAILED(hr))
         {
-            surface_load_location(surface, WINED3D_LOCATION_SYSMEM);
-            surface_release_client_storage(surface);
+            if (context)
+                context_release(context);
+            return;
         }
-        hr = surface_create_dib_section(surface);
-        if (FAILED(hr))
-            return WINED3DERR_INVALIDCALL;
-        if (!(surface->map_binding == WINED3D_LOCATION_USER_MEMORY
+        if (!(surface->resource.map_binding == WINED3D_LOCATION_USER_MEMORY
                 || surface->flags & SFLAG_PIN_SYSMEM
-                || surface->pbo))
-            surface->map_binding = WINED3D_LOCATION_DIB;
+                || surface->resource.buffer))
+            surface->resource.map_binding = WINED3D_LOCATION_DIB;
     }
 
-    surface_load_location(surface, WINED3D_LOCATION_DIB);
-    surface_invalidate_location(surface, ~WINED3D_LOCATION_DIB);
+    wined3d_resource_load_location(&surface->resource, context, WINED3D_LOCATION_DIB);
+    wined3d_resource_invalidate_location(&surface->resource, ~WINED3D_LOCATION_DIB);
+
+    if (context)
+        context_release(context);
 
     if (surface->resource.format->id == WINED3DFMT_P8_UINT
             || surface->resource.format->id == WINED3DFMT_P8_UINT_A8_UNORM)
@@ -3240,14 +2971,50 @@ HRESULT CDECL wined3d_surface_getdc(struct wined3d_surface *surface, HDC *dc)
             SetDIBColorTable(surface->hDC, 0, 256, col);
         }
     }
+}
+
+HRESULT CDECL wined3d_surface_getdc(struct wined3d_surface *surface, HDC *dc)
+{
+    struct wined3d_device *device = surface->resource.device;
+
+    TRACE("surface %p, dc %p.\n", surface, dc);
+
+    if (!(surface->resource.format->flags & WINED3DFMT_FLAG_GETDC))
+    {
+        WARN("Cannot use GetDC on a %s surface.\n", debug_d3dformat(surface->resource.format->id));
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    /* Give more detailed info for ddraw. */
+    if (surface->flags & SFLAG_DCINUSE)
+        return WINEDDERR_DCALREADYCREATED;
+
+    /* Can't GetDC if the surface is locked. */
+    if (surface->resource.map_count)
+        return WINED3DERR_INVALIDCALL;
 
     surface->flags |= SFLAG_DCINUSE;
     surface->resource.map_count++;
-
+    wined3d_cs_emit_getdc(device->cs, surface);
     *dc = surface->hDC;
     TRACE("Returning dc %p.\n", *dc);
 
-    return WINED3D_OK;
+    return *dc ? WINED3D_OK : WINED3DERR_INVALIDCALL;
+}
+
+void wined3d_surface_releasedc_cs(struct wined3d_surface *surface)
+{
+    if (surface->resource.map_binding == WINED3D_LOCATION_USER_MEMORY)
+    {
+        struct wined3d_device *device = surface->resource.device;
+        struct wined3d_context *context = NULL;
+
+        if (device->d3d_initialized)
+            context = context_acquire(device, NULL);
+        wined3d_resource_load_location(&surface->resource, context, WINED3D_LOCATION_USER_MEMORY);
+        if (context)
+            context_release(context);
+    }
 }
 
 HRESULT CDECL wined3d_surface_releasedc(struct wined3d_surface *surface, HDC dc)
@@ -3267,17 +3034,18 @@ HRESULT CDECL wined3d_surface_releasedc(struct wined3d_surface *surface, HDC dc)
     surface->resource.map_count--;
     surface->flags &= ~SFLAG_DCINUSE;
 
-    if (surface->map_binding == WINED3D_LOCATION_USER_MEMORY)
-        surface_load_location(surface, WINED3D_LOCATION_USER_MEMORY);
+    wined3d_cs_emit_releasedc(surface->resource.device->cs, surface);
 
     return WINED3D_OK;
 }
 
-static void read_from_framebuffer(struct wined3d_surface *surface, DWORD dst_location)
+static void read_from_framebuffer(struct wined3d_surface *surface, 
+        struct wined3d_context *old_ctx, DWORD dst_location)
 {
     struct wined3d_device *device = surface->resource.device;
     const struct wined3d_gl_info *gl_info;
     struct wined3d_context *context;
+    struct wined3d_surface *restore_rt;
     BYTE *mem;
     GLint fmt;
     GLint type;
@@ -3286,11 +3054,26 @@ static void read_from_framebuffer(struct wined3d_surface *surface, DWORD dst_loc
     BOOL bpp;
     BOOL srcIsUpsideDown;
     struct wined3d_bo_address data;
-    UINT pitch = wined3d_surface_get_pitch(surface);
+    UINT pitch, slice_pitch;
 
-    surface_get_memory(surface, &data, dst_location);
+    wined3d_resource_get_pitch(&surface->resource, &pitch, &slice_pitch);
+    wined3d_resource_get_memory(&surface->resource, dst_location, &data);
+
+    /* Context_release does not restore the original context in case of
+     * nested context_acquire calls. Only read_from_framebuffer and
+     * surface_blt_to_drawable use nested context_acquire calls. Manually
+     * restore the original context at the end of the function if needed. */
+    if (old_ctx->current_rt == surface)
+    {
+        restore_rt = NULL;
+        context = old_ctx;
+    }
+    else
+    {
+        restore_rt = old_ctx->current_rt;
+        context = context_acquire(device, surface);
+    }
 
-    context = context_acquire(device, surface);
     context_apply_blit_state(context, device);
     gl_info = context->gl_info;
 
@@ -3477,6 +3260,13 @@ static void read_from_framebuffer(struct wined3d_surface *surface, DWORD dst_loc
         }
         HeapFree(GetProcessHeap(), 0, mem);
     }
+
+    if (restore_rt)
+    {
+        context_release(context);
+        context = context_acquire(device, restore_rt);
+        context_release(context);
+    }
 }
 
 /* Read the framebuffer contents into a texture. Note that this function
@@ -3798,83 +3588,6 @@ static HRESULT d3dfmt_convert_surface(const BYTE *src, BYTE *dst, UINT pitch, UI
     return WINED3D_OK;
 }
 
-void flip_surface(struct wined3d_surface *front, struct wined3d_surface *back)
-{
-    if (front->container->level_count != 1 || front->container->layer_count != 1
-            || back->container->level_count != 1 || back->container->layer_count != 1)
-        ERR("Flip between surfaces %p and %p not supported.\n", front, back);
-
-    /* Flip the surface contents */
-    /* Flip the DC */
-    {
-        HDC tmp;
-        tmp = front->hDC;
-        front->hDC = back->hDC;
-        back->hDC = tmp;
-    }
-
-    /* Flip the DIBsection */
-    {
-        HBITMAP tmp = front->dib.DIBsection;
-        front->dib.DIBsection = back->dib.DIBsection;
-        back->dib.DIBsection = tmp;
-    }
-
-    /* Flip the surface data */
-    {
-        void* tmp;
-
-        tmp = front->dib.bitmap_data;
-        front->dib.bitmap_data = back->dib.bitmap_data;
-        back->dib.bitmap_data = tmp;
-
-        tmp = front->resource.heap_memory;
-        front->resource.heap_memory = back->resource.heap_memory;
-        back->resource.heap_memory = tmp;
-    }
-
-    /* Flip the PBO */
-    {
-        GLuint tmp_pbo = front->pbo;
-        front->pbo = back->pbo;
-        back->pbo = tmp_pbo;
-    }
-
-    /* Flip the opengl texture */
-    {
-        GLuint tmp;
-
-        tmp = back->container->texture_rgb.name;
-        back->container->texture_rgb.name = front->container->texture_rgb.name;
-        front->container->texture_rgb.name = tmp;
-
-        tmp = back->container->texture_srgb.name;
-        back->container->texture_srgb.name = front->container->texture_srgb.name;
-        front->container->texture_srgb.name = tmp;
-
-        tmp = back->rb_multisample;
-        back->rb_multisample = front->rb_multisample;
-        front->rb_multisample = tmp;
-
-        tmp = back->rb_resolved;
-        back->rb_resolved = front->rb_resolved;
-        front->rb_resolved = tmp;
-
-        resource_unload(&back->resource);
-        resource_unload(&front->resource);
-    }
-
-    {
-        DWORD tmp_flags = back->flags;
-        back->flags = front->flags;
-        front->flags = tmp_flags;
-
-        tmp_flags = back->locations;
-        back->locations = front->locations;
-        front->locations = tmp_flags;
-    }
-}
-
 /* Does a direct frame buffer -> texture copy. Stretching is done with single
  * pixel copy calls. */
 static void fb_copy_to_texture_direct(struct wined3d_surface *dst_surface, struct wined3d_surface *src_surface,
@@ -3981,8 +3694,8 @@ static void fb_copy_to_texture_direct(struct wined3d_surface *dst_surface, struc
 
     /* The texture is now most up to date - If the surface is a render target
      * and has a drawable, this path is never entered. */
-    surface_validate_location(dst_surface, WINED3D_LOCATION_TEXTURE_RGB);
-    surface_invalidate_location(dst_surface, ~WINED3D_LOCATION_TEXTURE_RGB);
+    wined3d_resource_validate_location(&dst_surface->resource, WINED3D_LOCATION_TEXTURE_RGB);
+    wined3d_resource_invalidate_location(&dst_surface->resource, ~WINED3D_LOCATION_TEXTURE_RGB);
 }
 
 /* Uses the hardware to stretch and flip the image */
@@ -4050,7 +3763,7 @@ static void fb_copy_to_texture_hwstretch(struct wined3d_surface *dst_surface, st
         checkGLcall("glEnable(texture_target)");
 
         /* For now invalidate the texture copy of the back buffer. Drawable and sysmem copy are untouched */
-        src_surface->locations &= ~WINED3D_LOCATION_TEXTURE_RGB;
+        wined3d_resource_invalidate_location(&src_surface->resource, WINED3D_LOCATION_TEXTURE_RGB);
     }
 
     /* Make sure that the top pixel is always above the bottom pixel, and keep a separate upside down flag
@@ -4247,15 +3960,17 @@ static void fb_copy_to_texture_hwstretch(struct wined3d_surface *dst_surface, st
         checkGLcall("glDeleteTextures(1, &backup)");
     }
 
-    if (wined3d_settings.strict_draw_ordering)
+    if (wined3d_settings.cs_multithreaded)
+        gl_info->gl_ops.gl.p_glFinish();
+    else if (wined3d_settings.strict_draw_ordering)
         gl_info->gl_ops.gl.p_glFlush(); /* Flush to ensure ordering across contexts. */
 
     context_release(context);
 
     /* The texture is now most up to date - If the surface is a render target
      * and has a drawable, this path is never entered. */
-    surface_validate_location(dst_surface, WINED3D_LOCATION_TEXTURE_RGB);
-    surface_invalidate_location(dst_surface, ~WINED3D_LOCATION_TEXTURE_RGB);
+    wined3d_resource_validate_location(&dst_surface->resource, WINED3D_LOCATION_TEXTURE_RGB);
+    wined3d_resource_invalidate_location(&dst_surface->resource, ~WINED3D_LOCATION_TEXTURE_RGB);
 }
 
 /* Front buffer coordinates are always full screen coordinates, but our GL
@@ -4286,24 +4001,40 @@ void surface_translate_drawable_coords(const struct wined3d_surface *surface, HW
     rect->bottom = drawable_height - rect->bottom;
 }
 
+/* Context activation is done by the caller. */
 static void surface_blt_to_drawable(const struct wined3d_device *device,
+        struct wined3d_context *old_ctx,
         enum wined3d_texture_filter_type filter, BOOL alpha_test,
         struct wined3d_surface *src_surface, const RECT *src_rect_in,
         struct wined3d_surface *dst_surface, const RECT *dst_rect_in)
 {
     const struct wined3d_gl_info *gl_info;
     struct wined3d_context *context;
+    struct wined3d_surface *restore_rt;
     RECT src_rect, dst_rect;
 
     src_rect = *src_rect_in;
     dst_rect = *dst_rect_in;
 
-    context = context_acquire(device, dst_surface);
+    /* Context_release does not restore the original context in case of
+     * nested context_acquire calls. Only read_from_framebuffer and
+     * surface_blt_to_drawable use nested context_acquire calls. Manually
+     * restore the original context at the end of the function if needed. */
+    if (old_ctx->current_rt == dst_surface)
+    {
+        restore_rt = NULL;
+        context = old_ctx;
+    }
+    else
+    {
+        restore_rt = old_ctx->current_rt;
+        context = context_acquire(device, dst_surface);
+    }
     gl_info = context->gl_info;
 
     /* Make sure the surface is up-to-date. This should probably use
-     * surface_load_location() and worry about the destination surface too,
-     * unless we're overwriting it completely. */
+     * wined3d_resource_load_location() and worry about the destination
+     * surface too, unless we're overwriting it completely. */
     wined3d_texture_load(src_surface->container, context, FALSE);
 
     /* Activate the destination context, set it up for blitting */
@@ -4347,11 +4078,18 @@ static void surface_blt_to_drawable(const struct wined3d_device *device,
     /* Leave the opengl state valid for blitting */
     device->blitter->unset_shader(context->gl_info);
 
-    if (wined3d_settings.strict_draw_ordering
+    if (wined3d_settings.cs_multithreaded)
+        gl_info->gl_ops.gl.p_glFinish();
+    else if (wined3d_settings.strict_draw_ordering
             || (dst_surface->swapchain && dst_surface->swapchain->front_buffer == dst_surface))
         gl_info->gl_ops.gl.p_glFlush(); /* Flush to ensure ordering across contexts. */
 
-    context_release(context);
+    if (restore_rt)
+    {
+        context_release(context);
+        context = context_acquire(device, restore_rt);
+        context_release(context);
+    }
 }
 
 HRESULT surface_color_fill(struct wined3d_surface *s, const RECT *rect, const struct wined3d_color *color)
@@ -4377,6 +4115,7 @@ static HRESULT surface_blt_special(struct wined3d_surface *dst_surface, const RE
     struct wined3d_device *device = dst_surface->resource.device;
     const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
     struct wined3d_swapchain *src_swapchain, *dst_swapchain;
+    const struct wined3d_fb_state *fb = &device->state.fb;
 
     TRACE("dst_surface %p, dst_rect %s, src_surface %p, src_rect %s, flags %#x, blt_fx %p, filter %s.\n",
             dst_surface, wine_dbgstr_rect(dst_rect), src_surface, wine_dbgstr_rect(src_rect),
@@ -4408,8 +4147,8 @@ static HRESULT surface_blt_special(struct wined3d_surface *dst_surface, const RE
 
     /* Early sort out of cases where no render target is used */
     if (!dst_swapchain && !src_swapchain
-            && src_surface != device->fb.render_targets[0]
-            && dst_surface != device->fb.render_targets[0])
+            && src_surface != fb->render_targets[0]
+            && dst_surface != fb->render_targets[0])
     {
         TRACE("No surface is render target, not using hardware blit.\n");
         return WINED3DERR_INVALIDCALL;
@@ -4438,16 +4177,16 @@ static HRESULT surface_blt_special(struct wined3d_surface *dst_surface, const RE
     if (dst_swapchain)
     {
         /* Handled with regular texture -> swapchain blit */
-        if (src_surface == device->fb.render_targets[0])
+        if (src_surface == fb->render_targets[0])
             TRACE("Blit from active render target to a swapchain\n");
     }
-    else if (src_swapchain && dst_surface == device->fb.render_targets[0])
+    else if (src_swapchain && dst_surface == fb->render_targets[0])
     {
         FIXME("Implement blit from a swapchain to the active render target\n");
         return WINED3DERR_INVALIDCALL;
     }
 
-    if ((src_swapchain || src_surface == device->fb.render_targets[0]) && !dst_swapchain)
+    if ((src_swapchain || src_surface == fb->render_targets[0]) && !dst_swapchain)
     {
         /* Blit from render target to texture */
         BOOL stretchx;
@@ -4503,6 +4242,7 @@ static HRESULT surface_blt_special(struct wined3d_surface *dst_surface, const RE
         /* Blit from offscreen surface to render target */
         struct wined3d_color_key old_blt_key = src_surface->container->src_blt_color_key;
         DWORD old_color_key_flags = src_surface->container->color_key_flags;
+        struct wined3d_context *context;
 
         TRACE("Blt from surface %p to rendertarget %p\n", src_surface, dst_surface);
 
@@ -4537,16 +4277,18 @@ static HRESULT surface_blt_special(struct wined3d_surface *dst_surface, const RE
             src_surface->container->color_key_flags &= ~WINEDDSD_CKSRCBLT;
         }
 
-        surface_blt_to_drawable(device, filter,
+        context = context_acquire(device, dst_surface);
+        surface_blt_to_drawable(device, context, filter,
                 flags & (WINEDDBLT_KEYSRC | WINEDDBLT_KEYSRCOVERRIDE | WINEDDBLT_ALPHATEST),
                 src_surface, src_rect, dst_surface, dst_rect);
+        context_release(context);
 
         /* Restore the color key parameters */
         src_surface->container->color_key_flags = old_color_key_flags;
         src_surface->container->src_blt_color_key = old_blt_key;
 
-        surface_validate_location(dst_surface, dst_surface->draw_binding);
-        surface_invalidate_location(dst_surface, ~dst_surface->draw_binding);
+        wined3d_resource_validate_location(&dst_surface->resource, dst_surface->draw_binding);
+        wined3d_resource_invalidate_location(&dst_surface->resource, ~dst_surface->draw_binding);
 
         return WINED3D_OK;
     }
@@ -4621,13 +4363,14 @@ void surface_modify_ds_location(struct wined3d_surface *surface,
 {
     TRACE("surface %p, new location %#x, w %u, h %u.\n", surface, location, w, h);
 
-    if (((surface->locations & WINED3D_LOCATION_TEXTURE_RGB) && !(location & WINED3D_LOCATION_TEXTURE_RGB))
-            || (!(surface->locations & WINED3D_LOCATION_TEXTURE_RGB) && (location & WINED3D_LOCATION_TEXTURE_RGB)))
+    if (((surface->resource.locations & WINED3D_LOCATION_TEXTURE_RGB) && !(location & WINED3D_LOCATION_TEXTURE_RGB))
+            || (!(surface->resource.locations & WINED3D_LOCATION_TEXTURE_RGB)
+            && (location & WINED3D_LOCATION_TEXTURE_RGB)))
         wined3d_texture_set_dirty(surface->container);
 
     surface->ds_current_size.cx = w;
     surface->ds_current_size.cy = h;
-    surface->locations = location;
+    surface->resource.locations = location;
 }
 
 /* Context activation is done by the caller. */
@@ -4642,7 +4385,7 @@ void surface_load_ds_location(struct wined3d_surface *surface, struct wined3d_co
     /* TODO: Make this work for modes other than FBO */
     if (wined3d_settings.offscreen_rendering_mode != ORM_FBO) return;
 
-    if (!(surface->locations & location))
+    if (!(surface->resource.locations & location))
     {
         w = surface->ds_current_size.cx;
         h = surface->ds_current_size.cy;
@@ -4668,7 +4411,7 @@ void surface_load_ds_location(struct wined3d_surface *surface, struct wined3d_co
         return;
     }
 
-    if (surface->locations & WINED3D_LOCATION_DISCARDED)
+    if (surface->resource.locations & WINED3D_LOCATION_DISCARDED)
     {
         TRACE("Surface was discarded, no need copy data.\n");
         switch (location)
@@ -4685,17 +4428,17 @@ void surface_load_ds_location(struct wined3d_surface *surface, struct wined3d_co
             default:
                 FIXME("Unhandled location %#x\n", location);
         }
-        surface->locations &= ~WINED3D_LOCATION_DISCARDED;
-        surface->locations |= location;
+        surface->resource.locations &= ~WINED3D_LOCATION_DISCARDED;
+        surface->resource.locations |= location;
         surface->ds_current_size.cx = surface->resource.width;
         surface->ds_current_size.cy = surface->resource.height;
         return;
     }
 
-    if (!surface->locations)
+    if (!surface->resource.locations)
     {
         FIXME("No up to date depth stencil location.\n");
-        surface->locations |= location;
+        surface->resource.locations |= location;
         surface->ds_current_size.cx = surface->resource.width;
         surface->ds_current_size.cy = surface->resource.height;
         return;
@@ -4759,7 +4502,9 @@ void surface_load_ds_location(struct wined3d_surface *surface, struct wined3d_co
 
         context_invalidate_state(context, STATE_FRAMEBUFFER);
 
-        if (wined3d_settings.strict_draw_ordering)
+        if (wined3d_settings.cs_multithreaded)
+            gl_info->gl_ops.gl.p_glFinish();
+        else if (wined3d_settings.strict_draw_ordering)
             gl_info->gl_ops.gl.p_glFlush(); /* Flush to ensure ordering across contexts. */
     }
     else if (location == WINED3D_LOCATION_DRAWABLE)
@@ -4774,7 +4519,9 @@ void surface_load_ds_location(struct wined3d_surface *surface, struct wined3d_co
 
         context_invalidate_state(context, STATE_FRAMEBUFFER);
 
-        if (wined3d_settings.strict_draw_ordering)
+        if (wined3d_settings.cs_multithreaded)
+            gl_info->gl_ops.gl.p_glFinish();
+        else if (wined3d_settings.strict_draw_ordering)
             gl_info->gl_ops.gl.p_glFlush(); /* Flush to ensure ordering across contexts. */
     }
     else
@@ -4782,134 +4529,52 @@ void surface_load_ds_location(struct wined3d_surface *surface, struct wined3d_co
         ERR("Invalid location (%#x) specified.\n", location);
     }
 
-    surface->locations |= location;
+    surface->resource.locations |= location;
     surface->ds_current_size.cx = surface->resource.width;
     surface->ds_current_size.cy = surface->resource.height;
 }
 
-void surface_validate_location(struct wined3d_surface *surface, DWORD location)
-{
-    TRACE("surface %p, location %s.\n", surface, wined3d_debug_location(location));
-
-    surface->locations |= location;
-}
-
-void surface_invalidate_location(struct wined3d_surface *surface, DWORD location)
-{
-    TRACE("surface %p, location %s.\n", surface, wined3d_debug_location(location));
-
-    if (location & (WINED3D_LOCATION_TEXTURE_RGB | WINED3D_LOCATION_TEXTURE_SRGB))
-        wined3d_texture_set_dirty(surface->container);
-    surface->locations &= ~location;
-
-    if (!surface->locations)
-        ERR("Surface %p does not have any up to date location.\n", surface);
-}
-
-static DWORD resource_access_from_location(DWORD location)
-{
-    switch (location)
-    {
-        case WINED3D_LOCATION_SYSMEM:
-        case WINED3D_LOCATION_USER_MEMORY:
-        case WINED3D_LOCATION_DIB:
-        case WINED3D_LOCATION_BUFFER:
-            return WINED3D_RESOURCE_ACCESS_CPU;
-
-        case WINED3D_LOCATION_DRAWABLE:
-        case WINED3D_LOCATION_TEXTURE_SRGB:
-        case WINED3D_LOCATION_TEXTURE_RGB:
-        case WINED3D_LOCATION_RB_MULTISAMPLE:
-        case WINED3D_LOCATION_RB_RESOLVED:
-            return WINED3D_RESOURCE_ACCESS_GPU;
-
-        default:
-            FIXME("Unhandled location %#x.\n", location);
-            return 0;
-    }
-}
-
-static void surface_copy_simple_location(struct wined3d_surface *surface, DWORD location)
-{
-    struct wined3d_device *device = surface->resource.device;
-    struct wined3d_context *context;
-    const struct wined3d_gl_info *gl_info;
-    struct wined3d_bo_address dst, src;
-    UINT size = surface->resource.size;
-
-    surface_get_memory(surface, &dst, location);
-    surface_get_memory(surface, &src, surface->locations);
-
-    if (dst.buffer_object)
-    {
-        context = context_acquire(device, NULL);
-        gl_info = context->gl_info;
-        GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, dst.buffer_object));
-        GL_EXTCALL(glBufferSubDataARB(GL_PIXEL_UNPACK_BUFFER_ARB, 0, size, src.addr));
-        GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, 0));
-        checkGLcall("Upload PBO");
-        context_release(context);
-        return;
-    }
-    if (src.buffer_object)
-    {
-        context = context_acquire(device, NULL);
-        gl_info = context->gl_info;
-        GL_EXTCALL(glBindBufferARB(GL_PIXEL_PACK_BUFFER_ARB, src.buffer_object));
-        GL_EXTCALL(glGetBufferSubDataARB(GL_PIXEL_PACK_BUFFER_ARB, 0, size, dst.addr));
-        GL_EXTCALL(glBindBufferARB(GL_PIXEL_PACK_BUFFER_ARB, 0));
-        checkGLcall("Download PBO");
-        context_release(context);
-        return;
-    }
-    memcpy(dst.addr, src.addr, size);
-}
-
+/* Context activation is done by the caller. */
 static void surface_load_sysmem(struct wined3d_surface *surface,
-        const struct wined3d_gl_info *gl_info, DWORD dst_location)
+        struct wined3d_context *context, DWORD dst_location)
 {
-    if (surface->locations & surface_simple_locations)
-    {
-        surface_copy_simple_location(surface, dst_location);
-        return;
-    }
+    const struct wined3d_gl_info *gl_info = context->gl_info;
 
-    if (surface->locations & (WINED3D_LOCATION_RB_MULTISAMPLE | WINED3D_LOCATION_RB_RESOLVED))
-        surface_load_location(surface, WINED3D_LOCATION_TEXTURE_RGB);
+    if (surface->resource.locations & (WINED3D_LOCATION_RB_MULTISAMPLE | WINED3D_LOCATION_RB_RESOLVED))
+        wined3d_resource_load_location(&surface->resource, context, WINED3D_LOCATION_TEXTURE_RGB);
 
     /* Download the surface to system memory. */
-    if (surface->locations & (WINED3D_LOCATION_TEXTURE_RGB | WINED3D_LOCATION_TEXTURE_SRGB))
+    if (surface->resource.locations & (WINED3D_LOCATION_TEXTURE_RGB | WINED3D_LOCATION_TEXTURE_SRGB))
     {
-        struct wined3d_device *device = surface->resource.device;
-        struct wined3d_context *context;
-
-        /* TODO: Use already acquired context when possible. */
-        context = context_acquire(device, NULL);
-
         wined3d_texture_bind_and_dirtify(surface->container, context,
-                !(surface->locations & WINED3D_LOCATION_TEXTURE_RGB));
+                !(surface->resource.locations & WINED3D_LOCATION_TEXTURE_RGB));
         surface_download_data(surface, gl_info, dst_location);
 
-        context_release(context);
-
         return;
     }
 
-    if (surface->locations & WINED3D_LOCATION_DRAWABLE)
+    if (surface->resource.locations & WINED3D_LOCATION_DRAWABLE)
     {
-        read_from_framebuffer(surface, dst_location);
+        read_from_framebuffer(surface, context, dst_location);
         return;
     }
 
     FIXME("Can't load surface %p with location flags %s into sysmem.\n",
-            surface, wined3d_debug_location(surface->locations));
+            surface, wined3d_debug_location(surface->resource.locations));
 }
 
+/* Context activation is done by the caller. */
 static HRESULT surface_load_drawable(struct wined3d_surface *surface,
-        const struct wined3d_gl_info *gl_info)
+        struct wined3d_context *context)
 {
     RECT r;
 
+    if (surface->resource.locations & WINED3D_LOCATION_DISCARDED)
+    {
+        TRACE("Surface was discarded, nothing to do.\n");
+        return WINED3D_OK;
+    }
+
     if (wined3d_settings.offscreen_rendering_mode == ORM_FBO && surface_is_offscreen(surface))
     {
         ERR("Trying to load offscreen surface into WINED3D_LOCATION_DRAWABLE.\n");
@@ -4917,63 +4582,73 @@ static HRESULT surface_load_drawable(struct wined3d_surface *surface,
     }
 
     surface_get_rect(surface, NULL, &r);
-    surface_load_location(surface, WINED3D_LOCATION_TEXTURE_RGB);
-    surface_blt_to_drawable(surface->resource.device,
+    wined3d_resource_load_location(&surface->resource, context, WINED3D_LOCATION_TEXTURE_RGB);
+    surface_blt_to_drawable(surface->resource.device, context,
             WINED3D_TEXF_POINT, FALSE, surface, &r, surface, &r);
 
     return WINED3D_OK;
 }
 
 static HRESULT surface_load_texture(struct wined3d_surface *surface,
-        const struct wined3d_gl_info *gl_info, BOOL srgb)
+        struct wined3d_context *context, BOOL srgb)
 {
+    const struct wined3d_gl_info *gl_info = context->gl_info;
     RECT src_rect = {0, 0, surface->resource.width, surface->resource.height};
     struct wined3d_device *device = surface->resource.device;
     enum wined3d_conversion_type convert;
-    struct wined3d_context *context;
-    UINT width, src_pitch, dst_pitch;
+    UINT width, src_row_pitch, src_slice_pitch, dst_pitch;
     struct wined3d_bo_address data;
     struct wined3d_format format;
     POINT dst_point = {0, 0};
     BYTE *mem = NULL;
+    const DWORD simple_locations =
+            WINED3D_LOCATION_SYSMEM | WINED3D_LOCATION_USER_MEMORY
+            | WINED3D_LOCATION_DIB | WINED3D_LOCATION_BUFFER;
+
+    if (surface->resource.locations & WINED3D_LOCATION_DISCARDED)
+    {
+        TRACE("Surface was discarded, nothing to do.\n");
+        surface_prepare_texture(surface, context, srgb);
+        return WINED3D_OK;
+    }
 
     if (wined3d_settings.offscreen_rendering_mode != ORM_FBO
             && surface_is_offscreen(surface)
-            && (surface->locations & WINED3D_LOCATION_DRAWABLE))
+            && (surface->resource.locations & WINED3D_LOCATION_DRAWABLE))
     {
         surface_load_fb_texture(surface, srgb);
 
         return WINED3D_OK;
     }
 
-    if (surface->locations & (WINED3D_LOCATION_TEXTURE_SRGB | WINED3D_LOCATION_TEXTURE_RGB)
+    if (surface->resource.locations & (WINED3D_LOCATION_TEXTURE_SRGB | WINED3D_LOCATION_TEXTURE_RGB)
             && (surface->resource.format->flags & WINED3DFMT_FLAG_FBO_ATTACHABLE_SRGB)
             && fbo_blit_supported(gl_info, WINED3D_BLIT_OP_COLOR_BLIT,
                 NULL, surface->resource.usage, surface->resource.pool, surface->resource.format,
                 NULL, surface->resource.usage, surface->resource.pool, surface->resource.format))
     {
         if (srgb)
-            surface_blt_fbo(device, WINED3D_TEXF_POINT, surface, WINED3D_LOCATION_TEXTURE_RGB,
+            surface_blt_fbo(device, context, WINED3D_TEXF_POINT, surface, WINED3D_LOCATION_TEXTURE_RGB,
                     &src_rect, surface, WINED3D_LOCATION_TEXTURE_SRGB, &src_rect);
         else
-            surface_blt_fbo(device, WINED3D_TEXF_POINT, surface, WINED3D_LOCATION_TEXTURE_SRGB,
+            surface_blt_fbo(device, context, WINED3D_TEXF_POINT, surface, WINED3D_LOCATION_TEXTURE_SRGB,
                     &src_rect, surface, WINED3D_LOCATION_TEXTURE_RGB, &src_rect);
 
         return WINED3D_OK;
     }
 
-    if (surface->locations & (WINED3D_LOCATION_RB_MULTISAMPLE | WINED3D_LOCATION_RB_RESOLVED)
+    if (surface->resource.locations & (WINED3D_LOCATION_RB_MULTISAMPLE | WINED3D_LOCATION_RB_RESOLVED)
             && (!srgb || (surface->resource.format->flags & WINED3DFMT_FLAG_FBO_ATTACHABLE_SRGB))
             && fbo_blit_supported(gl_info, WINED3D_BLIT_OP_COLOR_BLIT,
                 NULL, surface->resource.usage, surface->resource.pool, surface->resource.format,
                 NULL, surface->resource.usage, surface->resource.pool, surface->resource.format))
     {
-        DWORD src_location = surface->locations & WINED3D_LOCATION_RB_RESOLVED ?
+        DWORD src_location = surface->resource.locations & WINED3D_LOCATION_RB_RESOLVED ?
                 WINED3D_LOCATION_RB_RESOLVED : WINED3D_LOCATION_RB_MULTISAMPLE;
         DWORD dst_location = srgb ? WINED3D_LOCATION_TEXTURE_SRGB : WINED3D_LOCATION_TEXTURE_RGB;
         RECT rect = {0, 0, surface->resource.width, surface->resource.height};
 
-        surface_blt_fbo(device, WINED3D_TEXF_POINT, surface, src_location,
+        surface_blt_fbo(device, context, WINED3D_TEXF_POINT, surface, src_location,
                 &rect, surface, dst_location, &rect);
 
         return WINED3D_OK;
@@ -4986,38 +4661,35 @@ static HRESULT surface_load_texture(struct wined3d_surface *surface,
 
     if (srgb)
     {
-        if ((surface->locations & (WINED3D_LOCATION_TEXTURE_RGB | surface->map_binding))
-                == WINED3D_LOCATION_TEXTURE_RGB)
+        if ((surface->resource.locations & (WINED3D_LOCATION_TEXTURE_RGB
+                | surface->resource.map_binding)) == WINED3D_LOCATION_TEXTURE_RGB)
         {
             /* Performance warning... */
             FIXME("Downloading RGB surface %p to reload it as sRGB.\n", surface);
-            surface_prepare_map_memory(surface);
-            surface_load_location(surface, surface->map_binding);
+            wined3d_resource_prepare_map_memory(&surface->resource, context);
+            wined3d_resource_load_location(&surface->resource, context, surface->resource.map_binding);
         }
     }
     else
     {
-        if ((surface->locations & (WINED3D_LOCATION_TEXTURE_SRGB | surface->map_binding))
-                == WINED3D_LOCATION_TEXTURE_SRGB)
+        if ((surface->resource.locations & (WINED3D_LOCATION_TEXTURE_SRGB
+                | surface->resource.map_binding)) == WINED3D_LOCATION_TEXTURE_SRGB)
         {
             /* Performance warning... */
             FIXME("Downloading sRGB surface %p to reload it as RGB.\n", surface);
-            surface_prepare_map_memory(surface);
-            surface_load_location(surface, surface->map_binding);
+            wined3d_resource_prepare_map_memory(&surface->resource, context);
+            wined3d_resource_load_location(&surface->resource, context, surface->resource.map_binding);
         }
     }
 
-    if (!(surface->locations & surface_simple_locations))
+    if (!(surface->resource.locations & simple_locations))
     {
         WARN("Trying to load a texture from sysmem, but no simple location is valid.\n");
         /* Lets hope we get it from somewhere... */
-        surface_prepare_system_memory(surface);
-        surface_load_location(surface, WINED3D_LOCATION_SYSMEM);
+        wined3d_resource_prepare_system_memory(&surface->resource);
+        wined3d_resource_load_location(&surface->resource, context, WINED3D_LOCATION_SYSMEM);
     }
 
-    /* TODO: Use already acquired context when possible. */
-    context = context_acquire(device, NULL);
-
     surface_prepare_texture(surface, context, srgb);
     wined3d_texture_bind_and_dirtify(surface->container, context, srgb);
 
@@ -5029,26 +4701,27 @@ static HRESULT surface_load_texture(struct wined3d_surface *surface,
     else surface->flags &= ~SFLAG_GLCKEY;
 
     width = surface->resource.width;
-    src_pitch = wined3d_surface_get_pitch(surface);
+    wined3d_resource_get_pitch(&surface->resource, &src_row_pitch, &src_slice_pitch);
 
     /* Don't use PBOs for converted surfaces. During PBO conversion we look at
      * SFLAG_CONVERTED but it isn't set (yet) in all cases it is getting
      * called. */
-    if ((convert != WINED3D_CT_NONE || format.convert) && surface->pbo)
+    if ((convert != WINED3D_CT_NONE || format.convert) && surface->resource.buffer)
     {
         TRACE("Removing the pbo attached to surface %p.\n", surface);
 
         if (surface->flags & SFLAG_DIBSECTION)
-            surface->map_binding = WINED3D_LOCATION_DIB;
+            surface->resource.map_binding = WINED3D_LOCATION_DIB;
         else
-            surface->map_binding = WINED3D_LOCATION_SYSMEM;
+            surface->resource.map_binding = WINED3D_LOCATION_SYSMEM;
 
-        surface_prepare_map_memory(surface);
-        surface_load_location(surface, surface->map_binding);
-        surface_remove_pbo(surface, gl_info);
+        wined3d_resource_prepare_map_memory(&surface->resource, context);
+        wined3d_resource_load_location(&surface->resource, context, surface->resource.map_binding);
+        wined3d_resource_free_bo(&surface->resource);
+        wined3d_resource_invalidate_location(&surface->resource, WINED3D_LOCATION_BUFFER);
     }
 
-    surface_get_memory(surface, &data, surface->locations);
+    wined3d_resource_get_memory(&surface->resource, surface->resource.locations, &data);
     if (format.convert)
     {
         /* This code is entered for texture formats which need a fixup. */
@@ -5064,10 +4737,10 @@ static HRESULT surface_load_texture(struct wined3d_surface *surface,
             context_release(context);
             return E_OUTOFMEMORY;
         }
-        format.convert(data.addr, mem, src_pitch, src_pitch * height,
+        format.convert(data.addr, mem, src_row_pitch, src_row_pitch * height,
                 dst_pitch, dst_pitch * height, width, height, 1);
         format.byte_count = format.conv_byte_count;
-        src_pitch = dst_pitch;
+        src_row_pitch = dst_pitch;
         data.addr = mem;
     }
     else if (convert != WINED3D_CT_NONE)
@@ -5085,38 +4758,38 @@ static HRESULT surface_load_texture(struct wined3d_surface *surface,
             context_release(context);
             return E_OUTOFMEMORY;
         }
-        d3dfmt_convert_surface(data.addr, mem, src_pitch,
+        d3dfmt_convert_surface(data.addr, mem, src_row_pitch,
                 width, height, dst_pitch, convert, surface);
         format.byte_count = format.conv_byte_count;
-        src_pitch = dst_pitch;
+        src_row_pitch = dst_pitch;
         data.addr = mem;
     }
 
-    surface_upload_data(surface, gl_info, &format, &src_rect, src_pitch, &dst_point, srgb, &data);
-
-    context_release(context);
+    surface_upload_data(surface, gl_info, &format, &src_rect, src_row_pitch, &dst_point, srgb, &data);
 
     HeapFree(GetProcessHeap(), 0, mem);
 
     return WINED3D_OK;
 }
 
-static void surface_multisample_resolve(struct wined3d_surface *surface)
+/* Context activation is done by the caller. */
+static void surface_multisample_resolve(struct wined3d_surface *surface, struct wined3d_context *context)
 {
     RECT rect = {0, 0, surface->resource.width, surface->resource.height};
 
-    if (!(surface->locations & WINED3D_LOCATION_RB_MULTISAMPLE))
+    if (!(surface->resource.locations & WINED3D_LOCATION_RB_MULTISAMPLE))
         ERR("Trying to resolve multisampled surface %p, but location WINED3D_LOCATION_RB_MULTISAMPLE not current.\n",
                 surface);
 
-    surface_blt_fbo(surface->resource.device, WINED3D_TEXF_POINT,
+    surface_blt_fbo(surface->resource.device, context, WINED3D_TEXF_POINT,
             surface, WINED3D_LOCATION_RB_MULTISAMPLE, &rect, surface, WINED3D_LOCATION_RB_RESOLVED, &rect);
 }
 
-HRESULT surface_load_location(struct wined3d_surface *surface, DWORD location)
+/* Context activation is done by the caller. */
+static void wined3d_surface_load_location(struct wined3d_resource *resource,
+        struct wined3d_context *context, DWORD location)
 {
-    struct wined3d_device *device = surface->resource.device;
-    const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
+    struct wined3d_surface *surface = surface_from_resource(resource);
     HRESULT hr;
 
     TRACE("surface %p, location %s.\n", surface, wined3d_debug_location(location));
@@ -5124,45 +4797,29 @@ HRESULT surface_load_location(struct wined3d_surface *surface, DWORD location)
     if (surface->resource.usage & WINED3DUSAGE_DEPTHSTENCIL)
     {
         if (location == WINED3D_LOCATION_TEXTURE_RGB
-                && surface->locations & (WINED3D_LOCATION_DRAWABLE | WINED3D_LOCATION_DISCARDED))
+                && surface->resource.locations & (WINED3D_LOCATION_DRAWABLE | WINED3D_LOCATION_DISCARDED))
         {
-            struct wined3d_context *context = context_acquire(device, NULL);
             surface_load_ds_location(surface, context, location);
-            context_release(context);
-            return WINED3D_OK;
+            return;
         }
-        else if (location & surface->locations && surface->draw_binding != WINED3D_LOCATION_DRAWABLE)
+        else if (location & surface->resource.locations && surface->draw_binding != WINED3D_LOCATION_DRAWABLE)
         {
             /* Already up to date, nothing to do. */
-            return WINED3D_OK;
+            return;
         }
         else
         {
             FIXME("Unimplemented copy from %s to %s for depth/stencil buffers.\n",
-                    wined3d_debug_location(surface->locations), wined3d_debug_location(location));
-            return WINED3DERR_INVALIDCALL;
+                    wined3d_debug_location(surface->resource.locations), wined3d_debug_location(location));
+            return;
         }
     }
 
-    if (surface->locations & location)
-    {
-        TRACE("Location already up to date.\n");
-        return WINED3D_OK;
-    }
-
-    if (WARN_ON(d3d_surface))
-    {
-        DWORD required_access = resource_access_from_location(location);
-        if ((surface->resource.access_flags & required_access) != required_access)
-            WARN("Operation requires %#x access, but surface only has %#x.\n",
-                    required_access, surface->resource.access_flags);
-    }
-
-    if (!surface->locations)
+    if (!surface->resource.locations)
     {
         ERR("Surface %p does not have any up to date location.\n", surface);
         surface->flags |= SFLAG_LOST;
-        return WINED3DERR_DEVICELOST;
+        return;
     }
 
     switch (location)
@@ -5171,22 +4828,23 @@ HRESULT surface_load_location(struct wined3d_surface *surface, DWORD location)
         case WINED3D_LOCATION_USER_MEMORY:
         case WINED3D_LOCATION_SYSMEM:
         case WINED3D_LOCATION_BUFFER:
-            surface_load_sysmem(surface, gl_info, location);
+            surface_load_sysmem(surface, context, location);
             break;
 
         case WINED3D_LOCATION_DRAWABLE:
-            if (FAILED(hr = surface_load_drawable(surface, gl_info)))
-                return hr;
+            if (FAILED(hr = surface_load_drawable(surface, context)))
+                return;
             break;
 
         case WINED3D_LOCATION_RB_RESOLVED:
-            surface_multisample_resolve(surface);
+            surface_multisample_resolve(surface, context);
             break;
 
         case WINED3D_LOCATION_TEXTURE_RGB:
         case WINED3D_LOCATION_TEXTURE_SRGB:
-            if (FAILED(hr = surface_load_texture(surface, gl_info, location == WINED3D_LOCATION_TEXTURE_SRGB)))
-                return hr;
+            if (FAILED(hr = surface_load_texture(surface, context,
+                    location == WINED3D_LOCATION_TEXTURE_SRGB)))
+                return;
             break;
 
         default:
@@ -5194,12 +4852,12 @@ HRESULT surface_load_location(struct wined3d_surface *surface, DWORD location)
             break;
     }
 
-    surface_validate_location(surface, location);
+    wined3d_resource_validate_location(&surface->resource, location);
 
-    if (location != WINED3D_LOCATION_SYSMEM && (surface->locations & WINED3D_LOCATION_SYSMEM))
+    if (location != WINED3D_LOCATION_SYSMEM && (surface->resource.locations & WINED3D_LOCATION_SYSMEM))
         surface_evict_sysmem(surface);
 
-    return WINED3D_OK;
+    return;
 }
 
 BOOL surface_is_offscreen(const struct wined3d_surface *surface)
@@ -5479,21 +5137,36 @@ static HRESULT surface_cpu_blt(struct wined3d_surface *dst_surface, const RECT *
     int bpp, srcheight, srcwidth, dstheight, dstwidth, width;
     const struct wined3d_format *src_format, *dst_format;
     struct wined3d_texture *src_texture = NULL;
-    struct wined3d_map_desc dst_map, src_map;
+    void *src_data = NULL, *dst_data = NULL;
+    UINT src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch;
     const BYTE *sbase = NULL;
     HRESULT hr = WINED3D_OK;
     const BYTE *sbuf;
     BYTE *dbuf;
     int x, y;
+    struct wined3d_device *device = dst_surface->resource.device;
+    struct wined3d_context *context = NULL;
 
     TRACE("dst_surface %p, dst_rect %s, src_surface %p, src_rect %s, flags %#x, fx %p, filter %s.\n",
             dst_surface, wine_dbgstr_rect(dst_rect), src_surface, wine_dbgstr_rect(src_rect),
             flags, fx, debug_d3dtexturefiltertype(filter));
 
+    if (device->d3d_initialized)
+        context = context_acquire(device, NULL);
+
+    if (!wined3d_resource_prepare_map_memory(&dst_surface->resource, context))
+    {
+        hr = E_OUTOFMEMORY;
+        goto error;
+    }
+    wined3d_resource_load_location(&dst_surface->resource, context, dst_surface->resource.map_binding);
+
     if (src_surface == dst_surface)
     {
-        wined3d_surface_map(dst_surface, &dst_map, NULL, 0);
-        src_map = dst_map;
+        dst_data = wined3d_resource_get_map_ptr(&dst_surface->resource, context, 0);
+        wined3d_resource_get_pitch(&dst_surface->resource, &dst_row_pitch, &dst_slice_pitch);
+        src_data = dst_data;
+        src_row_pitch = dst_row_pitch;
         src_format = dst_surface->resource.format;
         dst_format = src_format;
     }
@@ -5502,6 +5175,12 @@ static HRESULT surface_cpu_blt(struct wined3d_surface *dst_surface, const RECT *
         dst_format = dst_surface->resource.format;
         if (src_surface)
         {
+            if (!wined3d_resource_prepare_map_memory(&src_surface->resource, context))
+            {
+                hr = E_OUTOFMEMORY;
+                goto error;
+            }
+
             if (dst_surface->resource.format->id != src_surface->resource.format->id)
             {
                 if (!(src_texture = surface_convert_format(src_surface, dst_format->id)))
@@ -5512,7 +5191,9 @@ static HRESULT surface_cpu_blt(struct wined3d_surface *dst_surface, const RECT *
                 }
                 src_surface = surface_from_resource(wined3d_texture_get_sub_resource(src_texture, 0));
             }
-            wined3d_surface_map(src_surface, &src_map, NULL, WINED3D_MAP_READONLY);
+            wined3d_resource_load_location(&src_surface->resource, context, src_surface->resource.map_binding);
+            wined3d_resource_get_pitch(&src_surface->resource, &src_row_pitch, &src_slice_pitch);
+            src_data = wined3d_resource_get_map_ptr(&src_surface->resource, context, 0);
             src_format = src_surface->resource.format;
         }
         else
@@ -5520,7 +5201,8 @@ static HRESULT surface_cpu_blt(struct wined3d_surface *dst_surface, const RECT *
             src_format = dst_format;
         }
 
-        wined3d_surface_map(dst_surface, &dst_map, dst_rect, 0);
+        wined3d_resource_get_pitch(&dst_surface->resource, &dst_row_pitch, &dst_slice_pitch);
+        dst_data = wined3d_resource_get_map_ptr(&dst_surface->resource, context, 0);
     }
 
     bpp = dst_surface->resource.format->byte_count;
@@ -5531,15 +5213,12 @@ static HRESULT surface_cpu_blt(struct wined3d_surface *dst_surface, const RECT *
     width = (dst_rect->right - dst_rect->left) * bpp;
 
     if (src_surface)
-        sbase = (BYTE *)src_map.data
-                + ((src_rect->top / src_format->block_height) * src_map.row_pitch)
+        sbase = (BYTE *)src_data
+                + ((src_rect->top / src_format->block_height) * src_row_pitch)
                 + ((src_rect->left / src_format->block_width) * src_format->block_byte_count);
-    if (src_surface != dst_surface)
-        dbuf = dst_map.data;
-    else
-        dbuf = (BYTE *)dst_map.data
-                + ((dst_rect->top / dst_format->block_height) * dst_map.row_pitch)
-                + ((dst_rect->left / dst_format->block_width) * dst_format->block_byte_count);
+    dbuf = (BYTE *)dst_data
+            + ((dst_rect->top / dst_format->block_height) * dst_row_pitch)
+            + ((dst_rect->left / dst_format->block_width) * dst_format->block_byte_count);
 
     if (src_format->flags & dst_format->flags & WINED3DFMT_FLAG_BLOCKS)
     {
@@ -5574,7 +5253,7 @@ static HRESULT surface_cpu_blt(struct wined3d_surface *dst_surface, const RECT *
         }
 
         hr = surface_cpu_blt_compressed(sbase, dbuf,
-                src_map.row_pitch, dst_map.row_pitch, dstwidth, dstheight,
+                src_row_pitch, dst_row_pitch, dstwidth, dstheight,
                 src_format, flags, fx);
         goto release;
     }
@@ -5582,7 +5261,7 @@ static HRESULT surface_cpu_blt(struct wined3d_surface *dst_surface, const RECT *
     /* First, all the 'source-less' blits */
     if (flags & WINEDDBLT_COLORFILL)
     {
-        hr = _Blt_ColorFill(dbuf, dstwidth, dstheight, bpp, dst_map.row_pitch, fx->u5.dwFillColor);
+        hr = _Blt_ColorFill(dbuf, dstwidth, dstheight, bpp, dst_row_pitch, fx->u5.dwFillColor);
         flags &= ~WINEDDBLT_COLORFILL;
     }
 
@@ -5596,12 +5275,12 @@ static HRESULT surface_cpu_blt(struct wined3d_surface *dst_surface, const RECT *
         switch (fx->dwROP)
         {
             case BLACKNESS:
-                hr = _Blt_ColorFill(dbuf, dstwidth, dstheight, bpp, dst_map.row_pitch, 0);
+                hr = _Blt_ColorFill(dbuf, dstwidth, dstheight, bpp, dst_row_pitch, 0);
                 break;
             case 0xaa0029: /* No-op */
                 break;
             case WHITENESS:
-                hr = _Blt_ColorFill(dbuf, dstwidth, dstheight, bpp, dst_map.row_pitch, ~0U);
+                hr = _Blt_ColorFill(dbuf, dstwidth, dstheight, bpp, dst_row_pitch, ~0U);
                 break;
             case SRCCOPY: /* Well, we do that below? */
                 break;
@@ -5652,19 +5331,19 @@ static HRESULT surface_cpu_blt(struct wined3d_surface *dst_surface, const RECT *
                         for (y = 0; y < dstheight; ++y)
                         {
                             memcpy(dbuf, sbuf, width);
-                            sbuf += src_map.row_pitch;
-                            dbuf += dst_map.row_pitch;
+                            sbuf += src_row_pitch;
+                            dbuf += dst_row_pitch;
                         }
                     }
                     else if (dst_rect->top > src_rect->top)
                     {
                         /* Copy from bottom upwards. */
-                        sbuf += src_map.row_pitch * dstheight;
-                        dbuf += dst_map.row_pitch * dstheight;
+                        sbuf += src_row_pitch * dstheight;
+                        dbuf += dst_row_pitch * dstheight;
                         for (y = 0; y < dstheight; ++y)
                         {
-                            sbuf -= src_map.row_pitch;
-                            dbuf -= dst_map.row_pitch;
+                            sbuf -= src_row_pitch;
+                            dbuf -= dst_row_pitch;
                             memcpy(dbuf, sbuf, width);
                         }
                     }
@@ -5674,8 +5353,8 @@ static HRESULT surface_cpu_blt(struct wined3d_surface *dst_surface, const RECT *
                         for (y = 0; y < dstheight; ++y)
                         {
                             memmove(dbuf, sbuf, width);
-                            sbuf += src_map.row_pitch;
-                            dbuf += dst_map.row_pitch;
+                            sbuf += src_row_pitch;
+                            dbuf += dst_row_pitch;
                         }
                     }
                 }
@@ -5684,9 +5363,9 @@ static HRESULT surface_cpu_blt(struct wined3d_surface *dst_surface, const RECT *
                     /* Stretching in y direction only. */
                     for (y = sy = 0; y < dstheight; ++y, sy += yinc)
                     {
-                        sbuf = sbase + (sy >> 16) * src_map.row_pitch;
+                        sbuf = sbase + (sy >> 16) * src_row_pitch;
                         memcpy(dbuf, sbuf, width);
-                        dbuf += dst_map.row_pitch;
+                        dbuf += dst_row_pitch;
                     }
                 }
             }
@@ -5696,13 +5375,13 @@ static HRESULT surface_cpu_blt(struct wined3d_surface *dst_surface, const RECT *
                 int last_sy = -1;
                 for (y = sy = 0; y < dstheight; ++y, sy += yinc)
                 {
-                    sbuf = sbase + (sy >> 16) * src_map.row_pitch;
+                    sbuf = sbase + (sy >> 16) * src_row_pitch;
 
                     if ((sy >> 16) == (last_sy >> 16))
                     {
                         /* This source row is the same as last source row -
                          * Copy the already stretched row. */
-                        memcpy(dbuf, dbuf - dst_map.row_pitch, width);
+                        memcpy(dbuf, dbuf - dst_row_pitch, width);
                     }
                     else
                     {
@@ -5749,14 +5428,14 @@ do { \
                         }
 #undef STRETCH_ROW
                     }
-                    dbuf += dst_map.row_pitch;
+                    dbuf += dst_row_pitch;
                     last_sy = sy;
                 }
             }
         }
         else
         {
-            LONG dstyinc = dst_map.row_pitch, dstxinc = bpp;
+            LONG dstyinc = dst_row_pitch, dstxinc = bpp;
             DWORD keylow = 0xffffffff, keyhigh = 0, keymask = 0xffffffff;
             DWORD destkeylow = 0x0, destkeyhigh = 0xffffffff, destkeymask = 0xffffffff;
             if (flags & (WINEDDBLT_KEYSRC | WINEDDBLT_KEYDEST | WINEDDBLT_KEYSRCOVERRIDE | WINEDDBLT_KEYDESTOVERRIDE))
@@ -5806,7 +5485,7 @@ do { \
                 LONG tmpxy;
                 dTopLeft     = dbuf;
                 dTopRight    = dbuf + ((dstwidth - 1) * bpp);
-                dBottomLeft  = dTopLeft + ((dstheight - 1) * dst_map.row_pitch);
+                dBottomLeft  = dTopLeft + ((dstheight - 1) * dst_row_pitch);
                 dBottomRight = dBottomLeft + ((dstwidth - 1) * bpp);
 
                 if (fx->dwDDFX & WINEDDBLTFX_ARITHSTRETCHY)
@@ -5889,7 +5568,7 @@ do { \
     type *d = (type *)dbuf, *dx, tmp; \
     for (y = sy = 0; y < dstheight; ++y, sy += yinc) \
     { \
-        s = (const type *)(sbase + (sy >> 16) * src_map.row_pitch); \
+        s = (const type *)(sbase + (sy >> 16) * src_row_pitch); \
         dx = d; \
         for (x = sx = 0; x < dstwidth; ++x, sx += xinc) \
         { \
@@ -5922,7 +5601,7 @@ do { \
                     BYTE *d = dbuf, *dx;
                     for (y = sy = 0; y < dstheight; ++y, sy += yinc)
                     {
-                        sbuf = sbase + (sy >> 16) * src_map.row_pitch;
+                        sbuf = sbase + (sy >> 16) * src_row_pitch;
                         dx = d;
                         for (x = sx = 0; x < dstwidth; ++x, sx+= xinc)
                         {
@@ -5953,6 +5632,10 @@ do { \
         }
     }
 
+    wined3d_resource_invalidate_location(&dst_surface->resource, ~dst_surface->resource.map_binding);
+    if (dst_surface->container)
+        wined3d_texture_set_dirty(dst_surface->container);
+
 error:
     if (flags && FIXME_ON(d3d_surface))
     {
@@ -5960,12 +5643,20 @@ error:
     }
 
 release:
-    wined3d_surface_unmap(dst_surface);
-    if (src_surface && src_surface != dst_surface)
-        wined3d_surface_unmap(src_surface);
+    if (dst_data)
+    {
+        wined3d_resource_release_map_ptr(&dst_surface->resource, context);
+
+        if (dst_surface->swapchain && dst_surface == dst_surface->swapchain->front_buffer)
+            dst_surface->surface_ops->surface_frontbuffer_updated(dst_surface);
+    }
+    if (src_surface && src_surface != dst_surface && src_data)
+        wined3d_resource_release_map_ptr(&src_surface->resource, context);
     /* Release the converted surface, if any. */
     if (src_texture)
         wined3d_texture_decref(src_texture);
+    if (context)
+        context_release(context);
 
     return hr;
 }
@@ -6000,14 +5691,13 @@ const struct blit_shader cpu_blit =  {
     cpu_blit_depth_fill,
 };
 
-HRESULT CDECL wined3d_surface_blt(struct wined3d_surface *dst_surface, const RECT *dst_rect_in,
-        struct wined3d_surface *src_surface, const RECT *src_rect_in, DWORD flags,
+void surface_blt_ugly(struct wined3d_surface *dst_surface, const RECT *dst_rect,
+        struct wined3d_surface *src_surface, const RECT *src_rect, DWORD flags,
         const WINEDDBLTFX *fx, enum wined3d_texture_filter_type filter)
 {
     struct wined3d_swapchain *src_swapchain, *dst_swapchain;
     struct wined3d_device *device = dst_surface->resource.device;
     DWORD src_ds_flags, dst_ds_flags;
-    RECT src_rect, dst_rect;
     BOOL scale, convert;
     enum wined3d_conversion_type dst_convert_type;
     struct wined3d_format dst_conv_fmt;
@@ -6018,104 +5708,6 @@ HRESULT CDECL wined3d_surface_blt(struct wined3d_surface *dst_surface, const REC
             | WINEDDBLT_DEPTHFILL
             | WINEDDBLT_DONOTWAIT;
 
-    TRACE("dst_surface %p, dst_rect %s, src_surface %p, src_rect %s, flags %#x, fx %p, filter %s.\n",
-            dst_surface, wine_dbgstr_rect(dst_rect_in), src_surface, wine_dbgstr_rect(src_rect_in),
-            flags, fx, debug_d3dtexturefiltertype(filter));
-    TRACE("Usage is %s.\n", debug_d3dusage(dst_surface->resource.usage));
-
-    if (fx)
-    {
-        TRACE("dwSize %#x.\n", fx->dwSize);
-        TRACE("dwDDFX %#x.\n", fx->dwDDFX);
-        TRACE("dwROP %#x.\n", fx->dwROP);
-        TRACE("dwDDROP %#x.\n", fx->dwDDROP);
-        TRACE("dwRotationAngle %#x.\n", fx->dwRotationAngle);
-        TRACE("dwZBufferOpCode %#x.\n", fx->dwZBufferOpCode);
-        TRACE("dwZBufferLow %#x.\n", fx->dwZBufferLow);
-        TRACE("dwZBufferHigh %#x.\n", fx->dwZBufferHigh);
-        TRACE("dwZBufferBaseDest %#x.\n", fx->dwZBufferBaseDest);
-        TRACE("dwZDestConstBitDepth %#x.\n", fx->dwZDestConstBitDepth);
-        TRACE("lpDDSZBufferDest %p.\n", fx->u1.lpDDSZBufferDest);
-        TRACE("dwZSrcConstBitDepth %#x.\n", fx->dwZSrcConstBitDepth);
-        TRACE("lpDDSZBufferSrc %p.\n", fx->u2.lpDDSZBufferSrc);
-        TRACE("dwAlphaEdgeBlendBitDepth %#x.\n", fx->dwAlphaEdgeBlendBitDepth);
-        TRACE("dwAlphaEdgeBlend %#x.\n", fx->dwAlphaEdgeBlend);
-        TRACE("dwReserved %#x.\n", fx->dwReserved);
-        TRACE("dwAlphaDestConstBitDepth %#x.\n", fx->dwAlphaDestConstBitDepth);
-        TRACE("lpDDSAlphaDest %p.\n", fx->u3.lpDDSAlphaDest);
-        TRACE("dwAlphaSrcConstBitDepth %#x.\n", fx->dwAlphaSrcConstBitDepth);
-        TRACE("lpDDSAlphaSrc %p.\n", fx->u4.lpDDSAlphaSrc);
-        TRACE("lpDDSPattern %p.\n", fx->u5.lpDDSPattern);
-        TRACE("ddckDestColorkey {%#x, %#x}.\n",
-                fx->ddckDestColorkey.color_space_low_value,
-                fx->ddckDestColorkey.color_space_high_value);
-        TRACE("ddckSrcColorkey {%#x, %#x}.\n",
-                fx->ddckSrcColorkey.color_space_low_value,
-                fx->ddckSrcColorkey.color_space_high_value);
-    }
-
-    if (dst_surface->resource.map_count || (src_surface && src_surface->resource.map_count))
-    {
-        WARN("Surface is busy, returning WINEDDERR_SURFACEBUSY.\n");
-        return WINEDDERR_SURFACEBUSY;
-    }
-
-    surface_get_rect(dst_surface, dst_rect_in, &dst_rect);
-
-    if (dst_rect.left >= dst_rect.right || dst_rect.top >= dst_rect.bottom
-            || dst_rect.left > dst_surface->resource.width || dst_rect.left < 0
-            || dst_rect.top > dst_surface->resource.height || dst_rect.top < 0
-            || dst_rect.right > dst_surface->resource.width || dst_rect.right < 0
-            || dst_rect.bottom > dst_surface->resource.height || dst_rect.bottom < 0)
-    {
-        WARN("The application gave us a bad destination rectangle.\n");
-        return WINEDDERR_INVALIDRECT;
-    }
-
-    if (src_surface)
-    {
-        surface_get_rect(src_surface, src_rect_in, &src_rect);
-
-        if (src_rect.left >= src_rect.right || src_rect.top >= src_rect.bottom
-                || src_rect.left > src_surface->resource.width || src_rect.left < 0
-                || src_rect.top > src_surface->resource.height || src_rect.top < 0
-                || src_rect.right > src_surface->resource.width || src_rect.right < 0
-                || src_rect.bottom > src_surface->resource.height || src_rect.bottom < 0)
-        {
-            WARN("Application gave us bad source rectangle for Blt.\n");
-            return WINEDDERR_INVALIDRECT;
-        }
-    }
-    else
-    {
-        memset(&src_rect, 0, sizeof(src_rect));
-    }
-
-    if (!fx || !(fx->dwDDFX))
-        flags &= ~WINEDDBLT_DDFX;
-
-    if (flags & WINEDDBLT_WAIT)
-        flags &= ~WINEDDBLT_WAIT;
-
-    if (flags & WINEDDBLT_ASYNC)
-    {
-        static unsigned int once;
-
-        if (!once++)
-            FIXME("Can't handle WINEDDBLT_ASYNC flag.\n");
-        flags &= ~WINEDDBLT_ASYNC;
-    }
-
-    /* WINEDDBLT_DONOTWAIT appeared in DX7. */
-    if (flags & WINEDDBLT_DONOTWAIT)
-    {
-        static unsigned int once;
-
-        if (!once++)
-            FIXME("Can't handle WINEDDBLT_DONOTWAIT flag.\n");
-        flags &= ~WINEDDBLT_DONOTWAIT;
-    }
-
     if (!device->d3d_initialized)
     {
         WARN("D3D not initialized, using fallback.\n");
@@ -6157,8 +5749,8 @@ HRESULT CDECL wined3d_surface_blt(struct wined3d_surface *dst_surface, const REC
     }
 
     scale = src_surface
-            && (src_rect.right - src_rect.left != dst_rect.right - dst_rect.left
-            || src_rect.bottom - src_rect.top != dst_rect.bottom - dst_rect.top);
+            && (src_rect->right - src_rect->left != dst_rect->right - dst_rect->left
+            || src_rect->bottom - src_rect->top != dst_rect->bottom - dst_rect->top);
     convert = src_surface && src_surface->resource.format->id != dst_surface->resource.format->id;
 
     dst_ds_flags = dst_surface->resource.format->flags & (WINED3DFMT_FLAG_DEPTH | WINED3DFMT_FLAG_STENCIL);
@@ -6176,30 +5768,24 @@ HRESULT CDECL wined3d_surface_blt(struct wined3d_surface *dst_surface, const REC
             TRACE("Depth fill.\n");
 
             if (!surface_convert_depth_to_float(dst_surface, fx->u5.dwFillDepth, &depth))
-                return WINED3DERR_INVALIDCALL;
+                return;
 
-            if (SUCCEEDED(wined3d_surface_depth_fill(dst_surface, &dst_rect, depth)))
-                return WINED3D_OK;
+            if (SUCCEEDED(wined3d_surface_depth_fill(dst_surface, dst_rect, depth)))
+                return;
         }
         else
         {
-            if (src_ds_flags != dst_ds_flags)
-            {
-                WARN("Rejecting depth / stencil blit between incompatible formats.\n");
-                return WINED3DERR_INVALIDCALL;
-            }
-
-            if (SUCCEEDED(wined3d_surface_depth_blt(src_surface, src_surface->draw_binding, &src_rect,
-                    dst_surface, dst_surface->draw_binding, &dst_rect)))
-                return WINED3D_OK;
+            if (SUCCEEDED(wined3d_surface_depth_blt(src_surface, src_surface->draw_binding, src_rect,
+                    dst_surface, dst_surface->draw_binding, dst_rect)))
+                return;
         }
     }
     else
     {
         /* In principle this would apply to depth blits as well, but we don't
          * implement those in the CPU blitter at the moment. */
-        if ((dst_surface->locations & dst_surface->map_binding)
-                && (!src_surface || (src_surface->locations & src_surface->map_binding)))
+        if ((dst_surface->resource.locations & dst_surface->resource.map_binding)
+                && (!src_surface || (src_surface->resource.locations & src_surface->resource.map_binding)))
         {
             if (scale)
                 TRACE("Not doing sysmem blit because of scaling.\n");
@@ -6218,16 +5804,16 @@ HRESULT CDECL wined3d_surface_blt(struct wined3d_surface *dst_surface, const REC
             if (!surface_convert_color_to_float(dst_surface, fx->u5.dwFillColor, &color))
                 goto fallback;
 
-            if (SUCCEEDED(surface_color_fill(dst_surface, &dst_rect, &color)))
-                return WINED3D_OK;
+            if (SUCCEEDED(surface_color_fill(dst_surface, dst_rect, &color)))
+                return;
         }
         else
         {
             TRACE("Color blit.\n");
 
             /* Upload */
-            if ((src_surface->locations & WINED3D_LOCATION_SYSMEM)
-                    && !(dst_surface->locations & WINED3D_LOCATION_SYSMEM))
+            if ((src_surface->resource.locations & WINED3D_LOCATION_SYSMEM)
+                    && !(dst_surface->resource.locations & WINED3D_LOCATION_SYSMEM))
             {
                 if (scale)
                     TRACE("Not doing upload because of scaling.\n");
@@ -6235,13 +5821,17 @@ HRESULT CDECL wined3d_surface_blt(struct wined3d_surface *dst_surface, const REC
                     TRACE("Not doing upload because of format conversion.\n");
                 else
                 {
-                    POINT dst_point = {dst_rect.left, dst_rect.top};
+                    POINT dst_point = {dst_rect->left, dst_rect->top};
 
-                    if (SUCCEEDED(surface_upload_from_surface(dst_surface, &dst_point, src_surface, &src_rect)))
+                    if (SUCCEEDED(surface_upload_from_surface(dst_surface, &dst_point, src_surface, src_rect)))
                     {
                         if (!surface_is_offscreen(dst_surface))
-                            surface_load_location(dst_surface, dst_surface->draw_binding);
-                        return WINED3D_OK;
+                        {
+                            struct wined3d_context *context = context_acquire(device, dst_surface);
+                            wined3d_resource_load_location(&dst_surface->resource, context, dst_surface->draw_binding);
+                            context_release(context);
+                        }
+                        return;
                     }
                 }
             }
@@ -6266,49 +5856,201 @@ HRESULT CDECL wined3d_surface_blt(struct wined3d_surface *dst_surface, const REC
                 wined3d_swapchain_present(dst_swapchain, NULL, NULL, dst_swapchain->win_handle, NULL, 0);
                 dst_swapchain->desc.swap_effect = swap_effect;
 
-                return WINED3D_OK;
+                return;
             }
 
             if (fbo_blit_supported(&device->adapter->gl_info, WINED3D_BLIT_OP_COLOR_BLIT,
-                    &src_rect, src_surface->resource.usage, src_surface->resource.pool, src_surface->resource.format,
-                    &dst_rect, dst_surface->resource.usage, dst_surface->resource.pool, dst_surface->resource.format))
+                    src_rect, src_surface->resource.usage, src_surface->resource.pool, src_surface->resource.format,
+                    dst_rect, dst_surface->resource.usage, dst_surface->resource.pool, dst_surface->resource.format))
             {
+                struct wined3d_context *context;
                 TRACE("Using FBO blit.\n");
 
-                surface_blt_fbo(device, filter,
-                        src_surface, src_surface->draw_binding, &src_rect,
-                        dst_surface, dst_surface->draw_binding, &dst_rect);
-                surface_validate_location(dst_surface, dst_surface->draw_binding);
-                surface_invalidate_location(dst_surface, ~dst_surface->draw_binding);
+                context = context_acquire(device, NULL);
+                surface_blt_fbo(device, context, filter,
+                        src_surface, src_surface->draw_binding, src_rect,
+                        dst_surface, dst_surface->draw_binding, dst_rect);
+                context_release(context);
 
-                return WINED3D_OK;
+                wined3d_resource_validate_location(&dst_surface->resource, dst_surface->draw_binding);
+                wined3d_resource_invalidate_location(&dst_surface->resource, ~dst_surface->draw_binding);
+
+                return;
             }
 
             if (arbfp_blit.blit_supported(&device->adapter->gl_info, WINED3D_BLIT_OP_COLOR_BLIT,
-                    &src_rect, src_surface->resource.usage, src_surface->resource.pool, src_surface->resource.format,
-                    &dst_rect, dst_surface->resource.usage, dst_surface->resource.pool, dst_surface->resource.format))
+                    src_rect, src_surface->resource.usage, src_surface->resource.pool, src_surface->resource.format,
+                    dst_rect, dst_surface->resource.usage, dst_surface->resource.pool, dst_surface->resource.format))
             {
                 TRACE("Using arbfp blit.\n");
 
-                if (SUCCEEDED(arbfp_blit_surface(device, filter, src_surface, &src_rect, dst_surface, &dst_rect)))
-                    return WINED3D_OK;
+                if (SUCCEEDED(arbfp_blit_surface(device, filter, src_surface, src_rect, dst_surface, dst_rect)))
+                    return;
             }
         }
     }
 
 fallback:
     /* Special cases for render targets. */
-    if (SUCCEEDED(surface_blt_special(dst_surface, &dst_rect, src_surface, &src_rect, flags, fx, filter)))
-        return WINED3D_OK;
+    if ((dst_surface->resource.usage & WINED3DUSAGE_RENDERTARGET)
+            || (src_surface && (src_surface->resource.usage & WINED3DUSAGE_RENDERTARGET)))
+    {
+        if (SUCCEEDED(surface_blt_special(dst_surface, dst_rect, src_surface, src_rect, flags, fx, filter)))
+            return;
+    }
 
 cpu:
 
     /* For the rest call the X11 surface implementation. For render targets
      * this should be implemented OpenGL accelerated in surface_blt_special(),
      * other blits are rather rare. */
-    return surface_cpu_blt(dst_surface, &dst_rect, src_surface, &src_rect, flags, fx, filter);
+    surface_cpu_blt(dst_surface, dst_rect, src_surface, src_rect, flags, fx, filter);
+    return;
+}
+
+HRESULT CDECL wined3d_surface_blt(struct wined3d_surface *dst_surface, const RECT *dst_rect_in,
+        struct wined3d_surface *src_surface, const RECT *src_rect_in, DWORD flags,
+        const WINEDDBLTFX *fx, enum wined3d_texture_filter_type filter)
+{
+    struct wined3d_device *device = dst_surface->resource.device;
+    RECT src_rect, dst_rect;
+
+    TRACE("dst_surface %p, dst_rect %s, src_surface %p, src_rect %s, flags %#x, fx %p, filter %s.\n",
+            dst_surface, wine_dbgstr_rect(dst_rect_in), src_surface, wine_dbgstr_rect(src_rect_in),
+            flags, fx, debug_d3dtexturefiltertype(filter));
+    TRACE("Usage is %s.\n", debug_d3dusage(dst_surface->resource.usage));
+
+    if (fx)
+    {
+        TRACE("dwSize %#x.\n", fx->dwSize);
+        TRACE("dwDDFX %#x.\n", fx->dwDDFX);
+        TRACE("dwROP %#x.\n", fx->dwROP);
+        TRACE("dwDDROP %#x.\n", fx->dwDDROP);
+        TRACE("dwRotationAngle %#x.\n", fx->dwRotationAngle);
+        TRACE("dwZBufferOpCode %#x.\n", fx->dwZBufferOpCode);
+        TRACE("dwZBufferLow %#x.\n", fx->dwZBufferLow);
+        TRACE("dwZBufferHigh %#x.\n", fx->dwZBufferHigh);
+        TRACE("dwZBufferBaseDest %#x.\n", fx->dwZBufferBaseDest);
+        TRACE("dwZDestConstBitDepth %#x.\n", fx->dwZDestConstBitDepth);
+        TRACE("lpDDSZBufferDest %p.\n", fx->u1.lpDDSZBufferDest);
+        TRACE("dwZSrcConstBitDepth %#x.\n", fx->dwZSrcConstBitDepth);
+        TRACE("lpDDSZBufferSrc %p.\n", fx->u2.lpDDSZBufferSrc);
+        TRACE("dwAlphaEdgeBlendBitDepth %#x.\n", fx->dwAlphaEdgeBlendBitDepth);
+        TRACE("dwAlphaEdgeBlend %#x.\n", fx->dwAlphaEdgeBlend);
+        TRACE("dwReserved %#x.\n", fx->dwReserved);
+        TRACE("dwAlphaDestConstBitDepth %#x.\n", fx->dwAlphaDestConstBitDepth);
+        TRACE("lpDDSAlphaDest %p.\n", fx->u3.lpDDSAlphaDest);
+        TRACE("dwAlphaSrcConstBitDepth %#x.\n", fx->dwAlphaSrcConstBitDepth);
+        TRACE("lpDDSAlphaSrc %p.\n", fx->u4.lpDDSAlphaSrc);
+        TRACE("lpDDSPattern %p.\n", fx->u5.lpDDSPattern);
+        TRACE("ddckDestColorkey {%#x, %#x}.\n",
+                fx->ddckDestColorkey.color_space_low_value,
+                fx->ddckDestColorkey.color_space_high_value);
+        TRACE("ddckSrcColorkey {%#x, %#x}.\n",
+                fx->ddckSrcColorkey.color_space_low_value,
+                fx->ddckSrcColorkey.color_space_high_value);
+    }
+
+    if (dst_surface->resource.map_count || (src_surface && src_surface->resource.map_count))
+    {
+        /* TODO: Separate application maps from internal maps */
+        if (!wined3d_settings.cs_multithreaded)
+        {
+            WARN("Surface is busy, returning WINEDDERR_SURFACEBUSY.\n");
+            return WINEDDERR_SURFACEBUSY;
+        }
+
+        wined3d_cs_emit_glfinish(dst_surface->resource.device->cs);
+        dst_surface->resource.device->cs->ops->finish(dst_surface->resource.device->cs);
+
+        if (dst_surface->resource.map_count || (src_surface && src_surface->resource.map_count))
+        {
+            WARN("Surface is busy, returning WINEDDERR_SURFACEBUSY.\n");
+            return WINEDDERR_SURFACEBUSY;
+        }
+    }
+
+    surface_get_rect(dst_surface, dst_rect_in, &dst_rect);
+
+    if (dst_rect.left >= dst_rect.right || dst_rect.top >= dst_rect.bottom
+            || dst_rect.left > dst_surface->resource.width || dst_rect.left < 0
+            || dst_rect.top > dst_surface->resource.height || dst_rect.top < 0
+            || dst_rect.right > dst_surface->resource.width || dst_rect.right < 0
+            || dst_rect.bottom > dst_surface->resource.height || dst_rect.bottom < 0)
+    {
+        WARN("The application gave us a bad destination rectangle.\n");
+        return WINEDDERR_INVALIDRECT;
+    }
+
+    if (src_surface)
+    {
+        DWORD src_ds_flags, dst_ds_flags;
+
+        surface_get_rect(src_surface, src_rect_in, &src_rect);
+
+        if (src_rect.left >= src_rect.right || src_rect.top >= src_rect.bottom
+                || src_rect.left > src_surface->resource.width || src_rect.left < 0
+                || src_rect.top > src_surface->resource.height || src_rect.top < 0
+                || src_rect.right > src_surface->resource.width || src_rect.right < 0
+                || src_rect.bottom > src_surface->resource.height || src_rect.bottom < 0)
+        {
+            WARN("Application gave us bad source rectangle for Blt.\n");
+            return WINEDDERR_INVALIDRECT;
+        }
+
+        dst_ds_flags = dst_surface->resource.format->flags & (WINED3DFMT_FLAG_DEPTH | WINED3DFMT_FLAG_STENCIL);
+        src_ds_flags = src_surface->resource.format->flags & (WINED3DFMT_FLAG_DEPTH | WINED3DFMT_FLAG_STENCIL);
+        if (src_ds_flags != dst_ds_flags)
+        {
+            WARN("Rejecting depth / stencil blit between incompatible formats.\n");
+            return WINED3DERR_INVALIDCALL;
+        }
+
+    }
+    else
+    {
+        memset(&src_rect, 0, sizeof(src_rect));
+    }
+
+    if (!fx || !(fx->dwDDFX))
+        flags &= ~WINEDDBLT_DDFX;
+
+    if (flags & WINEDDBLT_WAIT)
+        flags &= ~WINEDDBLT_WAIT;
+
+    if (flags & WINEDDBLT_ASYNC)
+    {
+        static unsigned int once;
+
+        if (!once++)
+            FIXME("Can't handle WINEDDBLT_ASYNC flag.\n");
+        flags &= ~WINEDDBLT_ASYNC;
+    }
+
+    /* WINEDDBLT_DONOTWAIT appeared in DX7. */
+    if (flags & WINEDDBLT_DONOTWAIT)
+    {
+        static unsigned int once;
+
+        if (!once++)
+            FIXME("Can't handle WINEDDBLT_DONOTWAIT flag.\n");
+        flags &= ~WINEDDBLT_DONOTWAIT;
+    }
+
+    TRACE("Emitting blit %p <== %p\n", dst_surface, src_surface);
+    wined3d_cs_emit_blt(device->cs, dst_surface, &dst_rect, src_surface, &src_rect,
+            flags, fx, filter);
+
+    return WINED3D_OK;
 }
 
+static const struct wined3d_resource_ops surface_resource_ops =
+{
+    surface_unload,
+    wined3d_surface_location_invalidated,
+    wined3d_surface_load_location,
+};
+
 static HRESULT surface_init(struct wined3d_surface *surface, struct wined3d_texture *container,
         const struct wined3d_resource_desc *desc, DWORD flags)
 {
@@ -6375,7 +6117,7 @@ static HRESULT surface_init(struct wined3d_surface *surface, struct wined3d_text
     }
 
     surface_set_container(surface, container);
-    surface_validate_location(surface, WINED3D_LOCATION_SYSMEM);
+    wined3d_resource_validate_location(&surface->resource, WINED3D_LOCATION_SYSMEM);
     list_init(&surface->renderbuffers);
     list_init(&surface->overlays);
 
@@ -6388,7 +6130,7 @@ static HRESULT surface_init(struct wined3d_surface *surface, struct wined3d_text
     if (lockable || desc->format == WINED3DFMT_D16_LOCKABLE)
         surface->resource.access_flags |= WINED3D_RESOURCE_ACCESS_CPU;
 
-    surface->map_binding = WINED3D_LOCATION_SYSMEM;
+    surface->resource.map_binding = WINED3D_LOCATION_SYSMEM;
 
     /* Call the private setup routine */
     hr = surface->surface_ops->surface_private_setup(surface);
@@ -6405,13 +6147,13 @@ static HRESULT surface_init(struct wined3d_surface *surface, struct wined3d_text
      * after a wined3d_surface_getdc() call. */
     if ((desc->usage & WINED3DUSAGE_OWNDC) && !surface->hDC
             && SUCCEEDED(surface_create_dib_section(surface)))
-        surface->map_binding = WINED3D_LOCATION_DIB;
+        surface->resource.map_binding = WINED3D_LOCATION_DIB;
 
-    if (surface->map_binding == WINED3D_LOCATION_DIB)
+    if (surface->resource.map_binding == WINED3D_LOCATION_DIB)
     {
         wined3d_resource_free_sysmem(&surface->resource);
-        surface_validate_location(surface, WINED3D_LOCATION_DIB);
-        surface_invalidate_location(surface, WINED3D_LOCATION_SYSMEM);
+        wined3d_resource_validate_location(&surface->resource, WINED3D_LOCATION_DIB);
+        wined3d_resource_invalidate_location(&surface->resource, WINED3D_LOCATION_SYSMEM);
     }
 
     return hr;
@@ -6438,7 +6180,7 @@ HRESULT CDECL wined3d_surface_create(struct wined3d_texture *container,
     if (FAILED(hr = surface_init(object, container, desc, flags)))
     {
         WARN("Failed to initialize surface, returning %#x.\n", hr);
-        HeapFree(GetProcessHeap(), 0, object);
+        /* The command stream takes care of freeing the memory. */
         return hr;
     }
 
diff --git a/dlls/wined3d/swapchain.c b/dlls/wined3d/swapchain.c
index 75e6628..d8f7617 100644
--- a/dlls/wined3d/swapchain.c
+++ b/dlls/wined3d/swapchain.c
@@ -302,7 +302,7 @@ static void swapchain_blit(const struct wined3d_swapchain *swapchain,
         if (backbuffer->resource.multisample_type)
         {
             location = WINED3D_LOCATION_RB_RESOLVED;
-            surface_load_location(backbuffer, location);
+            wined3d_resource_load_location(&backbuffer->resource, context, location);
         }
 
         context_apply_fbo_state_blit(context, GL_READ_FRAMEBUFFER, backbuffer, NULL, location);
@@ -408,10 +408,10 @@ static void swapchain_blit(const struct wined3d_swapchain *swapchain,
 }
 
 static void swapchain_gl_present(struct wined3d_swapchain *swapchain, const RECT *src_rect_in,
-        const RECT *dst_rect_in, const RGNDATA *dirty_region, DWORD flags)
+        const RECT *dst_rect_in, const RGNDATA *dirty_region, DWORD flags,
+        struct wined3d_surface *depth_stencil)
 {
     struct wined3d_surface *back_buffer = swapchain->back_buffers[0];
-    const struct wined3d_fb_state *fb = &swapchain->device->fb;
     const struct wined3d_gl_info *gl_info;
     struct wined3d_context *context;
     RECT src_rect, dst_rect;
@@ -438,27 +438,6 @@ static void swapchain_gl_present(struct wined3d_swapchain *swapchain, const RECT
                 NULL, WINED3D_TEXF_POINT);
     }
 
-    if (swapchain->device->bCursorVisible && swapchain->device->cursor_texture
-            && !swapchain->device->hardwareCursor)
-    {
-        struct wined3d_surface *cursor = surface_from_resource(
-                wined3d_texture_get_sub_resource(swapchain->device->cursor_texture, 0));
-        RECT destRect =
-        {
-            swapchain->device->xScreenSpace - swapchain->device->xHotSpot,
-            swapchain->device->yScreenSpace - swapchain->device->yHotSpot,
-            swapchain->device->xScreenSpace + swapchain->device->cursorWidth - swapchain->device->xHotSpot,
-            swapchain->device->yScreenSpace + swapchain->device->cursorHeight - swapchain->device->yHotSpot,
-        };
-
-        TRACE("Rendering the software cursor.\n");
-
-        if (swapchain->desc.windowed)
-            MapWindowPoints(NULL, swapchain->win_handle, (POINT *)&destRect, 2);
-        wined3d_surface_blt(back_buffer, &destRect, cursor, NULL, WINEDDBLT_ALPHATEST,
-                NULL, WINED3D_TEXF_POINT);
-    }
-
     TRACE("Presenting HDC %p.\n", context->hdc);
 
     render_to_fbo = swapchain->render_to_fbo;
@@ -500,14 +479,14 @@ static void swapchain_gl_present(struct wined3d_swapchain *swapchain, const RECT
      */
     if (!swapchain->render_to_fbo && render_to_fbo && wined3d_settings.offscreen_rendering_mode == ORM_FBO)
     {
-        surface_load_location(back_buffer, WINED3D_LOCATION_TEXTURE_RGB);
-        surface_invalidate_location(back_buffer, WINED3D_LOCATION_DRAWABLE);
+        wined3d_resource_load_location(&back_buffer->resource, context, WINED3D_LOCATION_TEXTURE_RGB);
+        wined3d_resource_invalidate_location(&back_buffer->resource, WINED3D_LOCATION_DRAWABLE);
         swapchain->render_to_fbo = TRUE;
         swapchain_update_draw_bindings(swapchain);
     }
     else
     {
-        surface_load_location(back_buffer, back_buffer->draw_binding);
+        wined3d_resource_load_location(&back_buffer->resource, context, back_buffer->draw_binding);
     }
 
     if (swapchain->render_to_fbo)
@@ -520,8 +499,8 @@ static void swapchain_gl_present(struct wined3d_swapchain *swapchain, const RECT
         swapchain_blit(swapchain, context, &src_rect, &dst_rect);
     }
 
-    if (swapchain->num_contexts > 1)
-        gl_info->gl_ops.gl.p_glFinish();
+    if (swapchain->num_contexts > 1 && !wined3d_settings.cs_multithreaded)
+        gl_info->gl_ops.gl.p_glFlush();
 
     /* call wglSwapBuffers through the gl table to avoid confusing the Steam overlay */
     gl_info->gl_ops.wgl.p_wglSwapBuffers(context->hdc); /* TODO: cycle through the swapchain buffers */
@@ -543,59 +522,35 @@ static void swapchain_gl_present(struct wined3d_swapchain *swapchain, const RECT
         }
     }
 
-    if (!swapchain->render_to_fbo && ((swapchain->front_buffer->locations & WINED3D_LOCATION_SYSMEM)
-            || (back_buffer->locations & WINED3D_LOCATION_SYSMEM)))
+    wined3d_resource_validate_location(&swapchain->front_buffer->resource, WINED3D_LOCATION_DRAWABLE);
+    wined3d_resource_invalidate_location(&swapchain->front_buffer->resource, ~WINED3D_LOCATION_DRAWABLE);
+    switch (swapchain->desc.swap_effect)
     {
-        /* Both memory copies of the surfaces are ok, flip them around too instead of dirtifying
-         * Doesn't work with render_to_fbo because we're not flipping
-         */
-        struct wined3d_surface *front = swapchain->front_buffer;
+        case WINED3D_SWAP_EFFECT_DISCARD:
+            wined3d_resource_validate_location(&back_buffer->resource, WINED3D_LOCATION_DISCARDED);
+            break;
 
-        if (front->resource.size == back_buffer->resource.size)
-        {
-            flip_surface(front, back_buffer);
+        case WINED3D_SWAP_EFFECT_FLIP:
+            wined3d_resource_validate_location(&back_buffer->resource, back_buffer->draw_binding);
+            wined3d_resource_invalidate_location(&back_buffer->resource, ~back_buffer->draw_binding);
+            break;
 
-            /* Tell the front buffer surface that is has been modified. However,
-             * the other locations were preserved during that, so keep the flags.
-             * This serves to update the emulated overlay, if any. */
-            surface_validate_location(front, WINED3D_LOCATION_DRAWABLE);
-        }
-        else
-        {
-            surface_validate_location(front, WINED3D_LOCATION_DRAWABLE);
-            surface_invalidate_location(front, ~WINED3D_LOCATION_DRAWABLE);
-            surface_validate_location(back_buffer, WINED3D_LOCATION_DRAWABLE);
-            surface_invalidate_location(back_buffer, ~WINED3D_LOCATION_DRAWABLE);
-        }
-    }
-    else
-    {
-        surface_validate_location(swapchain->front_buffer, WINED3D_LOCATION_DRAWABLE);
-        surface_invalidate_location(swapchain->front_buffer, ~WINED3D_LOCATION_DRAWABLE);
-        /* If the swapeffect is DISCARD, the back buffer is undefined. That means the SYSMEM
-         * and INTEXTURE copies can keep their old content if they have any defined content.
-         * If the swapeffect is COPY, the content remains the same. If it is FLIP however,
-         * the texture / sysmem copy needs to be reloaded from the drawable
-         */
-        if (swapchain->desc.swap_effect == WINED3D_SWAP_EFFECT_FLIP)
-        {
-            surface_validate_location(back_buffer, back_buffer->draw_binding);
-            surface_invalidate_location(back_buffer, ~back_buffer->draw_binding);
-        }
+        default:
+            break;
     }
 
-    if (fb->depth_stencil)
+    if (depth_stencil)
     {
         if (swapchain->desc.flags & WINED3DPRESENTFLAG_DISCARD_DEPTHSTENCIL
-                || fb->depth_stencil->flags & SFLAG_DISCARD)
+                || depth_stencil->flags & SFLAG_DISCARD)
         {
-            surface_modify_ds_location(fb->depth_stencil, WINED3D_LOCATION_DISCARDED,
-                    fb->depth_stencil->resource.width,
-                    fb->depth_stencil->resource.height);
-            if (fb->depth_stencil == swapchain->device->onscreen_depth_stencil)
+            surface_modify_ds_location(depth_stencil, WINED3D_LOCATION_DISCARDED,
+                    depth_stencil->resource.width,
+                    depth_stencil->resource.height);
+            if (depth_stencil == swapchain->device->cs->onscreen_depth_stencil)
             {
-                wined3d_surface_decref(swapchain->device->onscreen_depth_stencil);
-                swapchain->device->onscreen_depth_stencil = NULL;
+                wined3d_surface_decref(swapchain->device->cs->onscreen_depth_stencil);
+                swapchain->device->cs->onscreen_depth_stencil = NULL;
             }
         }
     }
@@ -625,7 +580,7 @@ void x11_copy_to_screen(const struct wined3d_swapchain *swapchain, const RECT *r
 
     TRACE("Copying surface %p to screen.\n", front);
 
-    surface_load_location(front, WINED3D_LOCATION_DIB);
+    wined3d_resource_load_location(&front->resource, NULL, WINED3D_LOCATION_DIB);
 
     src_dc = front->hDC;
     window = swapchain->win_handle;
@@ -653,7 +608,8 @@ void x11_copy_to_screen(const struct wined3d_swapchain *swapchain, const RECT *r
 }
 
 static void swapchain_gdi_present(struct wined3d_swapchain *swapchain, const RECT *src_rect_in,
-        const RECT *dst_rect_in, const RGNDATA *dirty_region, DWORD flags)
+        const RECT *dst_rect_in, const RGNDATA *dirty_region, DWORD flags,
+        struct wined3d_surface *depth_stencil)
 {
     struct wined3d_surface *front, *back;
 
@@ -680,9 +636,9 @@ static void swapchain_gdi_present(struct wined3d_swapchain *swapchain, const REC
     {
         void *tmp;
 
-        tmp = front->dib.bitmap_data;
-        front->dib.bitmap_data = back->dib.bitmap_data;
-        back->dib.bitmap_data = tmp;
+        tmp = front->resource.bitmap_data;
+        front->resource.bitmap_data = back->resource.bitmap_data;
+        back->resource.bitmap_data = tmp;
 
         if (front->resource.heap_memory)
             ERR("GDI Surface %p has heap memory allocated.\n", front);
@@ -753,6 +709,68 @@ void swapchain_update_render_to_fbo(struct wined3d_swapchain *swapchain)
     swapchain->render_to_fbo = TRUE;
 }
 
+HRESULT swapchain_create_context_cs(struct wined3d_device *device, struct wined3d_swapchain *swapchain)
+{
+    const struct wined3d_adapter *adapter = device->adapter;
+    unsigned int i;
+    static const enum wined3d_format_id formats[] =
+    {
+        WINED3DFMT_D24_UNORM_S8_UINT,
+        WINED3DFMT_D32_UNORM,
+        WINED3DFMT_R24_UNORM_X8_TYPELESS,
+        WINED3DFMT_D16_UNORM,
+        WINED3DFMT_S1_UINT_D15_UNORM
+    };
+
+    const struct wined3d_gl_info *gl_info = &adapter->gl_info;
+
+    swapchain->context = HeapAlloc(GetProcessHeap(), 0, sizeof(*swapchain->context));
+    if (!swapchain->context)
+    {
+        ERR("Failed to create the context array.\n");
+        return E_OUTOFMEMORY;
+    }
+    swapchain->num_contexts = 1;
+
+    /* In WGL both color, depth and stencil are features of a pixel format. In case of D3D they are separate.
+     * You are able to add a depth + stencil surface at a later stage when you need it.
+     * In order to support this properly in WineD3D we need the ability to recreate the opengl context and
+     * drawable when this is required. This is very tricky as we need to reapply ALL opengl states for the new
+     * context, need torecreate shaders, textures and other resources.
+     *
+     * The context manager already takes care of the state problem and for the other tasks code from Reset
+     * can be used. These changes are way to risky during the 1.0 code freeze which is taking place right now.
+     * Likely a lot of other new bugs will be exposed. For that reason request a depth stencil surface all the
+     * time. It can cause a slight performance hit but fixes a lot of regressions. A fixme reminds of that this
+     * issue needs to be fixed. */
+    for (i = 0; i < (sizeof(formats) / sizeof(*formats)); i++)
+    {
+        swapchain->ds_format = wined3d_get_format(gl_info, formats[i]);
+        swapchain->context[0] = context_create(swapchain, swapchain->front_buffer, swapchain->ds_format);
+        if (swapchain->context[0]) break;
+        TRACE("Depth stencil format %s is not supported, trying next format\n",
+                debug_d3dformat(formats[i]));
+    }
+
+    if (!swapchain->context[0])
+    {
+        WARN("Failed to create context.\n");
+        HeapFree(GetProcessHeap(), 0, swapchain->context);
+        swapchain->context = NULL;
+        return WINED3DERR_NOTAVAILABLE;
+    }
+
+    if (wined3d_settings.offscreen_rendering_mode != ORM_FBO
+            && (!swapchain->desc.enable_auto_depth_stencil
+            || swapchain->desc.auto_depth_stencil_format != swapchain->ds_format->id))
+    {
+        FIXME("Add OpenGL context recreation support to context_validate_onscreen_formats\n");
+    }
+    context_release(swapchain->context[0]);
+
+    return WINED3D_OK;
+}
+
 static HRESULT swapchain_init(struct wined3d_swapchain *swapchain, struct wined3d_device *device,
         struct wined3d_swapchain_desc *desc, void *parent, const struct wined3d_parent_ops *parent_ops)
 {
@@ -848,8 +866,8 @@ static HRESULT swapchain_init(struct wined3d_swapchain *swapchain, struct wined3
     surface_set_swapchain(swapchain->front_buffer, swapchain);
     if (!(device->wined3d->flags & WINED3D_NO3D))
     {
-        surface_validate_location(swapchain->front_buffer, WINED3D_LOCATION_DRAWABLE);
-        surface_invalidate_location(swapchain->front_buffer, ~WINED3D_LOCATION_DRAWABLE);
+        wined3d_resource_validate_location(&swapchain->front_buffer->resource, WINED3D_LOCATION_DRAWABLE);
+        wined3d_resource_invalidate_location(&swapchain->front_buffer->resource, ~WINED3D_LOCATION_DRAWABLE);
     }
 
     /* MSDN says we're only allowed a single fullscreen swapchain per device,
@@ -877,60 +895,9 @@ static HRESULT swapchain_init(struct wined3d_swapchain *swapchain, struct wined3
 
     if (!(device->wined3d->flags & WINED3D_NO3D))
     {
-        static const enum wined3d_format_id formats[] =
-        {
-            WINED3DFMT_D24_UNORM_S8_UINT,
-            WINED3DFMT_D32_UNORM,
-            WINED3DFMT_R24_UNORM_X8_TYPELESS,
-            WINED3DFMT_D16_UNORM,
-            WINED3DFMT_S1_UINT_D15_UNORM
-        };
-
-        const struct wined3d_gl_info *gl_info = &adapter->gl_info;
-
-        swapchain->context = HeapAlloc(GetProcessHeap(), 0, sizeof(*swapchain->context));
-        if (!swapchain->context)
-        {
-            ERR("Failed to create the context array.\n");
-            hr = E_OUTOFMEMORY;
-            goto err;
-        }
-        swapchain->num_contexts = 1;
-
-        /* In WGL both color, depth and stencil are features of a pixel format. In case of D3D they are separate.
-         * You are able to add a depth + stencil surface at a later stage when you need it.
-         * In order to support this properly in WineD3D we need the ability to recreate the opengl context and
-         * drawable when this is required. This is very tricky as we need to reapply ALL opengl states for the new
-         * context, need torecreate shaders, textures and other resources.
-         *
-         * The context manager already takes care of the state problem and for the other tasks code from Reset
-         * can be used. These changes are way to risky during the 1.0 code freeze which is taking place right now.
-         * Likely a lot of other new bugs will be exposed. For that reason request a depth stencil surface all the
-         * time. It can cause a slight performance hit but fixes a lot of regressions. A fixme reminds of that this
-         * issue needs to be fixed. */
-        for (i = 0; i < (sizeof(formats) / sizeof(*formats)); i++)
-        {
-            swapchain->ds_format = wined3d_get_format(gl_info, formats[i]);
-            swapchain->context[0] = context_create(swapchain, swapchain->front_buffer, swapchain->ds_format);
-            if (swapchain->context[0]) break;
-            TRACE("Depth stencil format %s is not supported, trying next format\n",
-                  debug_d3dformat(formats[i]));
-        }
-
-        if (!swapchain->context[0])
-        {
-            WARN("Failed to create context.\n");
-            hr = WINED3DERR_NOTAVAILABLE;
+        hr = wined3d_cs_emit_create_swapchain_context(device->cs, swapchain);
+        if (FAILED(hr))
             goto err;
-        }
-
-        if (wined3d_settings.offscreen_rendering_mode != ORM_FBO
-                && (!desc->enable_auto_depth_stencil
-                || swapchain->desc.auto_depth_stencil_format != swapchain->ds_format->id))
-        {
-            FIXME("Add OpenGL context recreation support to context_validate_onscreen_formats\n");
-        }
-        context_release(swapchain->context[0]);
     }
 
     if (swapchain->desc.backbuffer_count > 0)
diff --git a/dlls/wined3d/texture.c b/dlls/wined3d/texture.c
index 897af19..0b0ae89 100644
--- a/dlls/wined3d/texture.c
+++ b/dlls/wined3d/texture.c
@@ -64,6 +64,8 @@ static HRESULT wined3d_texture_init(struct wined3d_texture *texture, const struc
     {
         ERR("Failed to allocate sub-resource array.\n");
         resource_cleanup(&texture->resource);
+        if (wined3d_settings.cs_multithreaded)
+            texture->resource.device->cs->ops->finish(texture->resource.device->cs);
         return E_OUTOFMEMORY;
     }
 
@@ -117,13 +119,28 @@ static void wined3d_texture_unload_gl_texture(struct wined3d_texture *texture)
     resource_unload(&texture->resource);
 }
 
+void wined3d_texture_cleanup_cs(struct wined3d_texture *texture)
+{
+    wined3d_texture_unload_gl_texture(texture);
+    HeapFree(GetProcessHeap(), 0, texture->sub_resources);
+    HeapFree(GetProcessHeap(), 0, texture);
+}
+
 static void wined3d_texture_cleanup(struct wined3d_texture *texture)
 {
     UINT sub_count = texture->level_count * texture->layer_count;
     UINT i;
+    struct wined3d_device *device = texture->resource.device;
 
     TRACE("texture %p.\n", texture);
 
+    /* Because sub_resource_cleanup interferes with GL resources */
+    if (wined3d_settings.cs_multithreaded)
+    {
+        FIXME("Waiting for cs.\n");
+        device->cs->ops->finish(device->cs);
+    }
+
     for (i = 0; i < sub_count; ++i)
     {
         struct wined3d_resource *sub_resource = texture->sub_resources[i];
@@ -132,9 +149,8 @@ static void wined3d_texture_cleanup(struct wined3d_texture *texture)
             texture->texture_ops->texture_sub_resource_cleanup(sub_resource);
     }
 
-    wined3d_texture_unload_gl_texture(texture);
-    HeapFree(GetProcessHeap(), 0, texture->sub_resources);
     resource_cleanup(&texture->resource);
+    wined3d_cs_emit_texture_cleanup(device->cs, texture);
 }
 
 void wined3d_texture_set_dirty(struct wined3d_texture *texture)
@@ -483,9 +499,10 @@ ULONG CDECL wined3d_texture_decref(struct wined3d_texture *texture)
 
     if (!refcount)
     {
+        void *parent = texture->resource.parent;
+        const struct wined3d_parent_ops *parent_ops = texture->resource.parent_ops;
         wined3d_texture_cleanup(texture);
-        texture->resource.parent_ops->wined3d_object_destroyed(texture->resource.parent);
-        HeapFree(GetProcessHeap(), 0, texture);
+        parent_ops->wined3d_object_destroyed(parent);
     }
 
     return refcount;
@@ -543,10 +560,8 @@ void wined3d_texture_load(struct wined3d_texture *texture,
 
 void CDECL wined3d_texture_preload(struct wined3d_texture *texture)
 {
-    struct wined3d_context *context;
-    context = context_acquire(texture->resource.device, NULL);
-    wined3d_texture_load(texture, context, texture->flags & WINED3D_TEXTURE_IS_SRGB);
-    context_release(context);
+    const struct wined3d_device *device = texture->resource.device;
+    wined3d_cs_emit_texture_preload(device->cs, texture);
 }
 
 void * CDECL wined3d_texture_get_parent(const struct wined3d_texture *texture)
@@ -575,6 +590,13 @@ DWORD CDECL wined3d_texture_set_lod(struct wined3d_texture *texture, DWORD lod)
 
     if (texture->lod != lod)
     {
+        if (wined3d_settings.cs_multithreaded)
+        {
+            struct wined3d_device *device = texture->resource.device;
+            FIXME("Waiting for cs.\n");
+            device->cs->ops->finish(device->cs);
+        }
+
         texture->lod = lod;
 
         texture->texture_rgb.states[WINED3DTEXSTA_MAXMIPLEVEL] = ~0U;
@@ -634,6 +656,12 @@ HRESULT CDECL wined3d_texture_set_color_key(struct wined3d_texture *texture,
         return WINED3DERR_INVALIDCALL;
     }
 
+    if (wined3d_settings.cs_multithreaded)
+    {
+        FIXME("waiting for cs\n");
+        texture->resource.device->cs->ops->finish(texture->resource.device->cs);
+    }
+
     if (color_key)
     {
         switch (flags & ~WINEDDCKEY_COLORSPACE)
@@ -727,17 +755,20 @@ HRESULT CDECL wined3d_texture_add_dirty_region(struct wined3d_texture *texture,
 static void texture2d_sub_resource_load(struct wined3d_resource *sub_resource,
         struct wined3d_context *context, BOOL srgb)
 {
-    surface_load(surface_from_resource(sub_resource), srgb);
+    surface_load(surface_from_resource(sub_resource), context, srgb);
 }
 
 static void texture2d_sub_resource_add_dirty_region(struct wined3d_resource *sub_resource,
         const struct wined3d_box *dirty_region)
 {
     struct wined3d_surface *surface = surface_from_resource(sub_resource);
+    struct wined3d_context *context;
 
-    surface_prepare_map_memory(surface);
-    surface_load_location(surface, surface->map_binding);
-    surface_invalidate_location(surface, ~surface->map_binding);
+    context = context_acquire(surface->resource.device, NULL);
+    wined3d_resource_prepare_map_memory(&surface->resource, context);
+    wined3d_resource_load_location(&surface->resource, context, surface->resource.map_binding);
+    context_release(context);
+    wined3d_resource_invalidate_location(&surface->resource, ~surface->resource.map_binding);
 }
 
 static void texture2d_sub_resource_cleanup(struct wined3d_resource *sub_resource)
@@ -774,9 +805,23 @@ static void wined3d_texture_unload(struct wined3d_resource *resource)
     wined3d_texture_unload_gl_texture(texture);
 }
 
+static void wined3d_texture_load_location_invalidated(struct wined3d_resource *resource, DWORD location)
+{
+    ERR("Should not be called on textures.\n");
+}
+
+/* Context activation is done by the caller. */
+static void wined3d_texture_load_location(struct wined3d_resource *resource,
+        struct wined3d_context *context, DWORD location)
+{
+    ERR("Should not be called on textures.\n");
+}
+
 static const struct wined3d_resource_ops texture_resource_ops =
 {
     wined3d_texture_unload,
+    wined3d_texture_load_location_invalidated,
+    wined3d_texture_load_location,
 };
 
 static HRESULT cubetexture_init(struct wined3d_texture *texture, const struct wined3d_resource_desc *desc,
@@ -793,12 +838,14 @@ static HRESULT cubetexture_init(struct wined3d_texture *texture, const struct wi
     if (WINED3DFMT_UNKNOWN >= desc->format)
     {
         WARN("(%p) : Texture cannot be created with a format of WINED3DFMT_UNKNOWN.\n", texture);
+        HeapFree(GetProcessHeap(), 0, texture);
         return WINED3DERR_INVALIDCALL;
     }
 
     if (!gl_info->supported[ARB_TEXTURE_CUBE_MAP] && desc->pool != WINED3D_POOL_SCRATCH)
     {
         WARN("(%p) : Tried to create not supported cube texture.\n", texture);
+        HeapFree(GetProcessHeap(), 0, texture);
         return WINED3DERR_INVALIDCALL;
     }
 
@@ -808,12 +855,14 @@ static HRESULT cubetexture_init(struct wined3d_texture *texture, const struct wi
         if (!gl_info->supported[SGIS_GENERATE_MIPMAP])
         {
             WARN("No mipmap generation support, returning D3DERR_INVALIDCALL.\n");
+            HeapFree(GetProcessHeap(), 0, texture);
             return WINED3DERR_INVALIDCALL;
         }
 
         if (levels > 1)
         {
             WARN("D3DUSAGE_AUTOGENMIPMAP is set, and level count > 1, returning D3DERR_INVALIDCALL.\n");
+            HeapFree(GetProcessHeap(), 0, texture);
             return WINED3DERR_INVALIDCALL;
         }
 
@@ -841,6 +890,7 @@ static HRESULT cubetexture_init(struct wined3d_texture *texture, const struct wi
             else
             {
                 WARN("Attempted to create a NPOT cube texture (edge length %u) without GL support.\n", desc->width);
+                HeapFree(GetProcessHeap(), 0, texture);
                 return WINED3DERR_INVALIDCALL;
             }
         }
@@ -850,6 +900,7 @@ static HRESULT cubetexture_init(struct wined3d_texture *texture, const struct wi
             desc, device, parent, parent_ops, &texture_resource_ops)))
     {
         WARN("Failed to initialize texture, returning %#x\n", hr);
+        HeapFree(GetProcessHeap(), 0, texture);
         return hr;
     }
 
@@ -912,6 +963,7 @@ static HRESULT texture_init(struct wined3d_texture *texture, const struct wined3
     if (WINED3DFMT_UNKNOWN >= desc->format)
     {
         WARN("(%p) : Texture cannot be created with a format of WINED3DFMT_UNKNOWN.\n", texture);
+        HeapFree(GetProcessHeap(), 0, texture);
         return WINED3DERR_INVALIDCALL;
     }
 
@@ -942,6 +994,7 @@ static HRESULT texture_init(struct wined3d_texture *texture, const struct wined3
                 else
                 {
                     WARN("Attempted to create a mipmapped NPOT texture without unconditional NPOT support.\n");
+                    HeapFree(GetProcessHeap(), 0, texture);
                     return WINED3DERR_INVALIDCALL;
                 }
             }
@@ -954,12 +1007,14 @@ static HRESULT texture_init(struct wined3d_texture *texture, const struct wined3
         if (!gl_info->supported[SGIS_GENERATE_MIPMAP])
         {
             WARN("No mipmap generation support, returning WINED3DERR_INVALIDCALL.\n");
+            HeapFree(GetProcessHeap(), 0, texture);
             return WINED3DERR_INVALIDCALL;
         }
 
         if (levels > 1)
         {
             WARN("D3DUSAGE_AUTOGENMIPMAP is set, and level count > 1, returning WINED3DERR_INVALIDCALL.\n");
+            HeapFree(GetProcessHeap(), 0, texture);
             return WINED3DERR_INVALIDCALL;
         }
 
@@ -975,6 +1030,7 @@ static HRESULT texture_init(struct wined3d_texture *texture, const struct wined3
             desc, device, parent, parent_ops, &texture_resource_ops)))
     {
         WARN("Failed to initialize texture, returning %#x.\n", hr);
+        HeapFree(GetProcessHeap(), 0, texture);
         return hr;
     }
 
@@ -1092,12 +1148,14 @@ static HRESULT volumetexture_init(struct wined3d_texture *texture, const struct
     if (WINED3DFMT_UNKNOWN >= desc->format)
     {
         WARN("(%p) : Texture cannot be created with a format of WINED3DFMT_UNKNOWN.\n", texture);
+        HeapFree(GetProcessHeap(), 0, texture);
         return WINED3DERR_INVALIDCALL;
     }
 
     if (!gl_info->supported[EXT_TEXTURE3D])
     {
         WARN("(%p) : Texture cannot be created - no volume texture support.\n", texture);
+        HeapFree(GetProcessHeap(), 0, texture);
         return WINED3DERR_INVALIDCALL;
     }
 
@@ -1107,12 +1165,14 @@ static HRESULT volumetexture_init(struct wined3d_texture *texture, const struct
         if (!gl_info->supported[SGIS_GENERATE_MIPMAP])
         {
             WARN("No mipmap generation support, returning D3DERR_INVALIDCALL.\n");
+            HeapFree(GetProcessHeap(), 0, texture);
             return WINED3DERR_INVALIDCALL;
         }
 
         if (levels > 1)
         {
             WARN("D3DUSAGE_AUTOGENMIPMAP is set, and level count > 1, returning D3DERR_INVALIDCALL.\n");
+            HeapFree(GetProcessHeap(), 0, texture);
             return WINED3DERR_INVALIDCALL;
         }
 
@@ -1147,6 +1207,7 @@ static HRESULT volumetexture_init(struct wined3d_texture *texture, const struct
             {
                 WARN("Attempted to create a NPOT volume texture (%u, %u, %u) without GL support.\n",
                         desc->width, desc->height, desc->depth);
+                HeapFree(GetProcessHeap(), 0, texture);
                 return WINED3DERR_INVALIDCALL;
             }
         }
@@ -1156,6 +1217,7 @@ static HRESULT volumetexture_init(struct wined3d_texture *texture, const struct
             desc, device, parent, parent_ops, &texture_resource_ops)))
     {
         WARN("Failed to initialize texture, returning %#x.\n", hr);
+        HeapFree(GetProcessHeap(), 0, texture);
         return hr;
     }
 
@@ -1226,7 +1288,6 @@ HRESULT CDECL wined3d_texture_create(struct wined3d_device *device, const struct
     if (FAILED(hr))
     {
         WARN("Failed to initialize texture, returning %#x.\n", hr);
-        HeapFree(GetProcessHeap(), 0, object);
         return hr;
     }
 
diff --git a/dlls/wined3d/utils.c b/dlls/wined3d/utils.c
index 32426d9..f363841 100644
--- a/dlls/wined3d/utils.c
+++ b/dlls/wined3d/utils.c
@@ -2927,7 +2927,7 @@ void set_texture_matrix(const struct wined3d_gl_info *gl_info, const float *smat
                 * check for pixel shaders, and the shader has to undo the default gl divide.
                 *
                 * A more serious problem occurs if the app passes 4 coordinates in, and the
-                * 4th is != 1.0(opengl default). This would have to be fixed in drawStridedSlow
+                * 4th is != 1.0(opengl default). This would have to be fixed in draw_strided_slow
                 * or a replacement shader. */
                 default:
                     mat[3] = mat[7] = mat[11] = 0; mat[15] = 1;
@@ -3227,7 +3227,7 @@ void gen_ffp_frag_op(const struct wined3d_context *context, const struct wined3d
     unsigned int i;
     DWORD ttff;
     DWORD cop, aop, carg0, carg1, carg2, aarg0, aarg1, aarg2;
-    const struct wined3d_surface *rt = state->fb->render_targets[0];
+    const struct wined3d_surface *rt = state->fb.render_targets[0];
     const struct wined3d_gl_info *gl_info = context->gl_info;
     const struct wined3d_d3d_info *d3d_info = context->d3d_info;
 
diff --git a/dlls/wined3d/vertexdeclaration.c b/dlls/wined3d/vertexdeclaration.c
index cf5378c..fc7a110 100644
--- a/dlls/wined3d/vertexdeclaration.c
+++ b/dlls/wined3d/vertexdeclaration.c
@@ -48,6 +48,12 @@ ULONG CDECL wined3d_vertex_declaration_incref(struct wined3d_vertex_declaration
     return refcount;
 }
 
+void wined3d_vertex_declaration_destroy(struct wined3d_vertex_declaration *declaration)
+{
+    HeapFree(GetProcessHeap(), 0, declaration->elements);
+    HeapFree(GetProcessHeap(), 0, declaration);
+}
+
 ULONG CDECL wined3d_vertex_declaration_decref(struct wined3d_vertex_declaration *declaration)
 {
     ULONG refcount = InterlockedDecrement(&declaration->ref);
@@ -56,9 +62,9 @@ ULONG CDECL wined3d_vertex_declaration_decref(struct wined3d_vertex_declaration
 
     if (!refcount)
     {
-        HeapFree(GetProcessHeap(), 0, declaration->elements);
+        const struct wined3d_device *device = declaration->device;
         declaration->parent_ops->wined3d_object_destroyed(declaration->parent);
-        HeapFree(GetProcessHeap(), 0, declaration);
+        wined3d_cs_emit_vertex_declaration_destroy(device->cs, declaration);
     }
 
     return refcount;
diff --git a/dlls/wined3d/volume.c b/dlls/wined3d/volume.c
index 817fe7e..9b1549c 100644
--- a/dlls/wined3d/volume.c
+++ b/dlls/wined3d/volume.c
@@ -34,19 +34,6 @@ void volume_set_container(struct wined3d_volume *volume, struct wined3d_texture
     volume->container = container;
 }
 
-static BOOL volume_prepare_system_memory(struct wined3d_volume *volume)
-{
-    if (volume->resource.heap_memory)
-        return TRUE;
-
-    if (!wined3d_resource_allocate_sysmem(&volume->resource))
-    {
-        ERR("Failed to allocate system memory.\n");
-        return FALSE;
-    }
-    return TRUE;
-}
-
 /* Context activation is done by the caller. */
 static void wined3d_volume_allocate_texture(struct wined3d_volume *volume,
         const struct wined3d_context *context, BOOL srgb)
@@ -56,7 +43,7 @@ static void wined3d_volume_allocate_texture(struct wined3d_volume *volume,
     void *mem = NULL;
 
     if (gl_info->supported[APPLE_CLIENT_STORAGE] && !format->convert
-            && volume_prepare_system_memory(volume))
+            && wined3d_resource_prepare_system_memory(&volume->resource))
     {
         TRACE("Enabling GL_UNPACK_CLIENT_STORAGE_APPLE for volume %p\n", volume);
         gl_info->gl_ops.gl.p_glPixelStorei(GL_UNPACK_CLIENT_STORAGE_APPLE, GL_TRUE);
@@ -78,31 +65,6 @@ static void wined3d_volume_allocate_texture(struct wined3d_volume *volume,
     }
 }
 
-static void wined3d_volume_get_pitch(const struct wined3d_volume *volume, UINT *row_pitch,
-        UINT *slice_pitch)
-{
-    const struct wined3d_format *format = volume->resource.format;
-
-    if (format->flags & WINED3DFMT_FLAG_BLOCKS)
-    {
-        /* Since compressed formats are block based, pitch means the amount of
-         * bytes to the next row of block rather than the next row of pixels. */
-        UINT row_block_count = (volume->resource.width + format->block_width - 1) / format->block_width;
-        UINT slice_block_count = (volume->resource.height + format->block_height - 1) / format->block_height;
-        *row_pitch = row_block_count * format->block_byte_count;
-        *slice_pitch = *row_pitch * slice_block_count;
-    }
-    else
-    {
-        unsigned char alignment = volume->resource.device->surface_alignment;
-        *row_pitch = format->byte_count * volume->resource.width;  /* Bytes / row */
-        *row_pitch = (*row_pitch + alignment - 1) & ~(alignment - 1);
-        *slice_pitch = *row_pitch * volume->resource.height;
-    }
-
-    TRACE("Returning row pitch %u, slice pitch %u.\n", *row_pitch, *slice_pitch);
-}
-
 /* Context activation is done by the caller. */
 void wined3d_volume_upload_data(struct wined3d_volume *volume, const struct wined3d_context *context,
         const struct wined3d_bo_address *data)
@@ -133,7 +95,7 @@ void wined3d_volume_upload_data(struct wined3d_volume *volume, const struct wine
         dst_row_pitch = (dst_row_pitch + alignment - 1) & ~(alignment - 1);
         dst_slice_pitch = dst_row_pitch * height;
 
-        wined3d_volume_get_pitch(volume, &src_row_pitch, &src_slice_pitch);
+        wined3d_resource_get_pitch(&volume->resource, &src_row_pitch, &src_slice_pitch);
 
         mem = HeapAlloc(GetProcessHeap(), 0, dst_slice_pitch * depth);
         format->convert(data->addr, mem, src_row_pitch, src_slice_pitch,
@@ -161,20 +123,6 @@ void wined3d_volume_upload_data(struct wined3d_volume *volume, const struct wine
         HeapFree(GetProcessHeap(), 0, mem);
 }
 
-static void wined3d_volume_validate_location(struct wined3d_volume *volume, DWORD location)
-{
-    TRACE("Volume %p, setting %s.\n", volume, wined3d_debug_location(location));
-    volume->locations |= location;
-    TRACE("new location flags are %s.\n", wined3d_debug_location(volume->locations));
-}
-
-void wined3d_volume_invalidate_location(struct wined3d_volume *volume, DWORD location)
-{
-    TRACE("Volume %p, clearing %s.\n", volume, wined3d_debug_location(location));
-    volume->locations &= ~location;
-    TRACE("new location flags are %s.\n", wined3d_debug_location(volume->locations));
-}
-
 /* Context activation is done by the caller. */
 static void wined3d_volume_download_data(struct wined3d_volume *volume,
         const struct wined3d_context *context, const struct wined3d_bo_address *data)
@@ -210,28 +158,8 @@ static void wined3d_volume_download_data(struct wined3d_volume *volume,
 static void wined3d_volume_evict_sysmem(struct wined3d_volume *volume)
 {
     wined3d_resource_free_sysmem(&volume->resource);
-    wined3d_volume_invalidate_location(volume, WINED3D_LOCATION_SYSMEM);
-}
-
-static DWORD volume_access_from_location(DWORD location)
-{
-    switch (location)
-    {
-        case WINED3D_LOCATION_DISCARDED:
-            return 0;
-
-        case WINED3D_LOCATION_SYSMEM:
-            return WINED3D_RESOURCE_ACCESS_CPU;
-
-        case WINED3D_LOCATION_BUFFER:
-        case WINED3D_LOCATION_TEXTURE_RGB:
-        case WINED3D_LOCATION_TEXTURE_SRGB:
-            return WINED3D_RESOURCE_ACCESS_GPU;
-
-        default:
-            FIXME("Unhandled location %#x.\n", location);
-            return 0;
-    }
+    volume->resource.map_heap_memory = NULL;
+    wined3d_resource_invalidate_location(&volume->resource, WINED3D_LOCATION_SYSMEM);
 }
 
 /* Context activation is done by the caller. */
@@ -273,20 +201,16 @@ static BOOL wined3d_volume_can_evict(const struct wined3d_volume *volume)
 
     return TRUE;
 }
+
 /* Context activation is done by the caller. */
-static void wined3d_volume_load_location(struct wined3d_volume *volume,
+static void wined3d_volume_load_location(struct wined3d_resource *resource,
         struct wined3d_context *context, DWORD location)
 {
-    DWORD required_access = volume_access_from_location(location);
+    struct wined3d_volume *volume = volume_from_resource(resource);
+    DWORD required_access = wined3d_resource_access_from_location(location);
 
     TRACE("Volume %p, loading %s, have %s.\n", volume, wined3d_debug_location(location),
-        wined3d_debug_location(volume->locations));
-
-    if ((volume->locations & location) == location)
-    {
-        TRACE("Location(s) already up to date.\n");
-        return;
-    }
+        wined3d_debug_location(volume->resource.locations));
 
     if ((volume->resource.access_flags & required_access) != required_access)
     {
@@ -305,35 +229,35 @@ static void wined3d_volume_load_location(struct wined3d_volume *volume,
                     && !(volume->flags & WINED3D_VFLAG_SRGB_ALLOCATED)))
                 ERR("Trying to load (s)RGB texture without prior allocation.\n");
 
-            if (volume->locations & WINED3D_LOCATION_DISCARDED)
+            if (volume->resource.locations & WINED3D_LOCATION_DISCARDED)
             {
                 TRACE("Volume previously discarded, nothing to do.\n");
-                wined3d_volume_invalidate_location(volume, WINED3D_LOCATION_DISCARDED);
+                wined3d_resource_invalidate_location(&volume->resource, WINED3D_LOCATION_DISCARDED);
             }
-            else if (volume->locations & WINED3D_LOCATION_SYSMEM)
+            else if (volume->resource.locations & WINED3D_LOCATION_SYSMEM)
             {
                 struct wined3d_bo_address data = {0, volume->resource.heap_memory};
                 wined3d_volume_upload_data(volume, context, &data);
             }
-            else if (volume->locations & WINED3D_LOCATION_BUFFER)
+            else if (volume->resource.locations & WINED3D_LOCATION_BUFFER)
             {
-                struct wined3d_bo_address data = {volume->pbo, NULL};
+                struct wined3d_bo_address data = {volume->resource.buffer->name, NULL};
                 wined3d_volume_upload_data(volume, context, &data);
             }
-            else if (volume->locations & WINED3D_LOCATION_TEXTURE_RGB)
+            else if (volume->resource.locations & WINED3D_LOCATION_TEXTURE_RGB)
             {
                 wined3d_volume_srgb_transfer(volume, context, TRUE);
             }
-            else if (volume->locations & WINED3D_LOCATION_TEXTURE_SRGB)
+            else if (volume->resource.locations & WINED3D_LOCATION_TEXTURE_SRGB)
             {
                 wined3d_volume_srgb_transfer(volume, context, FALSE);
             }
             else
             {
-                FIXME("Implement texture loading from %s.\n", wined3d_debug_location(volume->locations));
+                FIXME("Implement texture loading from %s.\n", wined3d_debug_location(volume->resource.locations));
                 return;
             }
-            wined3d_volume_validate_location(volume, location);
+            wined3d_resource_validate_location(&volume->resource, location);
 
             if (wined3d_volume_can_evict(volume))
                 wined3d_volume_evict_sysmem(volume);
@@ -344,16 +268,11 @@ static void wined3d_volume_load_location(struct wined3d_volume *volume,
             if (!volume->resource.heap_memory)
                 ERR("Trying to load WINED3D_LOCATION_SYSMEM without setting it up first.\n");
 
-            if (volume->locations & WINED3D_LOCATION_DISCARDED)
-            {
-                TRACE("Volume previously discarded, nothing to do.\n");
-                wined3d_volume_invalidate_location(volume, WINED3D_LOCATION_DISCARDED);
-            }
-            else if (volume->locations & (WINED3D_LOCATION_TEXTURE_RGB | WINED3D_LOCATION_TEXTURE_SRGB))
+            if (volume->resource.locations & (WINED3D_LOCATION_TEXTURE_RGB | WINED3D_LOCATION_TEXTURE_SRGB))
             {
                 struct wined3d_bo_address data = {0, volume->resource.heap_memory};
 
-                if (volume->locations & WINED3D_LOCATION_TEXTURE_RGB)
+                if (volume->resource.locations & WINED3D_LOCATION_TEXTURE_RGB)
                     wined3d_texture_bind_and_dirtify(volume->container, context, FALSE);
                 else
                     wined3d_texture_bind_and_dirtify(volume->container, context, TRUE);
@@ -364,26 +283,21 @@ static void wined3d_volume_load_location(struct wined3d_volume *volume,
             else
             {
                 FIXME("Implement WINED3D_LOCATION_SYSMEM loading from %s.\n",
-                        wined3d_debug_location(volume->locations));
+                        wined3d_debug_location(volume->resource.locations));
                 return;
             }
-            wined3d_volume_validate_location(volume, WINED3D_LOCATION_SYSMEM);
+            wined3d_resource_validate_location(&volume->resource, WINED3D_LOCATION_SYSMEM);
             break;
 
         case WINED3D_LOCATION_BUFFER:
-            if (!volume->pbo || !(volume->flags & WINED3D_VFLAG_PBO))
+            if (!volume->resource.buffer || volume->resource.map_binding != WINED3D_LOCATION_BUFFER)
                 ERR("Trying to load WINED3D_LOCATION_BUFFER without setting it up first.\n");
 
-            if (volume->locations & WINED3D_LOCATION_DISCARDED)
+            if (volume->resource.locations & (WINED3D_LOCATION_TEXTURE_RGB | WINED3D_LOCATION_TEXTURE_SRGB))
             {
-                TRACE("Volume previously discarded, nothing to do.\n");
-                wined3d_volume_invalidate_location(volume, WINED3D_LOCATION_DISCARDED);
-            }
-            else if (volume->locations & (WINED3D_LOCATION_TEXTURE_RGB | WINED3D_LOCATION_TEXTURE_SRGB))
-            {
-                struct wined3d_bo_address data = {volume->pbo, NULL};
+                struct wined3d_bo_address data = {volume->resource.buffer->name, NULL};
 
-                if (volume->locations & WINED3D_LOCATION_TEXTURE_RGB)
+                if (volume->resource.locations & WINED3D_LOCATION_TEXTURE_RGB)
                     wined3d_texture_bind_and_dirtify(volume->container, context, FALSE);
                 else
                     wined3d_texture_bind_and_dirtify(volume->container, context, TRUE);
@@ -393,15 +307,15 @@ static void wined3d_volume_load_location(struct wined3d_volume *volume,
             else
             {
                 FIXME("Implement WINED3D_LOCATION_BUFFER loading from %s.\n",
-                        wined3d_debug_location(volume->locations));
+                        wined3d_debug_location(volume->resource.locations));
                 return;
             }
-            wined3d_volume_validate_location(volume, WINED3D_LOCATION_BUFFER);
+            wined3d_resource_validate_location(&volume->resource, WINED3D_LOCATION_BUFFER);
             break;
 
         default:
             FIXME("Implement %s loading from %s.\n", wined3d_debug_location(location),
-                    wined3d_debug_location(volume->locations));
+                    wined3d_debug_location(volume->resource.locations));
     }
 }
 
@@ -418,7 +332,7 @@ void wined3d_volume_load(struct wined3d_volume *volume, struct wined3d_context *
             volume->flags |= WINED3D_VFLAG_SRGB_ALLOCATED;
         }
 
-        wined3d_volume_load_location(volume, context, WINED3D_LOCATION_TEXTURE_SRGB);
+        wined3d_resource_load_location(&volume->resource, context, WINED3D_LOCATION_TEXTURE_SRGB);
     }
     else
     {
@@ -428,39 +342,10 @@ void wined3d_volume_load(struct wined3d_volume *volume, struct wined3d_context *
             volume->flags |= WINED3D_VFLAG_ALLOCATED;
         }
 
-        wined3d_volume_load_location(volume, context, WINED3D_LOCATION_TEXTURE_RGB);
+        wined3d_resource_load_location(&volume->resource, context, WINED3D_LOCATION_TEXTURE_RGB);
     }
 }
 
-/* Context activation is done by the caller. */
-static void wined3d_volume_prepare_pbo(struct wined3d_volume *volume, struct wined3d_context *context)
-{
-    const struct wined3d_gl_info *gl_info = context->gl_info;
-
-    if (volume->pbo)
-        return;
-
-    GL_EXTCALL(glGenBuffersARB(1, &volume->pbo));
-    GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, volume->pbo));
-    GL_EXTCALL(glBufferDataARB(GL_PIXEL_UNPACK_BUFFER_ARB, volume->resource.size, NULL, GL_STREAM_DRAW_ARB));
-    GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, 0));
-    checkGLcall("Create PBO");
-
-    TRACE("Created PBO %u for volume %p.\n", volume->pbo, volume);
-}
-
-static void wined3d_volume_free_pbo(struct wined3d_volume *volume)
-{
-    struct wined3d_context *context = context_acquire(volume->resource.device, NULL);
-    const struct wined3d_gl_info *gl_info = context->gl_info;
-
-    TRACE("Deleting PBO %u belonging to volume %p.\n", volume->pbo, volume);
-    GL_EXTCALL(glDeleteBuffersARB(1, &volume->pbo));
-    checkGLcall("glDeleteBuffersARB");
-    volume->pbo = 0;
-    context_release(context);
-}
-
 static void volume_unload(struct wined3d_resource *resource)
 {
     struct wined3d_volume *volume = volume_from_resource(resource);
@@ -472,27 +357,18 @@ static void volume_unload(struct wined3d_resource *resource)
 
     TRACE("texture %p.\n", resource);
 
-    if (volume_prepare_system_memory(volume))
+    if (wined3d_resource_prepare_system_memory(&volume->resource))
     {
         context = context_acquire(device, NULL);
-        wined3d_volume_load_location(volume, context, WINED3D_LOCATION_SYSMEM);
+        wined3d_resource_load_location(&volume->resource, context, WINED3D_LOCATION_SYSMEM);
         context_release(context);
-        wined3d_volume_invalidate_location(volume, ~WINED3D_LOCATION_SYSMEM);
+        wined3d_resource_invalidate_location(&volume->resource, ~WINED3D_LOCATION_SYSMEM);
     }
     else
     {
         ERR("Out of memory when unloading volume %p.\n", volume);
-        wined3d_volume_validate_location(volume, WINED3D_LOCATION_DISCARDED);
-        wined3d_volume_invalidate_location(volume, ~WINED3D_LOCATION_DISCARDED);
-    }
-
-    if (volume->pbo)
-    {
-        /* Should not happen because only dynamic default pool volumes
-         * have a buffer, and those are not evicted by device_evit_managed_resources
-         * and must be freed before a non-ex device reset. */
-        ERR("Unloading a volume with a buffer\n");
-        wined3d_volume_free_pbo(volume);
+        wined3d_resource_validate_location(&volume->resource, WINED3D_LOCATION_DISCARDED);
+        wined3d_resource_invalidate_location(&volume->resource, ~WINED3D_LOCATION_DISCARDED);
     }
 
     /* The texture name is managed by the container. */
@@ -519,6 +395,11 @@ ULONG CDECL wined3d_volume_incref(struct wined3d_volume *volume)
     return refcount;
 }
 
+void wined3d_volume_cleanup_cs(struct wined3d_volume *volume)
+{
+    HeapFree(GetProcessHeap(), 0, volume);
+}
+
 ULONG CDECL wined3d_volume_decref(struct wined3d_volume *volume)
 {
     ULONG refcount;
@@ -535,12 +416,12 @@ ULONG CDECL wined3d_volume_decref(struct wined3d_volume *volume)
 
     if (!refcount)
     {
-        if (volume->pbo)
-            wined3d_volume_free_pbo(volume);
+        struct wined3d_device *device = volume->resource.device;
 
         resource_cleanup(&volume->resource);
+
         volume->resource.parent_ops->wined3d_object_destroyed(volume->resource.parent);
-        HeapFree(GetProcessHeap(), 0, volume);
+        wined3d_cs_emit_volume_cleanup(device->cs, volume);
     }
 
     return refcount;
@@ -575,34 +456,6 @@ struct wined3d_resource * CDECL wined3d_volume_get_resource(struct wined3d_volum
     return &volume->resource;
 }
 
-static BOOL volume_check_block_align(const struct wined3d_volume *volume,
-        const struct wined3d_box *box)
-{
-    UINT width_mask, height_mask;
-    const struct wined3d_format *format = volume->resource.format;
-
-    if (!box)
-        return TRUE;
-
-    /* This assumes power of two block sizes, but NPOT block sizes would be
-     * silly anyway.
-     *
-     * This also assumes that the format's block depth is 1. */
-    width_mask = format->block_width - 1;
-    height_mask = format->block_height - 1;
-
-    if (box->left & width_mask)
-        return FALSE;
-    if (box->top & height_mask)
-        return FALSE;
-    if (box->right & width_mask && box->right != volume->resource.width)
-        return FALSE;
-    if (box->bottom & height_mask && box->bottom != volume->resource.height)
-        return FALSE;
-
-    return TRUE;
-}
-
 static BOOL wined3d_volume_check_box_dimensions(const struct wined3d_volume *volume,
         const struct wined3d_box *box)
 {
@@ -628,149 +481,33 @@ static BOOL wined3d_volume_check_box_dimensions(const struct wined3d_volume *vol
 HRESULT CDECL wined3d_volume_map(struct wined3d_volume *volume,
         struct wined3d_map_desc *map_desc, const struct wined3d_box *box, DWORD flags)
 {
-    struct wined3d_device *device = volume->resource.device;
-    struct wined3d_context *context;
-    const struct wined3d_gl_info *gl_info;
-    BYTE *base_memory;
+    HRESULT hr;
     const struct wined3d_format *format = volume->resource.format;
 
-    TRACE("volume %p, map_desc %p, box %p, flags %#x.\n",
-            volume, map_desc, box, flags);
-
     map_desc->data = NULL;
     if (!(volume->resource.access_flags & WINED3D_RESOURCE_ACCESS_CPU))
     {
         WARN("Volume %p is not CPU accessible.\n", volume);
         return WINED3DERR_INVALIDCALL;
     }
-    if (volume->resource.map_count)
-    {
-        WARN("Volume is already mapped.\n");
-        return WINED3DERR_INVALIDCALL;
-    }
     if (!wined3d_volume_check_box_dimensions(volume, box))
     {
         WARN("Map box is invalid.\n");
         return WINED3DERR_INVALIDCALL;
     }
-    if ((format->flags & WINED3DFMT_FLAG_BLOCKS) && !volume_check_block_align(volume, box))
+    if ((format->flags & WINED3DFMT_FLAG_BLOCKS) &&
+            !wined3d_resource_check_block_align(&volume->resource, box))
     {
         WARN("Map box is misaligned for %ux%u blocks.\n",
                 format->block_width, format->block_height);
         return WINED3DERR_INVALIDCALL;
     }
 
-    flags = wined3d_resource_sanitize_map_flags(&volume->resource, flags);
-
-    if (volume->flags & WINED3D_VFLAG_PBO)
-    {
-        context = context_acquire(device, NULL);
-        gl_info = context->gl_info;
-
-        wined3d_volume_prepare_pbo(volume, context);
-        if (flags & WINED3D_MAP_DISCARD)
-            wined3d_volume_validate_location(volume, WINED3D_LOCATION_BUFFER);
-        else
-            wined3d_volume_load_location(volume, context, WINED3D_LOCATION_BUFFER);
-
-        GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, volume->pbo));
-
-        if (gl_info->supported[ARB_MAP_BUFFER_RANGE])
-        {
-            GLbitfield mapflags = wined3d_resource_gl_map_flags(flags);
-            mapflags &= ~GL_MAP_FLUSH_EXPLICIT_BIT;
-            base_memory = GL_EXTCALL(glMapBufferRange(GL_PIXEL_UNPACK_BUFFER_ARB,
-                    0, volume->resource.size, mapflags));
-        }
-        else
-        {
-            GLenum access = wined3d_resource_gl_legacy_map_flags(flags);
-            base_memory = GL_EXTCALL(glMapBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, access));
-        }
-
-        GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, 0));
-        checkGLcall("Map PBO");
-
-        context_release(context);
-    }
-    else
-    {
-        if (!volume_prepare_system_memory(volume))
-        {
-            WARN("Out of memory.\n");
-            map_desc->data = NULL;
-            return E_OUTOFMEMORY;
-        }
-
-        if (flags & WINED3D_MAP_DISCARD)
-        {
-            wined3d_volume_validate_location(volume, WINED3D_LOCATION_SYSMEM);
-        }
-        else if (!(volume->locations & WINED3D_LOCATION_SYSMEM))
-        {
-            context = context_acquire(device, NULL);
-            wined3d_volume_load_location(volume, context, WINED3D_LOCATION_SYSMEM);
-            context_release(context);
-        }
-        base_memory = volume->resource.heap_memory;
-    }
-
-    TRACE("Base memory pointer %p.\n", base_memory);
-
-    if (format->flags & WINED3DFMT_FLAG_BROKEN_PITCH)
-    {
-        map_desc->row_pitch = volume->resource.width * format->byte_count;
-        map_desc->slice_pitch = map_desc->row_pitch * volume->resource.height;
-    }
-    else
-    {
-        wined3d_volume_get_pitch(volume, &map_desc->row_pitch, &map_desc->slice_pitch);
-    }
-
-    if (!box)
-    {
-        TRACE("No box supplied - all is ok\n");
-        map_desc->data = base_memory;
-    }
-    else
-    {
-        TRACE("Lock Box (%p) = l %u, t %u, r %u, b %u, fr %u, ba %u\n",
-                box, box->left, box->top, box->right, box->bottom, box->front, box->back);
-
-        if ((format->flags & (WINED3DFMT_FLAG_BLOCKS | WINED3DFMT_FLAG_BROKEN_PITCH)) == WINED3DFMT_FLAG_BLOCKS)
-        {
-            /* Compressed textures are block based, so calculate the offset of
-             * the block that contains the top-left pixel of the locked rectangle. */
-            map_desc->data = base_memory
-                    + (box->front * map_desc->slice_pitch)
-                    + ((box->top / format->block_height) * map_desc->row_pitch)
-                    + ((box->left / format->block_width) * format->block_byte_count);
-        }
-        else
-        {
-            map_desc->data = base_memory
-                    + (map_desc->slice_pitch * box->front)
-                    + (map_desc->row_pitch * box->top)
-                    + (box->left * volume->resource.format->byte_count);
-        }
-    }
-
-    if (!(flags & (WINED3D_MAP_NO_DIRTY_UPDATE | WINED3D_MAP_READONLY)))
-    {
-        wined3d_texture_set_dirty(volume->container);
-
-        if (volume->flags & WINED3D_VFLAG_PBO)
-            wined3d_volume_invalidate_location(volume, ~WINED3D_LOCATION_BUFFER);
-        else
-            wined3d_volume_invalidate_location(volume, ~WINED3D_LOCATION_SYSMEM);
-    }
-
-    volume->resource.map_count++;
-
-    TRACE("Returning memory %p, row pitch %d, slice pitch %d.\n",
-            map_desc->data, map_desc->row_pitch, map_desc->slice_pitch);
+    hr = wined3d_resource_map(&volume->resource, map_desc, box, flags);
+    if (FAILED(hr))
+        return hr;
 
-    return WINED3D_OK;
+    return hr;
 }
 
 struct wined3d_volume * CDECL wined3d_volume_from_resource(struct wined3d_resource *resource)
@@ -780,36 +517,30 @@ struct wined3d_volume * CDECL wined3d_volume_from_resource(struct wined3d_resour
 
 HRESULT CDECL wined3d_volume_unmap(struct wined3d_volume *volume)
 {
-    TRACE("volume %p.\n", volume);
-
-    if (!volume->resource.map_count)
-    {
-        WARN("Trying to unlock an unlocked volume %p.\n", volume);
-        return WINED3DERR_INVALIDCALL;
-    }
-
-    if (volume->flags & WINED3D_VFLAG_PBO)
-    {
-        struct wined3d_device *device = volume->resource.device;
-        struct wined3d_context *context = context_acquire(device, NULL);
-        const struct wined3d_gl_info *gl_info = context->gl_info;
+    HRESULT hr;
 
-        GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, volume->pbo));
-        GL_EXTCALL(glUnmapBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB));
-        GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, 0));
-        checkGLcall("Unmap PBO");
+    if (volume->resource.unmap_dirtify)
+        wined3d_texture_set_dirty(volume->container);
 
-        context_release(context);
-    }
+    hr = wined3d_resource_unmap(&volume->resource);
+    if (hr == WINEDDERR_NOTLOCKED)
+        return WINED3DERR_INVALIDCALL;
+    return hr;
+}
 
-    volume->resource.map_count--;
+static void wined3d_volume_location_invalidated(struct wined3d_resource *resource, DWORD location)
+{
+    struct wined3d_volume *volume = volume_from_resource(resource);
 
-    return WINED3D_OK;
+    if (location & (WINED3D_LOCATION_TEXTURE_RGB | WINED3D_LOCATION_TEXTURE_SRGB))
+        wined3d_texture_set_dirty(volume->container);
 }
 
 static const struct wined3d_resource_ops volume_resource_ops =
 {
     volume_unload,
+    wined3d_volume_location_invalidated,
+    wined3d_volume_load_location,
 };
 
 static HRESULT volume_init(struct wined3d_volume *volume, struct wined3d_texture *container,
@@ -846,14 +577,16 @@ static HRESULT volume_init(struct wined3d_volume *volume, struct wined3d_texture
     }
 
     volume->texture_level = level;
-    volume->locations = WINED3D_LOCATION_DISCARDED;
+    volume->resource.locations = WINED3D_LOCATION_DISCARDED;
+    volume->resource.map_binding = WINED3D_LOCATION_SYSMEM;
 
     if (desc->pool == WINED3D_POOL_DEFAULT && desc->usage & WINED3DUSAGE_DYNAMIC
             && gl_info->supported[ARB_PIXEL_BUFFER_OBJECT]
             && !format->convert)
     {
         wined3d_resource_free_sysmem(&volume->resource);
-        volume->flags |= WINED3D_VFLAG_PBO;
+        volume->resource.map_binding = WINED3D_LOCATION_BUFFER;
+        volume->resource.map_heap_memory = NULL;
     }
 
     volume_set_container(volume, container);
diff --git a/dlls/wined3d/wined3d.spec b/dlls/wined3d/wined3d.spec
index 3243f77..40c8fd1 100644
--- a/dlls/wined3d/wined3d.spec
+++ b/dlls/wined3d/wined3d.spec
@@ -170,12 +170,10 @@
 @ cdecl wined3d_query_incref(ptr)
 @ cdecl wined3d_query_issue(ptr long)
 
-@ cdecl wined3d_resource_free_private_data(ptr ptr)
 @ cdecl wined3d_resource_get_desc(ptr ptr)
 @ cdecl wined3d_resource_get_parent(ptr)
-@ cdecl wined3d_resource_get_private_data(ptr ptr ptr ptr)
 @ cdecl wined3d_resource_set_parent(ptr ptr)
-@ cdecl wined3d_resource_set_private_data(ptr ptr ptr long long)
+@ cdecl wined3d_resource_get_pitch(ptr ptr ptr)
 
 @ cdecl wined3d_rendertarget_view_create(ptr ptr ptr)
 @ cdecl wined3d_rendertarget_view_decref(ptr)
@@ -211,7 +209,6 @@
 @ cdecl wined3d_surface_get_overlay_position(ptr ptr ptr)
 @ cdecl wined3d_surface_get_palette(ptr)
 @ cdecl wined3d_surface_get_parent(ptr)
-@ cdecl wined3d_surface_get_pitch(ptr)
 @ cdecl wined3d_surface_get_priority(ptr)
 @ cdecl wined3d_surface_get_render_target_data(ptr ptr)
 @ cdecl wined3d_surface_get_resource(ptr)
diff --git a/dlls/wined3d/wined3d_main.c b/dlls/wined3d/wined3d_main.c
index 7ab2448..74be323 100644
--- a/dlls/wined3d/wined3d_main.c
+++ b/dlls/wined3d/wined3d_main.c
@@ -85,6 +85,7 @@ struct wined3d_settings wined3d_settings =
     ~0U,            /* No GS shader model limit by default. */
     ~0U,            /* No PS shader model limit by default. */
     FALSE,          /* 3D support enabled by default. */
+    FALSE,          /* No multithreaded CS by default. */
 };
 
 struct wined3d * CDECL wined3d_create(DWORD flags)
@@ -304,6 +305,12 @@ static BOOL wined3d_dll_init(HINSTANCE hInstDLL)
             TRACE("Disabling 3D support.\n");
             wined3d_settings.no_3d = TRUE;
         }
+        if (!get_config_key(hkey, appkey, "CSMT", buffer, size)
+                && !strcmp(buffer,"enabled"))
+        {
+            TRACE("Enabling multithreaded command stream.\n");
+            wined3d_settings.cs_multithreaded = TRUE;
+        }
     }
 
     if (appkey) RegCloseKey( appkey );
diff --git a/dlls/wined3d/wined3d_private.h b/dlls/wined3d/wined3d_private.h
index 0199ef8..2b82630 100644
--- a/dlls/wined3d/wined3d_private.h
+++ b/dlls/wined3d/wined3d_private.h
@@ -5,7 +5,7 @@
  * Copyright 2002-2003 Raphael Junqueira
  * Copyright 2002-2003, 2004 Jason Edmeades
  * Copyright 2005 Oliver Stieber
- * Copyright 2006-2011, 2013 Stefan Dösinger for CodeWeavers
+ * Copyright 2006-2011, 2013-2014 Stefan Dösinger for CodeWeavers
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -31,6 +31,7 @@
 #define WINE_GLAPI
 #endif
 
+#include <assert.h>
 #include <stdarg.h>
 #include <math.h>
 #include <limits.h>
@@ -266,6 +267,7 @@ struct wined3d_settings
     unsigned int max_sm_gs;
     unsigned int max_sm_ps;
     BOOL no_3d;
+    BOOL cs_multithreaded;
 };
 
 extern struct wined3d_settings wined3d_settings DECLSPEC_HIDDEN;
@@ -935,8 +937,9 @@ struct wined3d_stream_info
     WORD use_map; /* MAX_ATTRIBS, 16 */
 };
 
-void draw_primitive(struct wined3d_device *device, UINT start_idx, UINT index_count,
-        UINT start_instance, UINT instance_count, BOOL indexed) DECLSPEC_HIDDEN;
+void draw_primitive(struct wined3d_device *device, const struct wined3d_state *state,
+        UINT start_idx, UINT index_count, UINT start_instance, UINT instance_count,
+        BOOL indexed) DECLSPEC_HIDDEN;
 DWORD get_flexible_vertex_size(DWORD d3dvtVertexType) DECLSPEC_HIDDEN;
 
 #define eps 1e-8f
@@ -1015,6 +1018,8 @@ struct wined3d_occlusion_query
     struct list entry;
     GLuint id;
     struct wined3d_context *context;
+    DWORD samples;
+    BOOL started;
 };
 
 union wined3d_gl_query_object
@@ -1045,6 +1050,36 @@ enum wined3d_event_query_result wined3d_event_query_finish(const struct wined3d_
 void wined3d_event_query_issue(struct wined3d_event_query *query, const struct wined3d_device *device) DECLSPEC_HIDDEN;
 BOOL wined3d_event_query_supported(const struct wined3d_gl_info *gl_info) DECLSPEC_HIDDEN;
 
+struct wined3d_fb_state
+{
+    struct wined3d_surface **render_targets;
+    struct wined3d_surface *depth_stencil;
+    UINT rt_size;
+};
+
+static inline BOOL wined3d_fb_equal(const struct wined3d_fb_state *fb1, const struct wined3d_fb_state *fb2)
+{
+    UINT i;
+
+    if (fb1->depth_stencil != fb2->depth_stencil)
+        return FALSE;
+    if (fb1->rt_size != fb2->rt_size)
+        return FALSE;
+    for (i = 0; i < fb1->rt_size; i++)
+        if (fb1->render_targets[i] != fb2->render_targets[i])
+            return FALSE;
+    return TRUE;
+}
+
+static inline void wined3d_fb_copy(struct wined3d_fb_state *dst, const struct wined3d_fb_state *src)
+{
+    UINT i;
+
+    dst->depth_stencil = src->depth_stencil;
+    for (i = 0; i < min(dst->rt_size, src->rt_size); i++)
+        dst->render_targets[i] = src->render_targets[i];
+}
+
 struct wined3d_context
 {
     const struct wined3d_gl_info *gl_info;
@@ -1059,6 +1094,7 @@ struct wined3d_context
     DWORD                   dirtyArray[STATE_HIGHEST + 1]; /* Won't get bigger than that, a state is never marked dirty 2 times */
     DWORD                   numDirtyEntries;
     DWORD isStateDirty[STATE_HIGHEST / (sizeof(DWORD) * CHAR_BIT) + 1]; /* Bitmap to find out quickly if a state is dirty */
+    struct wined3d_fb_state current_fb;
 
     struct wined3d_swapchain *swapchain;
     struct wined3d_surface *current_rt;
@@ -1086,7 +1122,9 @@ struct wined3d_context
     DWORD lowest_disabled_stage : 4;    /* Max MAX_TEXTURES, 8 */
     DWORD rebind_fbo : 1;
     DWORD needs_set : 1;
-    DWORD padding : 18;
+    DWORD hdc_is_private : 1;
+    DWORD hdc_has_format : 1;           /* only meaningful if hdc_is_private */
+    DWORD padding : 16;
     DWORD shader_update_mask;
     DWORD constant_update_mask;
     DWORD                   numbered_array_mask;
@@ -1149,12 +1187,8 @@ struct wined3d_context
     GLfloat                 fog_coord_value;
     GLfloat                 color[4], fogstart, fogend, fogcolor[4];
     GLuint                  dummy_arbfp_prog;
-};
 
-struct wined3d_fb_state
-{
-    struct wined3d_surface **render_targets;
-    struct wined3d_surface *depth_stencil;
+    GLenum                  offscreenBuffer;
 };
 
 typedef void (*APPLYSTATEFUNC)(struct wined3d_context *ctx, const struct wined3d_state *state, DWORD state_id);
@@ -1282,7 +1316,8 @@ void context_alloc_occlusion_query(struct wined3d_context *context,
 void context_apply_blit_state(struct wined3d_context *context, const struct wined3d_device *device) DECLSPEC_HIDDEN;
 BOOL context_apply_clear_state(struct wined3d_context *context, const struct wined3d_device *device,
         UINT rt_count, const struct wined3d_fb_state *fb) DECLSPEC_HIDDEN;
-BOOL context_apply_draw_state(struct wined3d_context *context, struct wined3d_device *device) DECLSPEC_HIDDEN;
+BOOL context_apply_draw_state(struct wined3d_context *context, const struct wined3d_device *device,
+        const struct wined3d_state *state) DECLSPEC_HIDDEN;
 void context_apply_fbo_state_blit(struct wined3d_context *context, GLenum target,
         struct wined3d_surface *render_target, struct wined3d_surface *depth_stencil, DWORD location) DECLSPEC_HIDDEN;
 void context_active_texture(struct wined3d_context *context, const struct wined3d_gl_info *gl_info,
@@ -1814,7 +1849,7 @@ struct wined3d_stream_state
 struct wined3d_state
 {
     DWORD flags;
-    const struct wined3d_fb_state *fb;
+    struct wined3d_fb_state fb;
 
     struct wined3d_vertex_declaration *vertex_declaration;
     struct wined3d_stream_output stream_output[MAX_STREAM_OUT];
@@ -1856,6 +1891,14 @@ struct wined3d_state
     DWORD render_states[WINEHIGHEST_RENDER_STATE + 1];
 };
 
+struct wined3d_gl_bo
+{
+    GLuint name;
+    GLenum usage;
+    GLenum type_hint;
+    UINT size;
+};
+
 #define WINED3D_UNMAPPED_STAGE ~0U
 
 /* Multithreaded flag. Removed from the public header to signal that
@@ -1910,15 +1953,11 @@ struct wined3d_device
 
     struct wined3d_swapchain **swapchains;
     UINT swapchain_count;
+    struct wined3d_surface *auto_depth_stencil;
 
     struct list             resources; /* a linked list to track resources created by the device */
     struct list             shaders;   /* a linked list to track shaders (pixel and vertex)      */
 
-    /* Render Target Support */
-    struct wined3d_fb_state fb;
-    struct wined3d_surface *onscreen_depth_stencil;
-    struct wined3d_surface *auto_depth_stencil;
-
     /* For rendering to a texture using glCopyTexImage */
     GLuint                  depth_blt_texture;
 
@@ -1928,7 +1967,6 @@ struct wined3d_device
     UINT                    xScreenSpace;
     UINT                    yScreenSpace;
     UINT                    cursorWidth, cursorHeight;
-    struct wined3d_texture *cursor_texture;
     HCURSOR                 hardwareCursor;
 
     /* The Wine logo texture */
@@ -1960,9 +1998,17 @@ LRESULT device_process_message(struct wined3d_device *device, HWND window, BOOL
         UINT message, WPARAM wparam, LPARAM lparam, WNDPROC proc) DECLSPEC_HIDDEN;
 void device_resource_add(struct wined3d_device *device, struct wined3d_resource *resource) DECLSPEC_HIDDEN;
 void device_resource_released(struct wined3d_device *device, struct wined3d_resource *resource) DECLSPEC_HIDDEN;
-void device_switch_onscreen_ds(struct wined3d_device *device, struct wined3d_context *context,
-        struct wined3d_surface *depth_stencil) DECLSPEC_HIDDEN;
 void device_invalidate_state(const struct wined3d_device *device, DWORD state) DECLSPEC_HIDDEN;
+void device_invalidate_shader_constants(const struct wined3d_device *device, DWORD mask) DECLSPEC_HIDDEN;
+void device_exec_update_texture(struct wined3d_context *context, struct wined3d_texture *src_texture,
+        struct wined3d_texture *dst_texture) DECLSPEC_HIDDEN;
+struct wined3d_gl_bo *wined3d_device_get_bo(struct wined3d_device *device, UINT size, GLenum gl_usage,
+        GLenum type_hint, struct wined3d_context *context) DECLSPEC_HIDDEN;
+void wined3d_device_release_bo(struct wined3d_device *device, struct wined3d_gl_bo *bo,
+        const struct wined3d_context *context) DECLSPEC_HIDDEN;
+void device_create_dummy_textures(struct wined3d_device *device, struct wined3d_context *context) DECLSPEC_HIDDEN;
+void device_delete_opengl_contexts_cs(struct wined3d_device *device,
+        struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
 
 static inline BOOL isStateDirty(const struct wined3d_context *context, DWORD state)
 {
@@ -1984,6 +2030,9 @@ static inline void context_invalidate_active_texture(struct wined3d_context *con
 struct wined3d_resource_ops
 {
     void (*resource_unload)(struct wined3d_resource *resource);
+    void (*resource_location_invalidated)(struct wined3d_resource *resource, DWORD location);
+    void (*resource_load_location)(struct wined3d_resource *resource,
+            struct wined3d_context *context, DWORD location);
 };
 
 struct wined3d_resource
@@ -2004,9 +2053,13 @@ struct wined3d_resource
     UINT depth;
     UINT size;
     DWORD priority;
-    void *heap_memory;
+    void *heap_memory, *map_heap_memory, *user_memory, *bitmap_data;
+    struct wined3d_gl_bo *buffer, *map_buffer;
+    UINT custom_row_pitch, custom_slice_pitch;
     struct list resource_list_entry;
-    struct wined3d_private_store private_store;
+    LONG access_fence;
+    BOOL unmap_dirtify;
+    DWORD locations, map_binding;
 
     void *parent;
     const struct wined3d_parent_ops *parent_ops;
@@ -2024,11 +2077,53 @@ HRESULT resource_init(struct wined3d_resource *resource, struct wined3d_device *
 DWORD resource_set_priority(struct wined3d_resource *resource, DWORD priority) DECLSPEC_HIDDEN;
 void resource_unload(struct wined3d_resource *resource) DECLSPEC_HIDDEN;
 BOOL wined3d_resource_allocate_sysmem(struct wined3d_resource *resource) DECLSPEC_HIDDEN;
+void *wined3d_resource_allocate_sysmem2(struct wined3d_resource *resource) DECLSPEC_HIDDEN;
 void wined3d_resource_free_sysmem(struct wined3d_resource *resource) DECLSPEC_HIDDEN;
 DWORD wined3d_resource_sanitize_map_flags(const struct wined3d_resource *resource,
         DWORD flags) DECLSPEC_HIDDEN;
 GLbitfield wined3d_resource_gl_map_flags(DWORD d3d_flags) DECLSPEC_HIDDEN;
-GLenum wined3d_resource_gl_legacy_map_flags(DWORD d3d_flags) DECLSPEC_HIDDEN;
+void wined3d_resource_validate_location(struct wined3d_resource *resource,
+        DWORD location) DECLSPEC_HIDDEN;
+void wined3d_resource_invalidate_location(struct wined3d_resource *resource,
+        DWORD location) DECLSPEC_HIDDEN;
+void wined3d_resource_load_location(struct wined3d_resource *resource,
+        struct wined3d_context *context, DWORD location) DECLSPEC_HIDDEN;
+DWORD wined3d_resource_access_from_location(DWORD location) DECLSPEC_HIDDEN;
+BYTE *wined3d_resource_get_map_ptr(const struct wined3d_resource *resource,
+        const struct wined3d_context *context, DWORD flags) DECLSPEC_HIDDEN;
+void wined3d_resource_release_map_ptr(const struct wined3d_resource *resource,
+        const struct wined3d_context *context) DECLSPEC_HIDDEN;
+BOOL wined3d_resource_prepare_system_memory(struct wined3d_resource *resource) DECLSPEC_HIDDEN;
+BOOL wined3d_resource_prepare_map_memory(struct wined3d_resource *resource,
+        struct wined3d_context *context) DECLSPEC_HIDDEN;
+void wined3d_resource_get_memory(const struct wined3d_resource *resource,
+        DWORD location, struct wined3d_bo_address *data) DECLSPEC_HIDDEN;
+BOOL wined3d_resource_check_block_align(const struct wined3d_resource *resource,
+        const struct wined3d_box *box) DECLSPEC_HIDDEN;
+void wined3d_resource_free_bo(struct wined3d_resource *resource) DECLSPEC_HIDDEN;
+HRESULT wined3d_resource_map(struct wined3d_resource *resource, struct wined3d_map_desc *map_desc,
+        const struct wined3d_box *box, DWORD flags) DECLSPEC_HIDDEN;
+void *wined3d_resource_map_internal(struct wined3d_resource *resource, DWORD flags) DECLSPEC_HIDDEN;
+HRESULT wined3d_resource_unmap(struct wined3d_resource *resource) DECLSPEC_HIDDEN;
+void wined3d_resource_unmap_internal(struct wined3d_resource *resource) DECLSPEC_HIDDEN;
+void wined3d_resource_changed(struct wined3d_resource *resource,
+        struct wined3d_gl_bo *swap_buffer, void *swap_heap_memory) DECLSPEC_HIDDEN;
+void wined3d_resource_cleanup_cs(struct wined3d_resource *resource) DECLSPEC_HIDDEN;
+
+static inline void wined3d_resource_inc_fence(struct wined3d_resource *resource)
+{
+    InterlockedIncrement(&resource->access_fence);
+}
+
+static inline void wined3d_resource_dec_fence(struct wined3d_resource *resource)
+{
+    InterlockedDecrement(&resource->access_fence);
+}
+
+static inline void wined3d_resource_wait_fence(struct wined3d_resource *resource)
+{
+    while(InterlockedCompareExchange(&resource->access_fence, 0, 0));
+}
 
 /* Tests show that the start address of resources is 32 byte aligned */
 #define RESOURCE_ALIGNMENT 16
@@ -2116,6 +2211,7 @@ void wined3d_texture_bind_and_dirtify(struct wined3d_texture *texture,
 void wined3d_texture_load(struct wined3d_texture *texture,
         struct wined3d_context *context, BOOL srgb) DECLSPEC_HIDDEN;
 void wined3d_texture_set_dirty(struct wined3d_texture *texture) DECLSPEC_HIDDEN;
+void wined3d_texture_cleanup_cs(struct wined3d_texture *texture) DECLSPEC_HIDDEN;
 
 #define WINED3D_VFLAG_ALLOCATED         0x00000001
 #define WINED3D_VFLAG_SRGB_ALLOCATED    0x00000002
@@ -2140,10 +2236,9 @@ struct wined3d_volume
     struct wined3d_resource resource;
     struct wined3d_texture *container;
 
-    DWORD flags, locations;
+    DWORD flags;
     GLint texture_level;
     DWORD download_count;
-    GLuint pbo;
 };
 
 static inline struct wined3d_volume *volume_from_resource(struct wined3d_resource *resource)
@@ -2156,14 +2251,13 @@ HRESULT wined3d_volume_create(struct wined3d_texture *container, const struct wi
 void wined3d_volume_load(struct wined3d_volume *volume, struct wined3d_context *context,
         BOOL srgb_mode) DECLSPEC_HIDDEN;
 void volume_set_container(struct wined3d_volume *volume, struct wined3d_texture *container) DECLSPEC_HIDDEN;
-void wined3d_volume_invalidate_location(struct wined3d_volume *volume, DWORD location) DECLSPEC_HIDDEN;
 void wined3d_volume_upload_data(struct wined3d_volume *volume, const struct wined3d_context *context,
         const struct wined3d_bo_address *data) DECLSPEC_HIDDEN;
+void wined3d_volume_cleanup_cs(struct wined3d_volume *volume) DECLSPEC_HIDDEN;
 
 struct wined3d_surface_dib
 {
     HBITMAP DIBsection;
-    void *bitmap_data;
     UINT bitmap_size;
 };
 
@@ -2190,7 +2284,7 @@ struct wined3d_surface_ops
 {
     HRESULT (*surface_private_setup)(struct wined3d_surface *surface);
     void (*surface_realize_palette)(struct wined3d_surface *surface);
-    void (*surface_unmap)(struct wined3d_surface *surface);
+    void (*surface_frontbuffer_updated)(struct wined3d_surface *surface);
 };
 
 struct wined3d_surface
@@ -2200,21 +2294,16 @@ struct wined3d_surface
     struct wined3d_texture *container;
     struct wined3d_swapchain *swapchain;
     struct wined3d_palette *palette; /* D3D7 style palette handling */
-    DWORD draw_binding, map_binding;
-    void *user_memory;
-    DWORD locations;
+    DWORD draw_binding;
 
     DWORD flags;
 
-    UINT pitch;
     UINT pow2Width;
     UINT pow2Height;
 
     /* A method to retrieve the drawable size. Not in the Vtable to make it changeable */
     void (*get_drawable_size)(const struct wined3d_context *context, UINT *width, UINT *height);
 
-    /* PBO */
-    GLuint                    pbo;
     GLuint rb_multisample;
     GLuint rb_resolved;
     GLint texture_level;
@@ -2257,13 +2346,11 @@ void surface_set_dirty(struct wined3d_surface *surface) DECLSPEC_HIDDEN;
 HRESULT surface_color_fill(struct wined3d_surface *s,
         const RECT *rect, const struct wined3d_color *color) DECLSPEC_HIDDEN;
 GLenum surface_get_gl_buffer(const struct wined3d_surface *surface) DECLSPEC_HIDDEN;
-void surface_invalidate_location(struct wined3d_surface *surface, DWORD location) DECLSPEC_HIDDEN;
 BOOL surface_is_offscreen(const struct wined3d_surface *surface) DECLSPEC_HIDDEN;
-void surface_load(struct wined3d_surface *surface, BOOL srgb) DECLSPEC_HIDDEN;
+void surface_load(struct wined3d_surface *surface, struct wined3d_context *context, BOOL srgb) DECLSPEC_HIDDEN;
 void surface_load_ds_location(struct wined3d_surface *surface,
         struct wined3d_context *context, DWORD location) DECLSPEC_HIDDEN;
 void surface_load_fb_texture(struct wined3d_surface *surface, BOOL srgb) DECLSPEC_HIDDEN;
-HRESULT surface_load_location(struct wined3d_surface *surface, DWORD location) DECLSPEC_HIDDEN;
 void surface_modify_ds_location(struct wined3d_surface *surface, DWORD location, UINT w, UINT h) DECLSPEC_HIDDEN;
 void surface_prepare_rb(struct wined3d_surface *surface,
         const struct wined3d_gl_info *gl_info, BOOL multisample) DECLSPEC_HIDDEN;
@@ -2278,10 +2365,15 @@ void surface_translate_drawable_coords(const struct wined3d_surface *surface, HW
 void surface_update_draw_binding(struct wined3d_surface *surface) DECLSPEC_HIDDEN;
 HRESULT surface_upload_from_surface(struct wined3d_surface *dst_surface, const POINT *dst_point,
         struct wined3d_surface *src_surface, const RECT *src_rect) DECLSPEC_HIDDEN;
-void surface_validate_location(struct wined3d_surface *surface, DWORD location) DECLSPEC_HIDDEN;
 HRESULT CDECL wined3d_surface_create(struct wined3d_texture *container,
         const struct wined3d_resource_desc *desc, DWORD flags, struct wined3d_surface **surface) DECLSPEC_HIDDEN;
-void surface_prepare_map_memory(struct wined3d_surface *surface) DECLSPEC_HIDDEN;
+void surface_blt_ugly(struct wined3d_surface *dst_surface, const RECT *dst_rect_in,
+        struct wined3d_surface *src_surface, const RECT *src_rect_in, DWORD flags,
+        const WINEDDBLTFX *fx, enum wined3d_texture_filter_type filter) DECLSPEC_HIDDEN;
+BOOL surface_check_block_align(struct wined3d_surface *surface, const RECT *rect) DECLSPEC_HIDDEN;
+void wined3d_surface_cleanup_cs(struct wined3d_surface *surface) DECLSPEC_HIDDEN;
+void wined3d_surface_getdc_cs(struct wined3d_surface *surface) DECLSPEC_HIDDEN;
+void wined3d_surface_releasedc_cs(struct wined3d_surface *surface) DECLSPEC_HIDDEN;
 
 void get_drawable_size_swapchain(const struct wined3d_context *context, UINT *width, UINT *height) DECLSPEC_HIDDEN;
 void get_drawable_size_backbuffer(const struct wined3d_context *context, UINT *width, UINT *height) DECLSPEC_HIDDEN;
@@ -2289,7 +2381,7 @@ void get_drawable_size_fbo(const struct wined3d_context *context, UINT *width, U
 
 void draw_textured_quad(const struct wined3d_surface *src_surface, struct wined3d_context *context,
         const RECT *src_rect, const RECT *dst_rect, enum wined3d_texture_filter_type filter) DECLSPEC_HIDDEN;
-void flip_surface(struct wined3d_surface *front, struct wined3d_surface *back) DECLSPEC_HIDDEN;
+void surface_flip(struct wined3d_surface *front, struct wined3d_surface *back) DECLSPEC_HIDDEN;
 
 /* Surface flags: */
 #define SFLAG_CONVERTED         0x00000001 /* Converted for color keying or palettized. */
@@ -2362,6 +2454,8 @@ struct wined3d_vertex_declaration
     BOOL half_float_conv_needed;
 };
 
+void wined3d_vertex_declaration_destroy(struct wined3d_vertex_declaration *declaration) DECLSPEC_HIDDEN;
+
 struct wined3d_saved_states
 {
     DWORD transform[(HIGHEST_TRANSFORMSTATE >> 5) + 1];
@@ -2429,30 +2523,56 @@ struct wined3d_stateblock
 void stateblock_init_contained_states(struct wined3d_stateblock *stateblock) DECLSPEC_HIDDEN;
 
 void state_cleanup(struct wined3d_state *state) DECLSPEC_HIDDEN;
-HRESULT state_init(struct wined3d_state *state, struct wined3d_fb_state *fb,
-        const struct wined3d_gl_info *gl_info, const struct wined3d_d3d_info *d3d_info,
-        DWORD flags) DECLSPEC_HIDDEN;
+HRESULT state_init(struct wined3d_state *state, const struct wined3d_gl_info *gl_info,
+        const struct wined3d_d3d_info *d3d_info, DWORD flags) DECLSPEC_HIDDEN;
 void state_unbind_resources(struct wined3d_state *state) DECLSPEC_HIDDEN;
 
+struct wined3d_cs_list
+{
+    struct list blocks;
+};
+
+#define WINED3D_CS_QUEUE_SIZE 0x100000
+#define WINED3D_CS_SPIN_COUNT 10000000
+
+struct wined3d_cs_queue
+{
+    LONG head, tail;
+    BYTE data[WINED3D_CS_QUEUE_SIZE];
+};
+
 struct wined3d_cs_ops
 {
     void *(*require_space)(struct wined3d_cs *cs, size_t size);
-    void (*submit)(struct wined3d_cs *cs);
+    void *(*require_space_prio)(struct wined3d_cs *cs, size_t size);
+    void (*submit)(struct wined3d_cs *cs, size_t size);
+    void (*submit_prio)(struct wined3d_cs *cs, size_t size);
+    void (*finish)(struct wined3d_cs *cs);
+    void (*finish_prio)(struct wined3d_cs *cs);
 };
 
 struct wined3d_cs
 {
     const struct wined3d_cs_ops *ops;
     struct wined3d_device *device;
-    struct wined3d_fb_state fb;
     struct wined3d_state state;
+    HANDLE thread;
+    DWORD thread_id;
+    struct wined3d_surface *onscreen_depth_stencil;
+
+    struct wined3d_cs_queue queue, prio_queue;
+
+    LONG pending_presents;
+    struct list query_poll_list;
 
-    size_t data_size;
-    void *data;
+    HANDLE event;
+    BOOL waiting_for_event;
 };
 
 struct wined3d_cs *wined3d_cs_create(struct wined3d_device *device) DECLSPEC_HIDDEN;
 void wined3d_cs_destroy(struct wined3d_cs *cs) DECLSPEC_HIDDEN;
+void wined3d_cs_switch_onscreen_ds(struct wined3d_cs *cs, struct wined3d_context *context,
+        struct wined3d_surface *depth_stencil) DECLSPEC_HIDDEN;
 
 void wined3d_cs_emit_clear(struct wined3d_cs *cs, DWORD rect_count, const RECT *rects,
         DWORD flags, const struct wined3d_color *color, float depth, DWORD stencil) DECLSPEC_HIDDEN;
@@ -2495,6 +2615,68 @@ void wined3d_cs_emit_set_transform(struct wined3d_cs *cs, enum wined3d_transform
 void wined3d_cs_emit_set_vertex_declaration(struct wined3d_cs *cs,
         struct wined3d_vertex_declaration *declaration) DECLSPEC_HIDDEN;
 void wined3d_cs_emit_set_viewport(struct wined3d_cs *cs, const struct wined3d_viewport *viewport) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_set_consts_f(struct wined3d_cs *cs, UINT start_register, const float *constants,
+        UINT vector4f_count, enum wined3d_shader_type type) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_set_consts_b(struct wined3d_cs *cs, UINT start_register,
+        const BOOL *constants, UINT bool_count, enum wined3d_shader_type type) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_set_consts_i(struct wined3d_cs *cs, UINT start_register,
+        const int *constants, UINT vector4i_count, enum wined3d_shader_type type) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_glfinish(struct wined3d_cs *cs) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_set_base_vertex_index(struct wined3d_cs *cs,
+        UINT base_vertex_index) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_set_primitive_type(struct wined3d_cs *cs,
+        GLenum primitive_type) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_set_light(struct wined3d_cs *cs, const struct wined3d_light_info *light) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_set_light_enable(struct wined3d_cs *cs, UINT idx, BOOL enable) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_blt(struct wined3d_cs *cs, struct wined3d_surface *dst_surface,
+        const RECT *dst_rect, struct wined3d_surface *src_surface,
+        const RECT *src_rect, DWORD flags, const WINEDDBLTFX *fx,
+        enum wined3d_texture_filter_type filter) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_color_fill(struct wined3d_cs *cs, struct wined3d_surface *surface,
+        const RECT *rect, const struct wined3d_color *color) DECLSPEC_HIDDEN;
+void *wined3d_cs_emit_resource_map(struct wined3d_cs *cs, struct wined3d_resource *resource,
+        DWORD flags) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_resource_unmap(struct wined3d_cs *cs, struct wined3d_resource *resource) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_resource_changed(struct wined3d_cs *cs, struct wined3d_resource *resource,
+        struct wined3d_gl_bo *swap_buffer, void *swap_heap_memory) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_swap_mem(struct wined3d_cs *cs, struct wined3d_buffer *buffer,
+        BYTE *mem) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_buffer_invalidate_bo_range(struct wined3d_cs *cs,
+        struct wined3d_buffer *buffer, UINT offset, UINT size) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_query_issue(struct wined3d_cs *cs, struct wined3d_query *query,
+        DWORD flags) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_query_get_data(struct wined3d_cs *cs, struct wined3d_query *query, void *data,
+        UINT data_size, DWORD flags, HRESULT *ret) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_query_destroy(struct wined3d_cs *cs, struct wined3d_query *query) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_buffer_preload(struct wined3d_cs *cs, struct wined3d_buffer *buffer) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_vertex_declaration_destroy(struct wined3d_cs *cs,
+        struct wined3d_vertex_declaration *declaration) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_shader_cleanup(struct wined3d_cs *cs, struct wined3d_shader *shader) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_update_surface(struct wined3d_cs *cs, struct wined3d_surface *src,
+        const RECT *src_rect, struct wined3d_surface *dst, const POINT *dst_point) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_texture_preload(struct wined3d_cs *cs, struct wined3d_texture *texture) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_surface_preload(struct wined3d_cs *cs, struct wined3d_surface *surface) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_update_texture(struct wined3d_cs *cs, struct wined3d_texture *src,
+        struct wined3d_texture *dst) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_evict_resource(struct wined3d_cs *cs, struct wined3d_resource *resource) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_create_vbo(struct wined3d_cs *cs, struct wined3d_buffer *buffer) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_resource_cleanup(struct wined3d_cs *cs,
+        struct wined3d_resource *resource) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_buffer_cleanup(struct wined3d_cs *cs, struct wined3d_buffer *buffer) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_volume_cleanup(struct wined3d_cs *cs, struct wined3d_volume *volume) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_surface_cleanup(struct wined3d_cs *cs, struct wined3d_surface *surface) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_texture_cleanup(struct wined3d_cs *cs, struct wined3d_texture *texture) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_create_dummy_textures(struct wined3d_cs *cs) DECLSPEC_HIDDEN;
+HRESULT wined3d_cs_emit_create_swapchain_context(struct wined3d_cs *cs,
+        struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_delete_opengl_contexts(struct wined3d_cs *cs,
+        struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_set_palette(struct wined3d_cs *cs, struct wined3d_surface *surface,
+        struct wined3d_palette *palette) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_palette_set_entries(struct wined3d_cs *cs, struct wined3d_palette *palette,
+        DWORD flags, DWORD start, DWORD count, const PALETTEENTRY *entries) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_getdc(struct wined3d_cs *cs, struct wined3d_surface *surface) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_releasedc(struct wined3d_cs *cs, struct wined3d_surface *surface) DECLSPEC_HIDDEN;
 
 /* Direct3D terminology with little modifications. We do not have an issued state
  * because only the driver knows about it, but we have a created state because d3d
@@ -2509,7 +2691,8 @@ enum query_state {
 struct wined3d_query_ops
 {
     HRESULT (*query_get_data)(struct wined3d_query *query, void *data, DWORD data_size, DWORD flags);
-    HRESULT (*query_issue)(struct wined3d_query *query, DWORD flags);
+    BOOL (*query_poll)(struct wined3d_query *query);
+    BOOL (*query_issue)(struct wined3d_query *query, DWORD flags);
 };
 
 struct wined3d_query
@@ -2521,8 +2704,13 @@ struct wined3d_query
     enum wined3d_query_type type;
     DWORD data_size;
     void                     *extendedData;
+
+    LONG                     counter_main, counter_retrieved;
+    struct list              poll_list_entry;
 };
 
+void wined3d_query_destroy(struct wined3d_query *query) DECLSPEC_HIDDEN;
+
 /* TODO: Add tests and support for FLOAT16_4 POSITIONT, D3DCOLOR position, other
  * fixed function semantics as D3DCOLOR or FLOAT16 */
 enum wined3d_buffer_conversion_type
@@ -2541,6 +2729,7 @@ struct wined3d_map_range
 struct wined3d_buffer
 {
     struct wined3d_resource resource;
+    BYTE *map_mem;
 
     struct wined3d_buffer_desc desc;
 
@@ -2572,6 +2761,11 @@ void buffer_get_memory(struct wined3d_buffer *buffer, struct wined3d_context *co
 BYTE *buffer_get_sysmem(struct wined3d_buffer *This, struct wined3d_context *context) DECLSPEC_HIDDEN;
 void buffer_internal_preload(struct wined3d_buffer *buffer, struct wined3d_context *context,
         const struct wined3d_state *state) DECLSPEC_HIDDEN;
+void buffer_invalidate_bo_range(struct wined3d_buffer *This, UINT offset, UINT size) DECLSPEC_HIDDEN;
+void buffer_swap_mem(struct wined3d_buffer *buffer, BYTE *mem) DECLSPEC_HIDDEN;
+void buffer_create_buffer_object(struct wined3d_buffer *This,
+        struct wined3d_context *context) DECLSPEC_HIDDEN;
+void wined3d_buffer_cleanup_cs(struct wined3d_buffer *buffer) DECLSPEC_HIDDEN;
 
 struct wined3d_rendertarget_view
 {
@@ -2584,7 +2778,8 @@ struct wined3d_rendertarget_view
 struct wined3d_swapchain_ops
 {
     void (*swapchain_present)(struct wined3d_swapchain *swapchain, const RECT *src_rect,
-            const RECT *dst_rect, const RGNDATA *dirty_region, DWORD flags);
+            const RECT *dst_rect, const RGNDATA *dirty_region, DWORD flags,
+            struct wined3d_surface *depth_stencil);
 };
 
 struct wined3d_swapchain
@@ -2627,6 +2822,8 @@ void swapchain_destroy_contexts(struct wined3d_swapchain *swapchain) DECLSPEC_HI
 HDC swapchain_get_backup_dc(struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
 void swapchain_update_draw_bindings(struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
 void swapchain_update_render_to_fbo(struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
+HRESULT swapchain_create_context_cs(struct wined3d_device *device,
+        struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
 
 /*****************************************************************************
  * Utility function prototypes
@@ -2845,6 +3042,7 @@ unsigned int shader_find_free_input_register(const struct wined3d_shader_reg_map
 void shader_generate_main(const struct wined3d_shader *shader, struct wined3d_shader_buffer *buffer,
         const struct wined3d_shader_reg_maps *reg_maps, const DWORD *byte_code, void *backend_ctx) DECLSPEC_HIDDEN;
 BOOL shader_match_semantic(const char *semantic_name, enum wined3d_decl_usage usage) DECLSPEC_HIDDEN;
+void shader_cleanup(struct wined3d_shader *shader) DECLSPEC_HIDDEN;
 
 static inline BOOL shader_is_scalar(const struct wined3d_shader_register *reg)
 {
@@ -2943,6 +3141,9 @@ struct wined3d_palette
     DWORD flags;
 };
 
+void wined3d_exec_palette_set_entries(struct wined3d_palette *palette, DWORD flags,
+        DWORD start, DWORD count, const PALETTEENTRY *entries) DECLSPEC_HIDDEN;
+
 /* DirectDraw utility functions */
 extern enum wined3d_format_id pixelformat_for_depth(DWORD depth) DECLSPEC_HIDDEN;
 
diff --git a/dlls/winemac.drv/macdrv_cocoa.h b/dlls/winemac.drv/macdrv_cocoa.h
index 564910c..1550280 100644
--- a/dlls/winemac.drv/macdrv_cocoa.h
+++ b/dlls/winemac.drv/macdrv_cocoa.h
@@ -89,7 +89,7 @@
 
 
 #ifndef DECLSPEC_HIDDEN
-# if defined(__MSC_VER) || defined(__MINGW32__) || defined(__CYGWIN__)
+# if defined(_MSC_VER) || defined(__MINGW32__) || defined(__CYGWIN__)
 #  define DECLSPEC_HIDDEN
 # elif defined(__GNUC__) && ((__GNUC__ > 3) || ((__GNUC__ == 3) && (__GNUC_MINOR__ >= 3)))
 #  define DECLSPEC_HIDDEN __attribute__((visibility ("hidden")))
diff --git a/dlls/winemac.drv/opengl.c b/dlls/winemac.drv/opengl.c
index 825e523..0187822 100644
--- a/dlls/winemac.drv/opengl.c
+++ b/dlls/winemac.drv/opengl.c
@@ -1311,27 +1311,28 @@ static BOOL get_gl_view_window_rect(struct macdrv_win_data *data, macdrv_window
  */
 static BOOL set_win_format(struct macdrv_win_data *data, int format)
 {
-    macdrv_window cocoa_window;
-
     TRACE("hwnd %p format %d\n", data->hwnd, format);
 
-    if (!get_gl_view_window_rect(data, &cocoa_window, &data->gl_rect))
+    if (!data->gl_view)
     {
-        ERR("no top-level parent with Cocoa window in this process\n");
-        return FALSE;
-    }
+        macdrv_window cocoa_window;
 
-    if (data->gl_view) macdrv_dispose_view(data->gl_view);
-    data->gl_view = macdrv_create_view(cocoa_window, cgrect_from_rect(data->gl_rect));
+        if (!get_gl_view_window_rect(data, &cocoa_window, &data->gl_rect))
+        {
+            ERR("no top-level parent with Cocoa window in this process\n");
+            return FALSE;
+        }
 
-    if (!data->gl_view)
-    {
-        WARN("failed to create GL view for window %p rect %s\n", cocoa_window, wine_dbgstr_rect(&data->gl_rect));
-        return FALSE;
-    }
+        data->gl_view = macdrv_create_view(cocoa_window, cgrect_from_rect(data->gl_rect));
+        if (!data->gl_view)
+        {
+            WARN("failed to create GL view for window %p rect %s\n", cocoa_window, wine_dbgstr_rect(&data->gl_rect));
+            return FALSE;
+        }
 
-    TRACE("created GL view %p in window %p at %s\n", data->gl_view, cocoa_window,
-          wine_dbgstr_rect(&data->gl_rect));
+        TRACE("created GL view %p in window %p at %s\n", data->gl_view, cocoa_window,
+              wine_dbgstr_rect(&data->gl_rect));
+    }
 
     data->pixel_format = format;
 
@@ -1503,13 +1504,25 @@ static BOOL set_swap_interval(struct wgl_context *context, long interval)
  */
 static void sync_swap_interval(struct wgl_context *context)
 {
-    struct macdrv_win_data *data;
-
-    if (InterlockedCompareExchange(&context->update_swap_interval, FALSE, TRUE) &&
-        (data = get_win_data(context->draw_hwnd)))
+    if (InterlockedCompareExchange(&context->update_swap_interval, FALSE, TRUE))
     {
-        set_swap_interval(context, data->swap_interval);
-        release_win_data(data);
+        int interval;
+
+        if (context->draw_hwnd)
+        {
+            struct macdrv_win_data *data = get_win_data(context->draw_hwnd);
+            if (data)
+            {
+                interval = data->swap_interval;
+                release_win_data(data);
+            }
+            else /* window was destroyed? */
+                interval = 1;
+        }
+        else /* pbuffer */
+            interval = 0;
+
+        set_swap_interval(context, interval);
     }
 }
 
@@ -2717,6 +2730,10 @@ static BOOL macdrv_wglMakeContextCurrentARB(HDC draw_hdc, HDC read_hdc, struct w
                 SetLastError(ERROR_INVALID_PIXEL_FORMAT);
                 return FALSE;
             }
+
+            if (allow_vsync &&
+                (InterlockedCompareExchange(&context->update_swap_interval, FALSE, TRUE) || pbuffer != context->draw_pbuffer))
+                set_swap_interval(context, 0);
         }
         else
         {
@@ -3018,7 +3035,7 @@ static BOOL macdrv_wglSetPixelFormatWINE(HDC hdc, int fmt)
 static BOOL macdrv_wglSwapIntervalEXT(int interval)
 {
     struct wgl_context *context = NtCurrentTeb()->glContext;
-    struct macdrv_win_data *data;
+    BOOL changed = FALSE;
 
     TRACE("interval %d\n", interval);
 
@@ -3030,6 +3047,20 @@ static BOOL macdrv_wglSwapIntervalEXT(int interval)
     if (interval > 1)
         interval = 1;
 
+    if (context->draw_hwnd)
+    {
+        struct macdrv_win_data *data = get_win_data(context->draw_hwnd);
+        if (data)
+        {
+            changed = data->swap_interval != interval;
+            if (changed)
+                data->swap_interval = interval;
+            release_win_data(data);
+        }
+    }
+    else /* pbuffer */
+        interval = 0;
+
     InterlockedExchange(&context->update_swap_interval, FALSE);
     if (!set_swap_interval(context, interval))
     {
@@ -3037,25 +3068,17 @@ static BOOL macdrv_wglSwapIntervalEXT(int interval)
         return FALSE;
     }
 
-    if ((data = get_win_data(context->draw_hwnd)))
+    if (changed)
     {
-        BOOL changed = data->swap_interval != interval;
-        if (changed)
-            data->swap_interval = interval;
-        release_win_data(data);
+        struct wgl_context *ctx;
 
-        if (changed)
+        EnterCriticalSection(&context_section);
+        LIST_FOR_EACH_ENTRY(ctx, &context_list, struct wgl_context, entry)
         {
-            struct wgl_context *ctx;
-
-            EnterCriticalSection(&context_section);
-            LIST_FOR_EACH_ENTRY(ctx, &context_list, struct wgl_context, entry)
-            {
-                if (ctx != context && ctx->draw_hwnd == context->draw_hwnd)
-                    InterlockedExchange(&context->update_swap_interval, TRUE);
-            }
-            LeaveCriticalSection(&context_section);
+            if (ctx != context && ctx->draw_hwnd == context->draw_hwnd)
+                InterlockedExchange(&context->update_swap_interval, TRUE);
         }
+        LeaveCriticalSection(&context_section);
     }
 
     return TRUE;
diff --git a/dlls/winex11.drv/opengl.c b/dlls/winex11.drv/opengl.c
index b3bd45b..2e28077 100644
--- a/dlls/winex11.drv/opengl.c
+++ b/dlls/winex11.drv/opengl.c
@@ -1909,6 +1909,7 @@ static void wglFinish(void)
     escape.code = X11DRV_FLUSH_GL_DRAWABLE;
     escape.gl_drawable = 0;
 
+    ERR("wglFinish\n");
     if ((gl = get_gl_drawable( WindowFromDC( ctx->hdc ), 0 )))
     {
         switch (gl->type)
@@ -1934,6 +1935,7 @@ static void wglFlush(void)
     escape.code = X11DRV_FLUSH_GL_DRAWABLE;
     escape.gl_drawable = 0;
 
+    ERR("wglFlush\n");
     if ((gl = get_gl_drawable( WindowFromDC( ctx->hdc ), 0 )))
     {
         switch (gl->type)
diff --git a/dlls/winhttp/cookie.c b/dlls/winhttp/cookie.c
index af881ea..6e104b2 100644
--- a/dlls/winhttp/cookie.c
+++ b/dlls/winhttp/cookie.c
@@ -134,10 +134,6 @@ static cookie_t *parse_cookie( const WCHAR *string )
     const WCHAR *p;
     int len;
 
-    if (!(cookie = heap_alloc_zero( sizeof(cookie_t) ))) return NULL;
-
-    list_init( &cookie->entry );
-
     if (!(p = strchrW( string, '=' )))
     {
         WARN("no '=' in %s\n", debugstr_w(string));
@@ -148,6 +144,11 @@ static cookie_t *parse_cookie( const WCHAR *string )
         WARN("empty cookie name in %s\n", debugstr_w(string));
         return NULL;
     }
+
+    if (!(cookie = heap_alloc_zero( sizeof(cookie_t) ))) return NULL;
+
+    list_init( &cookie->entry );
+
     len = p - string;
     if (!(cookie->name = heap_alloc( (len + 1) * sizeof(WCHAR) )))
     {
diff --git a/dlls/winhttp/tests/winhttp.c b/dlls/winhttp/tests/winhttp.c
index e14f366..354f46f 100644
--- a/dlls/winhttp/tests/winhttp.c
+++ b/dlls/winhttp/tests/winhttp.c
@@ -1721,6 +1721,11 @@ static void test_resolve_timeout(void)
 
         SetLastError(0xdeadbeef);
         ret = WinHttpSendRequest(req, NULL, 0, NULL, 0, 0, 0);
+        if(ret == 1)
+        {
+            skip("nxdomain returned success. Broken ISP redirects?\n");
+            return;
+        }
         ok(!ret, "sent request\n");
         ok(GetLastError() == ERROR_WINHTTP_NAME_NOT_RESOLVED,
            "expected ERROR_WINHTTP_NAME_NOT_RESOLVED got %u\n", GetLastError());
diff --git a/dlls/wininet/tests/http.c b/dlls/wininet/tests/http.c
index e40cdb6..70e82db 100644
--- a/dlls/wininet/tests/http.c
+++ b/dlls/wininet/tests/http.c
@@ -2196,7 +2196,7 @@ static DWORD CALLBACK server_thread(LPVOID param)
             if (!memcmp(buffer, "GET ", sizeof("GET ")-1) &&
                 !strstr(buffer, "Cache-Control: no-cache\r\n")) send(c, okmsg, sizeof(okmsg)-1, 0);
             else if (strstr(buffer, "Cache-Control: no-cache\r\n")) send(c, okmsg, sizeof(okmsg)-1, 0);
-            send(c, notokmsg, sizeof(notokmsg)-1, 0);
+            else send(c, notokmsg, sizeof(notokmsg)-1, 0);
         }
         if (strstr(buffer, "GET /test_premature_disconnect"))
             trace("closing connection\n");
@@ -2213,7 +2213,7 @@ static DWORD CALLBACK server_thread(LPVOID param)
 static void test_basic_request(int port, const char *verb, const char *url)
 {
     HINTERNET hi, hc, hr;
-    DWORD r, count;
+    DWORD r, count, error;
     char buffer[0x100];
 
     hi = InternetOpenA(NULL, INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0);
@@ -2225,7 +2225,10 @@ static void test_basic_request(int port, const char *verb, const char *url)
     hr = HttpOpenRequestA(hc, verb, url, NULL, NULL, NULL, 0, 0);
     ok(hr != NULL, "HttpOpenRequest failed\n");
 
+    SetLastError(0xdeadbeef);
     r = HttpSendRequestA(hr, NULL, 0, NULL, 0);
+    error = GetLastError();
+    ok(error == ERROR_SUCCESS || broken(error != ERROR_SUCCESS), "expected ERROR_SUCCESS, got %u\n", error);
     ok(r, "HttpSendRequest failed\n");
 
     count = 0;
@@ -2241,32 +2244,6 @@ static void test_basic_request(int port, const char *verb, const char *url)
     InternetCloseHandle(hi);
 }
 
-static void test_last_error(int port)
-{
-    HINTERNET hi, hc, hr;
-    DWORD error;
-    BOOL r;
-
-    hi = InternetOpenA(NULL, INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0);
-    ok(hi != NULL, "open failed\n");
-
-    hc = InternetConnectA(hi, "localhost", port, NULL, NULL, INTERNET_SERVICE_HTTP, 0, 0);
-    ok(hc != NULL, "connect failed\n");
-
-    hr = HttpOpenRequestA(hc, NULL, "/test1", NULL, NULL, NULL, 0, 0);
-    ok(hr != NULL, "HttpOpenRequest failed\n");
-
-    SetLastError(0xdeadbeef);
-    r = HttpSendRequestA(hr, NULL, 0, NULL, 0);
-    error = GetLastError();
-    ok(r, "HttpSendRequest failed\n");
-    ok(error == ERROR_SUCCESS || broken(error != ERROR_SUCCESS), "expected ERROR_SUCCESS, got %u\n", error);
-
-    InternetCloseHandle(hr);
-    InternetCloseHandle(hc);
-    InternetCloseHandle(hi);
-}
-
 static void test_proxy_indirect(int port)
 {
     HINTERNET hi, hc, hr;
@@ -3078,12 +3055,17 @@ static void test_no_content(int port)
     CHECK_NOTIFIED(INTERNET_STATUS_REQUEST_SENT);
     CHECK_NOTIFIED(INTERNET_STATUS_RECEIVING_RESPONSE);
     CHECK_NOTIFIED(INTERNET_STATUS_RESPONSE_RECEIVED);
-    CHECK_NOTIFIED(INTERNET_STATUS_CLOSING_CONNECTION);
-    CHECK_NOTIFIED(INTERNET_STATUS_CONNECTION_CLOSED);
     CHECK_NOTIFIED(INTERNET_STATUS_REQUEST_COMPLETE);
 
     close_async_handle(session, hCompleteEvent, 2);
     CloseHandle(hCompleteEvent);
+
+    /*
+     * The connection should be closed before closing handle. This is true for most
+     * wininet versions (including Wine), but some old win2k versions fail to do that.
+     */
+    CHECK_NOTIFIED(INTERNET_STATUS_CLOSING_CONNECTION);
+    CHECK_NOTIFIED(INTERNET_STATUS_CONNECTION_CLOSED);
 }
 
 static void test_conn_close(int port)
@@ -3933,6 +3915,7 @@ static void test_cache_control_verb(int port)
     ret = HttpSendRequestA(request, NULL, 0, NULL, 0);
     ok(ret, "HttpSendRequest failed %u\n", GetLastError());
     test_status_code(request, 200);
+    InternetCloseHandle(request);
 
     request = HttpOpenRequestA(connect, "POST", "/test_cache_control_verb", NULL, NULL, NULL,
                               INTERNET_FLAG_NO_CACHE_WRITE, 0);
@@ -3940,6 +3923,7 @@ static void test_cache_control_verb(int port)
     ret = HttpSendRequestA(request, NULL, 0, NULL, 0);
     ok(ret, "HttpSendRequest failed %u\n", GetLastError());
     test_status_code(request, 200);
+    InternetCloseHandle(request);
 
     request = HttpOpenRequestA(connect, "HEAD", "/test_cache_control_verb", NULL, NULL, NULL,
                               INTERNET_FLAG_NO_CACHE_WRITE, 0);
@@ -3947,6 +3931,7 @@ static void test_cache_control_verb(int port)
     ret = HttpSendRequestA(request, NULL, 0, NULL, 0);
     ok(ret, "HttpSendRequest failed %u\n", GetLastError());
     test_status_code(request, 200);
+    InternetCloseHandle(request);
 
     request = HttpOpenRequestA(connect, "GET", "/test_cache_control_verb", NULL, NULL, NULL,
                               INTERNET_FLAG_NO_CACHE_WRITE, 0);
@@ -3954,8 +3939,8 @@ static void test_cache_control_verb(int port)
     ret = HttpSendRequestA(request, NULL, 0, NULL, 0);
     ok(ret, "HttpSendRequest failed %u\n", GetLastError());
     test_status_code(request, 200);
-
     InternetCloseHandle(request);
+
     InternetCloseHandle(connect);
     InternetCloseHandle(session);
 }
@@ -3994,7 +3979,6 @@ static void test_http_connection(void)
     test_response_without_headers(si.port);
     test_HttpQueryInfo(si.port);
     test_HttpSendRequestW(si.port);
-    test_last_error(si.port);
     test_options(si.port);
     test_no_content(si.port);
     test_conn_close(si.port);
diff --git a/dlls/winmm/tests/capture.c b/dlls/winmm/tests/capture.c
index 05c5735..54c3793 100644
--- a/dlls/winmm/tests/capture.c
+++ b/dlls/winmm/tests/capture.c
@@ -454,7 +454,8 @@ static void wave_in_test_device(UINT_PTR device)
     format.cbSize=0;
     rc=waveInOpen(&win,device,&format,0,0,CALLBACK_NULL|WAVE_FORMAT_DIRECT);
     ok(rc==MMSYSERR_NOERROR || rc==WAVERR_BADFORMAT ||
-       rc==MMSYSERR_INVALFLAG || rc==MMSYSERR_INVALPARAM,
+       rc==MMSYSERR_INVALFLAG || rc==MMSYSERR_INVALPARAM ||
+       rc==MMSYSERR_ALLOCATED,
        "waveInOpen(%s): returned: %s\n",dev_name(device),wave_in_error(rc));
     if (rc==MMSYSERR_NOERROR) {
         waveInClose(win);
@@ -472,7 +473,8 @@ static void wave_in_test_device(UINT_PTR device)
     format.cbSize=0;
     rc=waveInOpen(&win,device,&format,0,0,CALLBACK_NULL|WAVE_FORMAT_DIRECT);
     ok(rc==MMSYSERR_NOERROR || rc==WAVERR_BADFORMAT ||
-       rc==MMSYSERR_INVALFLAG || rc==MMSYSERR_INVALPARAM,
+       rc==MMSYSERR_INVALFLAG || rc==MMSYSERR_INVALPARAM ||
+       rc==MMSYSERR_ALLOCATED,
        "waveInOpen(%s): returned: %s\n",dev_name(device),wave_in_error(rc));
     if (rc==MMSYSERR_NOERROR) {
         waveInClose(win);
@@ -496,7 +498,8 @@ static void wave_in_test_device(UINT_PTR device)
     rc=waveInOpen(&win,device,&wfex.Format,0,0,
                   CALLBACK_NULL|WAVE_FORMAT_DIRECT);
     ok(rc==MMSYSERR_NOERROR || rc==WAVERR_BADFORMAT ||
-       rc==MMSYSERR_INVALFLAG || rc==MMSYSERR_INVALPARAM,
+       rc==MMSYSERR_INVALFLAG || rc==MMSYSERR_INVALPARAM ||
+       rc==MMSYSERR_ALLOCATED,
        "waveInOpen(%s): returned: %s\n",dev_name(device),wave_in_error(rc));
     if (rc==MMSYSERR_NOERROR) {
         waveInClose(win);
@@ -520,7 +523,8 @@ static void wave_in_test_device(UINT_PTR device)
     rc=waveInOpen(&win,device,&wfex.Format,0,0,
                   CALLBACK_NULL|WAVE_FORMAT_DIRECT);
     ok(rc==MMSYSERR_NOERROR || rc==WAVERR_BADFORMAT ||
-       rc==MMSYSERR_INVALFLAG || rc==MMSYSERR_INVALPARAM,
+       rc==MMSYSERR_INVALFLAG || rc==MMSYSERR_INVALPARAM ||
+       rc==MMSYSERR_ALLOCATED,
        "waveInOpen(%s): returned: %s\n",dev_name(device),wave_in_error(rc));
     if (rc==MMSYSERR_NOERROR) {
         waveInClose(win);
@@ -544,7 +548,8 @@ static void wave_in_test_device(UINT_PTR device)
     rc=waveInOpen(&win,device,&wfex.Format,0,0,
                   CALLBACK_NULL|WAVE_FORMAT_DIRECT);
     ok(rc==MMSYSERR_NOERROR || rc==WAVERR_BADFORMAT ||
-       rc==MMSYSERR_INVALFLAG || rc==MMSYSERR_INVALPARAM,
+       rc==MMSYSERR_INVALFLAG || rc==MMSYSERR_INVALPARAM ||
+       rc==MMSYSERR_ALLOCATED,
        "waveInOpen(%s): returned: %s\n",dev_name(device),wave_in_error(rc));
     if (rc==MMSYSERR_NOERROR) {
         waveInClose(win);
@@ -571,7 +576,8 @@ static void wave_in_test_device(UINT_PTR device)
     rc=waveInOpen(&win,device,&wfex.Format,0,0,
                   CALLBACK_NULL|WAVE_FORMAT_DIRECT);
     ok(rc==MMSYSERR_NOERROR || rc==WAVERR_BADFORMAT ||
-       rc==MMSYSERR_INVALFLAG || rc==MMSYSERR_INVALPARAM,
+       rc==MMSYSERR_INVALFLAG || rc==MMSYSERR_INVALPARAM ||
+       rc==MMSYSERR_ALLOCATED,
        "waveInOpen(%s): returned: %s\n",dev_name(device),wave_in_error(rc));
     if (rc==MMSYSERR_NOERROR) {
         waveInClose(win);
@@ -596,7 +602,8 @@ static void wave_in_test_device(UINT_PTR device)
     rc=waveInOpen(&win,device,&wfex.Format,0,0,
                   CALLBACK_NULL|WAVE_FORMAT_DIRECT);
     ok(rc==MMSYSERR_NOERROR || rc==WAVERR_BADFORMAT ||
-       rc==MMSYSERR_INVALFLAG || rc==MMSYSERR_INVALPARAM,
+       rc==MMSYSERR_INVALFLAG || rc==MMSYSERR_INVALPARAM ||
+       rc==MMSYSERR_ALLOCATED,
        "waveInOpen(%s): returned: %s\n",dev_name(device),wave_in_error(rc));
     if (rc==MMSYSERR_NOERROR) {
         waveInClose(win);
@@ -620,7 +627,8 @@ static void wave_in_test_device(UINT_PTR device)
     rc=waveInOpen(&win,device,&wfex.Format,0,0,
                   CALLBACK_NULL|WAVE_FORMAT_DIRECT);
     ok(rc==MMSYSERR_NOERROR || rc==WAVERR_BADFORMAT ||
-       rc==MMSYSERR_INVALFLAG || rc==MMSYSERR_INVALPARAM,
+       rc==MMSYSERR_INVALFLAG || rc==MMSYSERR_INVALPARAM ||
+       rc==MMSYSERR_ALLOCATED,
        "waveInOpen(%s): returned: %s\n",dev_name(device),wave_in_error(rc));
     if (rc==MMSYSERR_NOERROR) {
         waveInClose(win);
diff --git a/dlls/ws2_32/socket.c b/dlls/ws2_32/socket.c
index 42044e6..cdcbb11 100644
--- a/dlls/ws2_32/socket.c
+++ b/dlls/ws2_32/socket.c
@@ -3337,12 +3337,13 @@ INT WINAPI WS_getsockopt(SOCKET s, INT level,
 #endif
 
 #ifdef HAS_IRDA
+#define MAX_IRDA_DEVICES 10
+
     case WS_SOL_IRLMP:
         switch(optname)
         {
         case WS_IRLMP_ENUMDEVICES:
         {
-            static const int MAX_IRDA_DEVICES = 10;
             char buf[sizeof(struct irda_device_list) +
                      (MAX_IRDA_DEVICES - 1) * sizeof(struct irda_device_info)];
             int res;
@@ -3402,6 +3403,7 @@ INT WINAPI WS_getsockopt(SOCKET s, INT level,
             return SOCKET_ERROR;
         }
         break; /* case WS_SOL_IRLMP */
+#undef MAX_IRDA_DEVICES
 #endif
 
     /* Levels WS_IPPROTO_TCP and WS_IPPROTO_IP convert directly */
diff --git a/dlls/ws2_32/tests/sock.c b/dlls/ws2_32/tests/sock.c
index 00947c9..dcedd99 100644
--- a/dlls/ws2_32/tests/sock.c
+++ b/dlls/ws2_32/tests/sock.c
@@ -5518,11 +5518,21 @@ static void test_GetAddrInfoW(void)
 
     result = (ADDRINFOW *)0xdeadbeef;
     ret = pGetAddrInfoW(NULL, NULL, NULL, &result);
+    if(ret == 0)
+    {
+        skip("nxdomain returned success. Broken ISP redirects?\n");
+        return;
+    }
     ok(ret == WSAHOST_NOT_FOUND, "got %d expected WSAHOST_NOT_FOUND\n", ret);
     ok(result == NULL, "got %p\n", result);
 
     result = (ADDRINFOW *)0xdeadbeef;
     ret = pGetAddrInfoW(nxdomain, NULL, NULL, &result);
+    if(ret == 0)
+    {
+        skip("nxdomain returned success. Broken ISP redirects?\n");
+        return;
+    }
     ok(ret == WSAHOST_NOT_FOUND, "got %d expected WSAHOST_NOT_FOUND\n", ret);
     ok(result == NULL, "got %p\n", result);
 
@@ -5659,6 +5669,11 @@ static void test_getaddrinfo(void)
 
     result = (ADDRINFOA *)0xdeadbeef;
     ret = pgetaddrinfo("nxdomain.codeweavers.com", NULL, NULL, &result);
+    if(ret == 0)
+    {
+        skip("nxdomain returned success. Broken ISP redirects?\n");
+        return;
+    }
     ok(ret == WSAHOST_NOT_FOUND, "got %d expected WSAHOST_NOT_FOUND\n", ret);
     ok(result == NULL, "got %p\n", result);
 
diff --git a/dlls/wtsapi32/tests/wtsapi.c b/dlls/wtsapi32/tests/wtsapi.c
index 0a5a1ed..e8dced7 100644
--- a/dlls/wtsapi32/tests/wtsapi.c
+++ b/dlls/wtsapi32/tests/wtsapi.c
@@ -45,41 +45,33 @@ static void test_WTSEnumerateProcessesW(void)
     info = NULL;
     SetLastError(0xdeadbeef);
     ret = WTSEnumerateProcessesW(WTS_CURRENT_SERVER_HANDLE, 1, 1, &info, &count);
-    todo_wine
     ok(!ret, "expected WTSEnumerateProcessesW to fail\n");
-    todo_wine
     ok(GetLastError()== ERROR_INVALID_PARAMETER, "expected ERROR_INVALID_PARAMETER got: %d\n", GetLastError());
     if (info) WTSFreeMemory(info);
 
     info = NULL;
     SetLastError(0xdeadbeef);
     ret = WTSEnumerateProcessesW(WTS_CURRENT_SERVER_HANDLE, 0, 0, &info, &count);
-    todo_wine
     ok(!ret, "expected WTSEnumerateProcessesW to fail\n");
-    todo_wine
     ok(GetLastError()== ERROR_INVALID_PARAMETER, "expected ERROR_INVALID_PARAMETER got: %d\n", GetLastError());
     if (info) WTSFreeMemory(info);
 
     info = NULL;
     SetLastError(0xdeadbeef);
     ret = WTSEnumerateProcessesW(WTS_CURRENT_SERVER_HANDLE, 0, 2, &info, &count);
-    todo_wine
     ok(!ret, "expected WTSEnumerateProcessesW to fail\n");
-    todo_wine
     ok(GetLastError()== ERROR_INVALID_PARAMETER, "expected ERROR_INVALID_PARAMETER got: %d\n", GetLastError());
     if (info) WTSFreeMemory(info);
 
     SetLastError(0xdeadbeef);
     ret = WTSEnumerateProcessesW(WTS_CURRENT_SERVER_HANDLE, 0, 1, NULL, &count);
     ok(!ret, "expected WTSEnumerateProcessesW to fail\n");
-    todo_wine
     ok(GetLastError()== ERROR_INVALID_PARAMETER, "expected ERROR_INVALID_PARAMETER got: %d\n", GetLastError());
 
     info = NULL;
     SetLastError(0xdeadbeef);
     ret = WTSEnumerateProcessesW(WTS_CURRENT_SERVER_HANDLE, 0, 1, &info, NULL);
     ok(!ret, "expected WTSEnumerateProcessesW to fail\n");
-    todo_wine
     ok(GetLastError()== ERROR_INVALID_PARAMETER, "expected ERROR_INVALID_PARAMETER got: %d\n", GetLastError());
     if (info) WTSFreeMemory(info);
 
diff --git a/dlls/wtsapi32/wtsapi32.c b/dlls/wtsapi32/wtsapi32.c
index 314ec6b..79d5a7f 100644
--- a/dlls/wtsapi32/wtsapi32.c
+++ b/dlls/wtsapi32/wtsapi32.c
@@ -87,7 +87,11 @@ BOOL WINAPI WTSEnumerateProcessesW(HANDLE hServer, DWORD Reserved, DWORD Version
     FIXME("Stub %p 0x%08x 0x%08x %p %p\n", hServer, Reserved, Version,
           ppProcessInfo, pCount);
 
-    if (!ppProcessInfo || !pCount) return FALSE;
+    if (!ppProcessInfo || !pCount || Reserved != 0 || Version != 1)
+    {
+        SetLastError(ERROR_INVALID_PARAMETER);
+        return FALSE;
+    }
 
     *pCount = 0;
     *ppProcessInfo = NULL;
diff --git a/include/Makefile.in b/include/Makefile.in
index 525e4eb..ebdc96b 100644
--- a/include/Makefile.in
+++ b/include/Makefile.in
@@ -39,6 +39,7 @@ PUBLIC_IDL_H_SRCS = \
 	dwrite.idl \
 	dwrite_1.idl \
 	dxgi.idl \
+	dxgi1_2.idl \
 	endpointvolume.idl \
 	exdisp.idl \
 	fusion.idl \
diff --git a/include/corerror.h b/include/corerror.h
index 6419ea1..bc6e3e9 100644
--- a/include/corerror.h
+++ b/include/corerror.h
@@ -1,5 +1,6 @@
 /*
  * Copyright 2008 James Hawkins
+ * Copyright 2014 Kai Tietz
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -51,6 +52,16 @@
 
 #define COR_E_ASSEMBLYEXPECTED          EMAKEHR(0x1018)
 #define COR_E_TYPEUNLOADED              EMAKEHR(0x1013)
+#define COR_E_APPDOMAINUNLOADED         EMAKEHR(0x1014)
+#define COR_E_CANNOTUNLOADAPPDOMAIN     EMAKEHR(0x1015)
+#define COR_E_FIXUPSINEXE               EMAKEHR(0x1019)
+#define COR_E_NO_LOADLIBRARY_ALLOWED    EMAKEHR(0x101a)
+#define COR_E_NEWER_RUNTIME             EMAKEHR(0x101b)
+#define COR_E_CANNOT_SET_POLICY         EMAKEHR(0x101c)
+#define COR_E_CANNOT_SPECIFY_EVIDENCE   EMAKEHR(0x101d)
+#define COR_E_MULTIMODULEASSEMBLIESDIALLOWED EMAKEHR(0x101e)
+#define COR_E_MODULE_HASH_CHECK_FAILED  EMAKEHR(0x1039)
+#define COR_E_ASSEMBLY_NOT_EXPECTED     EMAKEHR(0x1057)
 #define COR_E_EXCEPTION                 EMAKEHR(0x1500)
 #define COR_E_SYSTEM                    EMAKEHR(0x1501)
 #define COR_E_ARGUMENTOUTOFRANGE        EMAKEHR(0x1502)
@@ -90,6 +101,7 @@
 #define COR_E_SEMAPHOREFULL             EMAKEHR(0x152B)
 #define COR_E_WAITHANDLECANNOTBEOPENED  EMAKEHR(0x152C)
 #define COR_E_ABANDONEDMUTEX            EMAKEHR(0x152D)
+#define COR_E_THREADABORTED             EMAKEHR(0x1530)
 #define COR_E_INVALIDOLEVARIANTTYPE     EMAKEHR(0x1531)
 #define COR_E_MISSINGMANIFESTRESOURCE   EMAKEHR(0x1532)
 #define COR_E_SAFEARRAYTYPEMISMATCH     EMAKEHR(0x1533)
@@ -105,7 +117,12 @@
 #define COR_E_RUNTIMEWRAPPED            EMAKEHR(0x153E)
 #define COR_E_DEVICESNOTSUPPORTED       EMAKEHR(0x1540)
 #define COR_E_DATAMISALIGNED            EMAKEHR(0x1541)
+#define COR_E_CODECONTRACTFAILED        EMAKEHR(0x1542)
+#define COR_E_TYPEACCESS                EMAKEHR(0x1543)
+#define COR_E_ACCESSING_CCW             EMAKEHR(0x1544)
+#define COR_E_LOADING_REFERENCE_ASSEMBLY EMAKEHR(0x1058)
 #define COR_E_KEYNOTFOUND               EMAKEHR(0x1577)
+#define COR_E_INSUFFICIENTEXECUTIONSTACK EMAKEHR(0x1578)
 #define COR_E_APPLICATION               EMAKEHR(0x1600)
 #define COR_E_INVALIDFILTERCRITERIA     EMAKEHR(0x1601)
 #define COR_E_REFLECTIONTYPELOAD        EMAKEHR(0x1602)
@@ -119,16 +136,1134 @@
 #define COR_E_HOSTPROTECTION            EMAKEHR(0x1640)
 #define COR_E_ILLEGAL_REENTRANCY        EMAKEHR(0x1641)
 
+#define COR_E_SqlException EMAKEHR(0x1904)
+#define COR_E_Data EMAKEHR(0x1920)
+#define COR_E_DataDeletedRowInaccessible EMAKEHR(0x1921)
+#define COR_E_DataDuplicateName EMAKEHR(0x1922)
+#define COR_E_DataInRowChangingEvent EMAKEHR(0x1923)
+#define COR_E_DataInvalidConstraint EMAKEHR(0x1924)
+#define COR_E_DataMissingPrimaryKey EMAKEHR(0x1925)
+#define COR_E_DataNoNullAllowed EMAKEHR(0x1926)
+#define COR_E_DataReadOnly EMAKEHR(0x1927)
+#define COR_E_DataRowNotInTable EMAKEHR(0x1928)
+#define COR_E_DataVersionNotFound EMAKEHR(0x1929)
+#define COR_E_DataConstraint EMAKEHR(0x192a)
+#define COR_E_StrongTyping EMAKEHR(0x192b)
+#define COR_E_SqlType EMAKEHR(0x1930)
+#define COR_E_SqlNullValue EMAKEHR(0x1931)
+#define COR_E_SqlTruncate EMAKEHR(0x1932)
+#define COR_E_AdapterMapping EMAKEHR(0x1933)
+#define COR_E_DataAdapter EMAKEHR(0x1934)
+#define COR_E_DBConcurrency EMAKEHR(0x1935)
+#define COR_E_OperationAborted EMAKEHR(0x1936)
+#define COR_E_InvalidUdt EMAKEHR(0x1937)
+#define COR_E_OdbcException EMAKEHR(0x1937)
+#define COR_E_OracleException EMAKEHR(0x1938)
+#define COR_E_Xml EMAKEHR(0x1940)
+#define COR_E_XmlSchema EMAKEHR(0x1941)
+#define COR_E_XmlXslt EMAKEHR(0x1942)
+#define COR_E_XmlXPath EMAKEHR(0x1943)
+#define COR_E_XmlQuery EMAKEHR(0x1944)
+
+#define FUSION_E_REF_DEF_MISMATCH EMAKEHR(0x1040)
+#define FUSION_E_INVALID_PRIVATE_ASM_LOCATION EMAKEHR(0x1041)
+#define FUSION_E_ASM_MODULE_MISSING EMAKEHR(0x1042)
+#define FUSION_E_UNEXPECTED_MODULE_FOUND EMAKEHR(0x1043)
 #define FUSION_E_PRIVATE_ASM_DISALLOWED EMAKEHR(0x1044)
+#define FUSION_E_SIGNATURE_CHECK_FAILED EMAKEHR(0x1045)
+#define FUSION_E_DATABASE_ERROR         EMAKEHR(0x1046)
 #define FUSION_E_INVALID_NAME           EMAKEHR(0x1047)
+#define FUSION_E_CODE_DOWNLOAD_DISABLED EMAKEHR(0x1048)
+#define FUSION_E_UNINSTALL_DISALLOWED   EMAKEHR(0x1049)
+#define FUSION_E_HOST_GAC_ASM_MISMATCH  EMAKEHR(0x1050)
+#define FUSION_E_LOADFROM_BLOCKED       EMAKEHR(0x1051)
+#define FUSION_E_CACHEFILE_FAILED       EMAKEHR(0x1052)
+#define FUSION_E_APP_DOMAIN_LOCKED      EMAKEHR(0x1053)
+#define FUSION_E_CONFIGURATION_ERROR    EMAKEHR(0x1054)
+#define FUSION_E_MANIFEST_PARSE_ERROR   EMAKEHR(0x1055)
+#define FUSION_E_INVALID_ASSEMBLY_REFERENCE EMAKEHR(0x1056)
 
+#define CLDB_E_FILE_BADREAD             EMAKEHR(0x1100)
+#define CLDB_E_FILE_BADWRITE            EMAKEHR(0x1101)
+#define CLDB_E_FILE_READONLY            EMAKEHR(0x1103)
+#define CLDB_E_NAME_ERROR               EMAKEHR(0x1105)
+#define CLDB_E_TRUNCATION               EMAKEHR(0x1106)
 #define CLDB_E_FILE_OLDVER              EMAKEHR(0x1107)
+#define CLDB_E_RELOCATED                EMAKEHR(0x1108)
+#define CLDB_E_SMDUPLICATE              EMAKEHR(0x110a)
+#define CLDB_E_NO_DATA                  EMAKEHR(0x110b)
+#define CLDB_E_READONLY                 EMAKEHR(0x110c)
+#define CLDB_E_INCOMPATIBLE             EMAKEHR(0x110d)
+#define CLDB_E_FILE_CORRUPT             EMAKEHR(0x110e)
+#define CLDB_E_SCHEMA_VERNOTFOUND       EMAKEHR(0x110f)
+#define CLDB_E_BADUPDATEMODE            EMAKEHR(0x1110)
+#define CLDB_E_INDEX_NONULLKEYS         EMAKEHR(0x1121)
+#define CLDB_E_INDEX_DUPLICATE          EMAKEHR(0x1122)
+#define CLDB_E_INDEX_BADTYPE            EMAKEHR(0x1123)
+#define CLDB_E_INDEX_NOTFOUND           EMAKEHR(0x1124)
+#define CLDB_E_RECORD_NOTFOUND          EMAKEHR(0x1130)
+#define CLDB_E_RECORD_OVERFLOW          EMAKEHR(0x1131)
+#define CLDB_E_RECORD_DUPLICATE         EMAKEHR(0x1132)
+#define CLDB_E_RECORD_PKREQUIRED        EMAKEHR(0x1133)
+#define CLDB_E_RECORD_DELETED           EMAKEHR(0x1134)
+#define CLDB_E_RECORD_OUTOFORDER        EMAKEHR(0x1135)
+#define CLDB_E_COLUMN_OVERFLOW          EMAKEHR(0x1140)
+#define CLDB_E_COLUMN_READONLY          EMAKEHR(0x1141)
+#define CLDB_E_COLUMN_SPECIALCOL        EMAKEHR(0x1142)
+#define CLDB_E_COLUMN_PKNONULLS         EMAKEHR(0x1143)
+#define CLDB_E_TABLE_CANTDROP           EMAKEHR(0x1150)
+#define CLDB_E_OBJECT_NOTFOUND          EMAKEHR(0x1151)
+#define CLDB_E_OBJECT_COLNOTFOUND       EMAKEHR(0x1152)
+#define CLDB_E_VECTOR_BADINDEX          EMAKEHR(0x1153)
+#define CLDB_E_TOO_BIG                  EMAKEHR(0x1154)
+#define CLDB_E_INTERNALERROR            EMAKEHR(0x1fff)
+
+#define CLDB_S_TRUNCATION               SMAKEHR(0x1106)
+#define CLDB_S_NULL                     SMAKEHR(0x1109)
+#define CLDB_S_INDEX_TABLESCANREQUIRED  SMAKEHR(0x1125)
 
-#define CLR_E_SHIM_RUNTIME              EMAKEHR(0x1700)
-#define CLR_E_SHIM_RUNTIMEEXPORT        EMAKEHR(0x1701)
-#define CLR_E_SHIM_INSTALLROOT          EMAKEHR(0x1702)
-#define CLR_E_SHIM_INSTALLCOMP          EMAKEHR(0x1703)
+#define CLR_E_APP_CONFIG_NOT_ALLOWED_IN_APPX_PROCESS EMAKEHR(0x104a)
+#define CLR_E_SHIM_RUNTIME                   EMAKEHR(0x1700)
+#define CLR_E_SHIM_RUNTIMELOAD               EMAKEHR(0x1700)
+#define CLR_E_SHIM_RUNTIMEEXPORT             EMAKEHR(0x1701)
+#define CLR_E_SHIM_INSTALLROOT               EMAKEHR(0x1702)
+#define CLR_E_SHIM_INSTALLCOMP               EMAKEHR(0x1703)
 #define CLR_E_SHIM_LEGACYRUNTIMEALREADYBOUND EMAKEHR(0x1704)
-#define CLR_E_SHIM_SHUTDOWNINPROGRESS   EMAKEHR(0x1705)
+#define CLR_E_SHIM_SHUTDOWNINPROGRESS        EMAKEHR(0x1705)
+#define CLR_E_BIND_ASSEMBLY_VERSION_TOO_LOW  EMAKEHR(0x2000)
+#define CLR_E_BIND_ASSEMBLY_PUBLIC_KEY_MISMATCH EMAKEHR(0x2001)
+#define CLR_E_BIND_IMAGE_UNAVAILABLE         EMAKEHR(0x2002)
+#define CLR_E_BIND_UNRECOGNIZED_IDENTITY_FORMAT EMAKEHR(0x2003)
+#define CLR_E_BIND_ASSEMBLY_NOT_FOUND        EMAKEHR(0x2004)
+#define CLR_E_BIND_TYPE_NOT_FOUND            EMAKEHR(0x2005)
+
+#define CLR_OPTSVC_E_CONTROLLER_INTERRUPT EMAKEHR(0x1e00)
+
+#define META_S_PARAM_MISMATCH SMAKEHR(0x1189)
+#define META_S_DUPLICATE      SMAKEHR(0x1197)
+
+#define TLBX_E_INVALID_TYPEINFO EMAKEHR(0x1160)
+#define TLBX_E_INVALID_TYPEINFO_UNNAMED EMAKEHR(0x1161)
+#define TLBX_E_CTX_NESTED EMAKEHR(0x1162)
+#define TLBX_E_ERROR_MESSAGE EMAKEHR(0x1163)
+#define TLBX_E_CANT_SAVE EMAKEHR(0x1164)
+#define TLBX_E_CANTLOADLIBRARY EMAKEHR(0x1166)
+#define TLBX_E_BAD_VT_TYPE EMAKEHR(0x1167)
+#define TLBX_E_NO_MSCOREE_TLB EMAKEHR(0x1168)
+#define TLBX_E_BAD_MSCOREE_TLB EMAKEHR(0x1169)
+#define TLBX_E_TLB_EXCEPTION EMAKEHR(0x116a)
+#define TLBX_E_MULTIPLE_LCIDS EMAKEHR(0x116b)
+#define TLBX_E_AMBIGUOUS_RETURN EMAKEHR(0x116d)
+#define TLBX_E_DUPLICATE_TYPE_NAME EMAKEHR(0x116e)
+#define TLBX_E_ASANY EMAKEHR(0x1175)
+#define TLBX_E_INVALIDLCIDPARAM EMAKEHR(0x1176)
+#define TLBX_E_LCIDONDISPONLYITF EMAKEHR(0x1177)
+#define TLBX_E_NONPUBLIC_FIELD EMAKEHR(0x1178)
+#define TLBX_E_BAD_NAMES EMAKEHR(0x117b)
+#define TLBX_E_GENERICINST_SIGNATURE EMAKEHR(0x117d)
+#define TLBX_E_GENERICPAR_SIGNATURE EMAKEHR(0x117e)
+#define TLBX_E_NO_SAFEHANDLE_ARRAYS EMAKEHR(0x1186)
+#define TLBX_E_NO_CRITICALHANDLE_ARRAYS EMAKEHR(0x118c)
+#define TLBX_E_CANT_LOAD_MODULE EMAKEHR(0x11a0)
+#define TLBX_E_CANT_LOAD_CLASS EMAKEHR(0x11a1)
+#define TLBX_E_NULL_MODULE EMAKEHR(0x11a2)
+#define TLBX_E_NO_CLSID_KEY EMAKEHR(0x11a3)
+#define TLBX_E_CIRCULAR_EXPORT EMAKEHR(0x11a4)
+#define TLBX_E_CIRCULAR_IMPORT EMAKEHR(0x11a5)
+#define TLBX_E_BAD_NATIVETYPE EMAKEHR(0x11a6)
+#define TLBX_E_BAD_VTABLE EMAKEHR(0x11a7)
+#define TLBX_E_CRM_NON_STATIC EMAKEHR(0x11a8)
+#define TLBX_E_CRM_INVALID_SIG EMAKEHR(0x11a9)
+#define TLBX_E_CLASS_LOAD_EXCEPTION EMAKEHR(0x11aa)
+#define TLBX_E_UNKNOWN_SIGNATURE EMAKEHR(0x11ab)
+#define TLBX_E_REFERENCED_TYPELIB EMAKEHR(0x11ac)
+#define TLBX_E_INVALID_NAMESPACE EMAKEHR(0x11ad)
+#define TLBX_E_LAYOUT_ERROR EMAKEHR(0x11ae)
+#define TLBX_E_NOTIUNKNOWN EMAKEHR(0x11af)
+#define TLBX_E_NONVISIBLEVALUECLASS EMAKEHR(0x11b0)
+#define TLBX_E_LPTSTR_NOT_ALLOWED EMAKEHR(0x11b1)
+#define TLBX_E_AUTO_CS_NOT_ALLOWED EMAKEHR(0x11b2)
+#define TLBX_E_ENUM_VALUE_INVALID EMAKEHR(0x11b5)
+#define TLBX_E_DUPLICATE_IID EMAKEHR(0x11b6)
+#define TLBX_E_NO_NESTED_ARRAYS EMAKEHR(0x11b7)
+#define TLBX_E_PARAM_ERROR_NAMED EMAKEHR(0x11b8)
+#define TLBX_E_PARAM_ERROR_UNNAMED EMAKEHR(0x11b9)
+#define TLBX_E_AGNOST_SIGNATURE EMAKEHR(0x11ba)
+#define TLBX_E_CONVERT_FAIL EMAKEHR(0x11bb)
+#define TLBX_E_BAD_SIGNATURE EMAKEHR(0x11bd)
+#define TLBX_E_ARRAY_NEEDS_NT_FIXED EMAKEHR(0x11be)
+#define TLBX_E_CLASS_NEEDS_NT_INTF EMAKEHR(0x11bf)
+#define TLBX_E_TYPED_REF EMAKEHR(0x11da)
+#define TLBX_E_BITNESS_MISMATCH EMAKEHR(0x11e1)
+#define TLBX_E_EVENT_WITH_NEWENUM EMAKEHR(0x11e2)
+#define TLBX_E_PROPGET_WITHOUT_RETURN EMAKEHR(0x11e3)
+#define TLBX_E_CIRCULAR_EXPORT2 EMAKEHR(0x1b52)
+
+#define TLBX_I_TYPEINFO_IMPORTED SMAKEHR(0x116c)
+#define TLBX_I_PIA_REGISTERED_FOR_TLB SMAKEHR(0x116d)
+#define TLBX_I_AGNOSTIC_ASSEMBLY SMAKEHR(0x116e)
+#define TLBX_I_USEIUNKNOWN SMAKEHR(0x116f)
+#define TLBX_I_UNCONVERTABLE_ARGS SMAKEHR(0x1170)
+#define TLBX_I_UNCONVERTABLE_FIELD SMAKEHR(0x1171)
+#define TLBX_I_NONSEQUENTIALSTRUCT EMAKEHR(0x1172)
+#define TLBX_I_RESOLVEREFFAILED EMAKEHR(0x1174)
+#define TLBX_I_TYPE_EXPORTED SMAKEHR(0x1179)
+#define TLBX_I_DUPLICATE_DISPID SMAKEHR(0x117a)
+#define TLBX_I_REF_TYPE_AS_STRUCT SMAKEHR(0x117c)
+#define TLBX_I_GENERIC_TYPE SMAKEHR(0x117f)
+#define TLBX_I_GENERIC_BASE_TYPE SMAKEHR(0x11e0)
+
+#define TLBX_S_REFERENCED_TYPELIB SMAKEHR(0x11ac)
+#define TLBX_S_NOSTDINTERFACE     SMAKEHR(0x11b3)
+#define TLBX_S_DUPLICATE_DISPID   SMAKEHR(0x11b4)
+
+#define TLBX_W_LIBNOTREGISTERED EMAKEHR(0x1165)
+#define TLBX_W_WARNING_MESSAGE SMAKEHR(0x1173)
+#define TLBX_W_ASSEMBLY_HAS_EMBEDDED_TLB SMAKEHR(0x1174)
+#define TLBX_W_CROSS_COMPILE_NO_REFS SMAKEHR(0x1175)
+#define TLBX_W_PURE_CROSS_COMPILE SMAKEHR(0x1176)
+#define TLBX_W_NON_INTEGRAL_CA_TYPE SMAKEHR(0x1184)
+#define TLBX_W_IENUM_CA_ON_IUNK SMAKEHR(0x1185)
+#define TLBX_W_DUAL_NOT_DISPATCH EMAKEHR(0x11bc)
+#define TLBX_W_NO_PROPS_IN_EVENTS EMAKEHR(0x11d3)
+#define TLBX_W_ENUM_VALUE_TOOBIG SMAKEHR(0x11d5)
+#define TLBX_W_EXPORTING_AUTO_LAYOUT SMAKEHR(0x11d9)
+#define TLBX_W_DEFAULT_INTF_NOT_VISIBLE SMAKEHR(0x11db)
+#define TLBX_W_BAD_SAFEARRAYFIELD_NO_ELEMENTVT SMAKEHR(0x11de)
+#define TLBX_W_LAYOUTCLASS_AS_INTERFACE SMAKEHR(0x11df)
+
+#define VLDTR_E_RID_OUTOFRANGE EMAKEHR(0x1203)
+#define VLDTR_E_CDTKN_OUTOFRANGE EMAKEHR(0x1204)
+#define VLDTR_E_CDRID_OUTOFRANGE EMAKEHR(0x1205)
+#define VLDTR_E_STRING_INVALID EMAKEHR(0x1206)
+#define VLDTR_E_GUID_INVALID EMAKEHR(0x1207)
+#define VLDTR_E_BLOB_INVALID EMAKEHR(0x1208)
+#define VLDTR_E_MOD_MULTI EMAKEHR(0x1209)
+#define VLDTR_E_MOD_NULLMVID EMAKEHR(0x120a)
+#define VLDTR_E_TR_NAMENULL EMAKEHR(0x120b)
+#define VLDTR_E_TR_DUP EMAKEHR(0x120c)
+#define VLDTR_E_TD_NAMENULL EMAKEHR(0x120d)
+#define VLDTR_E_TD_DUPNAME EMAKEHR(0x120e)
+#define VLDTR_E_TD_DUPGUID EMAKEHR(0x120f)
+#define VLDTR_E_TD_NOTIFACEOBJEXTNULL EMAKEHR(0x1210)
+#define VLDTR_E_TD_OBJEXTENDSNONNULL EMAKEHR(0x1211)
+#define VLDTR_E_TD_EXTENDSSEALED EMAKEHR(0x1212)
+#define VLDTR_E_TD_DLTNORTSPCL EMAKEHR(0x1213)
+#define VLDTR_E_TD_RTSPCLNOTDLT EMAKEHR(0x1214)
+#define VLDTR_E_MI_DECLPRIV EMAKEHR(0x1215)
+#define VLDTR_E_AS_BADNAME EMAKEHR(0x1216)
+#define VLDTR_E_FILE_SYSNAME EMAKEHR(0x1217)
+#define VLDTR_E_MI_BODYSTATIC EMAKEHR(0x1218)
+#define VLDTR_E_TD_IFACENOTABS EMAKEHR(0x1219)
+#define VLDTR_E_TD_IFACEPARNOTNIL EMAKEHR(0x121a)
+#define VLDTR_E_TD_IFACEGUIDNULL EMAKEHR(0x121b)
+#define VLDTR_E_MI_DECLFINAL EMAKEHR(0x121c)
+#define VLDTR_E_TD_VTNOTSEAL EMAKEHR(0x121d)
+#define VLDTR_E_PD_BADFLAGS EMAKEHR(0x121e)
+#define VLDTR_E_IFACE_DUP EMAKEHR(0x121f)
+#define VLDTR_E_MR_NAMENULL EMAKEHR(0x1220)
+#define VLDTR_E_MR_VTBLNAME EMAKEHR(0x1221)
+#define VLDTR_E_MR_DELNAME EMAKEHR(0x1222)
+#define VLDTR_E_MR_PARNIL EMAKEHR(0x1223)
+#define VLDTR_E_MR_BADCALLINGCONV EMAKEHR(0x1224)
+#define VLDTR_E_MR_NOTVARARG EMAKEHR(0x1225)
+#define VLDTR_E_MR_NAMEDIFF EMAKEHR(0x1226)
+#define VLDTR_E_MR_SIGDIFF EMAKEHR(0x1227)
+#define VLDTR_E_MR_DUP EMAKEHR(0x1228)
+#define VLDTR_E_CL_TDAUTO EMAKEHR(0x1229)
+#define VLDTR_E_CL_BADPCKSZ EMAKEHR(0x122a)
+#define VLDTR_E_CL_DUP EMAKEHR(0x122b)
+#define VLDTR_E_FL_BADOFFSET EMAKEHR(0x122c)
+#define VLDTR_E_FL_TDNIL EMAKEHR(0x122d)
+#define VLDTR_E_FL_NOCL EMAKEHR(0x122e)
+#define VLDTR_E_FL_TDNOTEXPLCT EMAKEHR(0x122f)
+#define VLDTR_E_FL_FLDSTATIC EMAKEHR(0x1230)
+#define VLDTR_E_FL_DUP EMAKEHR(0x1231)
+#define VLDTR_E_MODREF_NAMENULL EMAKEHR(0x1232)
+#define VLDTR_E_MODREF_DUP EMAKEHR(0x1233)
+#define VLDTR_E_TR_BADSCOPE EMAKEHR(0x1234)
+#define VLDTR_E_TD_NESTEDNOENCL EMAKEHR(0x1235)
+#define VLDTR_E_TD_EXTTRRES EMAKEHR(0x1236)
+#define VLDTR_E_SIGNULL EMAKEHR(0x1237)
+#define VLDTR_E_SIGNODATA EMAKEHR(0x1238)
+#define VLDTR_E_MD_BADCALLINGCONV EMAKEHR(0x1239)
+#define VLDTR_E_MD_THISSTATIC EMAKEHR(0x123a)
+#define VLDTR_E_MD_NOTTHISNOTSTATIC EMAKEHR(0x123b)
+#define VLDTR_E_MD_NOARGCNT EMAKEHR(0x123c)
+#define VLDTR_E_SIG_MISSELTYPE EMAKEHR(0x123d)
+#define VLDTR_E_SIG_MISSTKN EMAKEHR(0x123e)
+#define VLDTR_E_SIG_TKNBAD EMAKEHR(0x123f)
+#define VLDTR_E_SIG_MISSFPTR EMAKEHR(0x1240)
+#define VLDTR_E_SIG_MISSFPTRARGCNT EMAKEHR(0x1241)
+#define VLDTR_E_SIG_MISSRANK EMAKEHR(0x1242)
+#define VLDTR_E_SIG_MISSNSIZE EMAKEHR(0x1243)
+#define VLDTR_E_SIG_MISSSIZE EMAKEHR(0x1244)
+#define VLDTR_E_SIG_MISSNLBND EMAKEHR(0x1245)
+#define VLDTR_E_SIG_MISSLBND EMAKEHR(0x1246)
+#define VLDTR_E_SIG_BADELTYPE EMAKEHR(0x1247)
+#define VLDTR_E_SIG_MISSVASIZE EMAKEHR(0x1248)
+#define VLDTR_E_FD_BADCALLINGCONV EMAKEHR(0x1249)
+#define VLDTR_E_MD_NAMENULL EMAKEHR(0x124a)
+#define VLDTR_E_MD_PARNIL EMAKEHR(0x124b)
+#define VLDTR_E_MD_DUP EMAKEHR(0x124c)
+#define VLDTR_E_FD_NAMENULL EMAKEHR(0x124d)
+#define VLDTR_E_FD_PARNIL EMAKEHR(0x124e)
+#define VLDTR_E_FD_DUP EMAKEHR(0x124f)
+#define VLDTR_E_AS_MULTI EMAKEHR(0x1250)
+#define VLDTR_E_AS_NAMENULL EMAKEHR(0x1251)
+#define VLDTR_E_SIG_TOKTYPEMISMATCH EMAKEHR(0x1252)
+#define VLDTR_E_CL_TDINTF EMAKEHR(0x1253)
+#define VLDTR_E_ASOS_OSPLTFRMIDINVAL EMAKEHR(0x1254)
+#define VLDTR_E_AR_NAMENULL EMAKEHR(0x1255)
+#define VLDTR_E_TD_ENCLNOTNESTED EMAKEHR(0x1256)
+#define VLDTR_E_AROS_OSPLTFRMIDINVAL EMAKEHR(0x1257)
+#define VLDTR_E_FILE_NAMENULL EMAKEHR(0x1258)
+#define VLDTR_E_CT_NAMENULL EMAKEHR(0x1259)
+#define VLDTR_E_TD_EXTENDSCHILD EMAKEHR(0x125a)
+#define VLDTR_E_MAR_NAMENULL EMAKEHR(0x125b)
+#define VLDTR_E_FILE_DUP EMAKEHR(0x125c)
+#define VLDTR_E_FILE_NAMEFULLQLFD EMAKEHR(0x125d)
+#define VLDTR_E_CT_DUP EMAKEHR(0x125e)
+#define VLDTR_E_MAR_DUP EMAKEHR(0x125f)
+#define VLDTR_E_MAR_NOTPUBPRIV EMAKEHR(0x1260)
+#define VLDTR_E_TD_ENUMNOVALUE EMAKEHR(0x1261)
+#define VLDTR_E_TD_ENUMVALSTATIC EMAKEHR(0x1262)
+#define VLDTR_E_TD_ENUMVALNOTSN EMAKEHR(0x1263)
+#define VLDTR_E_TD_ENUMFLDNOTST EMAKEHR(0x1264)
+#define VLDTR_E_TD_ENUMFLDNOTLIT EMAKEHR(0x1265)
+#define VLDTR_E_TD_ENUMNOLITFLDS EMAKEHR(0x1266)
+#define VLDTR_E_TD_ENUMFLDSIGMISMATCH EMAKEHR(0x1267)
+#define VLDTR_E_TD_ENUMVALNOT1ST EMAKEHR(0x1268)
+#define VLDTR_E_FD_NOTVALUERTSN EMAKEHR(0x1269)
+#define VLDTR_E_FD_VALUEPARNOTENUM EMAKEHR(0x126a)
+#define VLDTR_E_FD_INSTINIFACE EMAKEHR(0x126b)
+#define VLDTR_E_FD_NOTPUBINIFACE EMAKEHR(0x126c)
+#define VLDTR_E_FMD_GLOBALNOTPUBPRIVSC EMAKEHR(0x126d)
+#define VLDTR_E_FMD_GLOBALNOTSTATIC EMAKEHR(0x126e)
+#define VLDTR_E_FD_GLOBALNORVA EMAKEHR(0x126f)
+#define VLDTR_E_MD_CTORZERORVA EMAKEHR(0x1270)
+#define VLDTR_E_FD_MARKEDNOMARSHAL EMAKEHR(0x1271)
+#define VLDTR_E_FD_MARSHALNOTMARKED EMAKEHR(0x1272)
+#define VLDTR_E_FD_MARKEDNODEFLT EMAKEHR(0x1273)
+#define VLDTR_E_FD_DEFLTNOTMARKED EMAKEHR(0x1274)
+#define VLDTR_E_FMD_MARKEDNOSECUR EMAKEHR(0x1275)
+#define VLDTR_E_FMD_SECURNOTMARKED EMAKEHR(0x1276)
+#define VLDTR_E_FMD_PINVOKENOTSTATIC EMAKEHR(0x1277)
+#define VLDTR_E_FMD_MARKEDNOPINVOKE EMAKEHR(0x1278)
+#define VLDTR_E_FMD_PINVOKENOTMARKED EMAKEHR(0x1279)
+#define VLDTR_E_FMD_BADIMPLMAP EMAKEHR(0x127a)
+#define VLDTR_E_IMAP_BADMODREF EMAKEHR(0x127b)
+#define VLDTR_E_IMAP_BADMEMBER EMAKEHR(0x127c)
+#define VLDTR_E_IMAP_BADIMPORTNAME EMAKEHR(0x127d)
+#define VLDTR_E_IMAP_BADCALLCONV EMAKEHR(0x127e)
+#define VLDTR_E_FMD_BADACCESSFLAG EMAKEHR(0x127f)
+#define VLDTR_E_FD_INITONLYANDLITERAL EMAKEHR(0x1280)
+#define VLDTR_E_FD_LITERALNOTSTATIC EMAKEHR(0x1281)
+#define VLDTR_E_FMD_RTSNNOTSN EMAKEHR(0x1282)
+#define VLDTR_E_MD_ABSTPARNOTABST EMAKEHR(0x1283)
+#define VLDTR_E_MD_NOTSTATABSTININTF EMAKEHR(0x1284)
+#define VLDTR_E_MD_NOTPUBININTF EMAKEHR(0x1285)
+#define VLDTR_E_MD_CTORININTF EMAKEHR(0x1286)
+#define VLDTR_E_MD_GLOBALCTORCCTOR EMAKEHR(0x1287)
+#define VLDTR_E_MD_CTORSTATIC EMAKEHR(0x1288)
+#define VLDTR_E_MD_CTORNOTSNRTSN EMAKEHR(0x1289)
+#define VLDTR_E_MD_CTORVIRT EMAKEHR(0x128a)
+#define VLDTR_E_MD_CTORABST EMAKEHR(0x128b)
+#define VLDTR_E_MD_CCTORNOTSTATIC EMAKEHR(0x128c)
+#define VLDTR_E_MD_ZERORVA EMAKEHR(0x128d)
+#define VLDTR_E_MD_FINNOTVIRT EMAKEHR(0x128e)
+#define VLDTR_E_MD_STATANDFINORVIRT EMAKEHR(0x128f)
+#define VLDTR_E_MD_ABSTANDFINAL EMAKEHR(0x1290)
+#define VLDTR_E_MD_ABSTANDIMPL EMAKEHR(0x1291)
+#define VLDTR_E_MD_ABSTANDPINVOKE EMAKEHR(0x1292)
+#define VLDTR_E_MD_ABSTNOTVIRT EMAKEHR(0x1293)
+#define VLDTR_E_MD_NOTABSTNOTIMPL EMAKEHR(0x1294)
+#define VLDTR_E_MD_NOTABSTBADFLAGSRVA EMAKEHR(0x1295)
+#define VLDTR_E_MD_PRIVSCOPENORVA EMAKEHR(0x1296)
+#define VLDTR_E_MD_GLOBALABSTORVIRT EMAKEHR(0x1297)
+#define VLDTR_E_SIG_LONGFORM EMAKEHR(0x1298)
+#define VLDTR_E_MD_MULTIPLESEMANTICS EMAKEHR(0x1299)
+#define VLDTR_E_MD_INVALIDSEMANTICS EMAKEHR(0x129a)
+#define VLDTR_E_MD_SEMANTICSNOTEXIST EMAKEHR(0x129b)
+#define VLDTR_E_MI_DECLNOTVIRT EMAKEHR(0x129c)
+#define VLDTR_E_FMD_GLOBALITEM EMAKEHR(0x129d)
+#define VLDTR_E_MD_MULTSEMANTICFLAGS EMAKEHR(0x129e)
+#define VLDTR_E_MD_NOSEMANTICFLAGS EMAKEHR(0x129f)
+#define VLDTR_E_FD_FLDINIFACE EMAKEHR(0x12a0)
+#define VLDTR_E_AS_HASHALGID EMAKEHR(0x12a1)
+#define VLDTR_E_AS_PROCID EMAKEHR(0x12a2)
+#define VLDTR_E_AR_PROCID EMAKEHR(0x12a3)
+#define VLDTR_E_CN_PARENTRANGE EMAKEHR(0x12a4)
+#define VLDTR_E_AS_BADFLAGS EMAKEHR(0x12a5)
+#define VLDTR_E_TR_HASTYPEDEF EMAKEHR(0x12a6)
+#define VLDTR_E_IFACE_BADIMPL EMAKEHR(0x12a7)
+#define VLDTR_E_IFACE_BADIFACE EMAKEHR(0x12a8)
+#define VLDTR_E_TD_SECURNOTMARKED EMAKEHR(0x12a9)
+#define VLDTR_E_TD_MARKEDNOSECUR EMAKEHR(0x12aa)
+#define VLDTR_E_MD_CCTORHASARGS EMAKEHR(0x12ab)
+#define VLDTR_E_CT_BADIMPL EMAKEHR(0x12ac)
+#define VLDTR_E_MI_ALIENBODY EMAKEHR(0x12ad)
+#define VLDTR_E_MD_CCTORCALLCONV EMAKEHR(0x12ae)
+#define VLDTR_E_MI_BADCLASS EMAKEHR(0x12af)
+#define VLDTR_E_MI_CLASSISINTF EMAKEHR(0x12b0)
+#define VLDTR_E_MI_BADDECL EMAKEHR(0x12b1)
+#define VLDTR_E_MI_BADBODY EMAKEHR(0x12b2)
+#define VLDTR_E_MI_DUP EMAKEHR(0x12b3)
+#define VLDTR_E_FD_BADPARENT EMAKEHR(0x12b4)
+#define VLDTR_E_MD_PARAMOUTOFSEQ EMAKEHR(0x12b5)
+#define VLDTR_E_MD_PARASEQTOOBIG EMAKEHR(0x12b6)
+#define VLDTR_E_MD_PARMMARKEDNOMARSHAL EMAKEHR(0x12b7)
+#define VLDTR_E_MD_PARMMARSHALNOTMARKED EMAKEHR(0x12b8)
+#define VLDTR_E_MD_PARMMARKEDNODEFLT EMAKEHR(0x12ba)
+#define VLDTR_E_MD_PARMDEFLTNOTMARKED EMAKEHR(0x12bb)
+#define VLDTR_E_PR_BADSCOPE EMAKEHR(0x12bc)
+#define VLDTR_E_PR_NONAME EMAKEHR(0x12bd)
+#define VLDTR_E_PR_NOSIG EMAKEHR(0x12be)
+#define VLDTR_E_PR_DUP EMAKEHR(0x12bf)
+#define VLDTR_E_PR_BADCALLINGCONV EMAKEHR(0x12c0)
+#define VLDTR_E_PR_MARKEDNODEFLT EMAKEHR(0x12c1)
+#define VLDTR_E_PR_DEFLTNOTMARKED EMAKEHR(0x12c2)
+#define VLDTR_E_PR_BADSEMANTICS EMAKEHR(0x12c3)
+#define VLDTR_E_PR_BADMETHOD EMAKEHR(0x12c4)
+#define VLDTR_E_PR_ALIENMETHOD EMAKEHR(0x12c5)
+#define VLDTR_E_CN_BLOBNOTNULL EMAKEHR(0x12c6)
+#define VLDTR_E_CN_BLOBNULL EMAKEHR(0x12c7)
+#define VLDTR_E_EV_BADSCOPE EMAKEHR(0x12c8)
+#define VLDTR_E_EV_NONAME EMAKEHR(0x12ca)
+#define VLDTR_E_EV_DUP EMAKEHR(0x12cb)
+#define VLDTR_E_EV_BADEVTYPE EMAKEHR(0x12cc)
+#define VLDTR_E_EV_EVTYPENOTCLASS EMAKEHR(0x12cd)
+#define VLDTR_E_EV_BADSEMANTICS EMAKEHR(0x12ce)
+#define VLDTR_E_EV_BADMETHOD EMAKEHR(0x12cf)
+#define VLDTR_E_EV_ALIENMETHOD EMAKEHR(0x12d0)
+#define VLDTR_E_EV_NOADDON EMAKEHR(0x12d1)
+#define VLDTR_E_EV_NOREMOVEON EMAKEHR(0x12d2)
+#define VLDTR_E_CT_DUPTDNAME EMAKEHR(0x12d3)
+#define VLDTR_E_MAR_BADOFFSET EMAKEHR(0x12d4)
+#define VLDTR_E_DS_BADOWNER EMAKEHR(0x12d5)
+#define VLDTR_E_DS_BADFLAGS EMAKEHR(0x12d6)
+#define VLDTR_E_DS_NOBLOB EMAKEHR(0x12d7)
+#define VLDTR_E_MAR_BADIMPL EMAKEHR(0x12d8)
+#define VLDTR_E_MR_VARARGCALLINGCONV EMAKEHR(0x12da)
+#define VLDTR_E_MD_CTORNOTVOID EMAKEHR(0x12db)
+#define VLDTR_E_EV_FIRENOTVOID EMAKEHR(0x12dc)
+#define VLDTR_E_AS_BADLOCALE EMAKEHR(0x12dd)
+#define VLDTR_E_CN_PARENTTYPE EMAKEHR(0x12de)
+#define VLDTR_E_SIG_SENTINMETHODDEF EMAKEHR(0x12df)
+#define VLDTR_E_SIG_SENTMUSTVARARG EMAKEHR(0x12e0)
+#define VLDTR_E_SIG_MULTSENTINELS EMAKEHR(0x12e1)
+#define VLDTR_E_SIG_LASTSENTINEL EMAKEHR(0x12e2)
+#define VLDTR_E_SIG_MISSARG EMAKEHR(0x12e3)
+#define VLDTR_E_SIG_BYREFINFIELD EMAKEHR(0x12e4)
+#define VLDTR_E_MD_SYNCMETHODINVTYPE EMAKEHR(0x12e5)
+#define VLDTR_E_TD_NAMETOOLONG EMAKEHR(0x12e6)
+#define VLDTR_E_AS_PROCDUP EMAKEHR(0x12e7)
+#define VLDTR_E_ASOS_DUP EMAKEHR(0x12e8)
+#define VLDTR_E_MAR_BADFLAGS EMAKEHR(0x12e9)
+#define VLDTR_E_CT_NOTYPEDEFID EMAKEHR(0x12ea)
+#define VLDTR_E_FILE_BADFLAGS EMAKEHR(0x12eb)
+#define VLDTR_E_FILE_NULLHASH EMAKEHR(0x12ec)
+#define VLDTR_E_MOD_NONAME EMAKEHR(0x12ed)
+#define VLDTR_E_MOD_NAMEFULLQLFD EMAKEHR(0x12ee)
+#define VLDTR_E_TD_RTSPCLNOTSPCL EMAKEHR(0x12ef)
+#define VLDTR_E_TD_EXTENDSIFACE EMAKEHR(0x12f0)
+#define VLDTR_E_MD_CTORPINVOKE EMAKEHR(0x12f1)
+#define VLDTR_E_TD_SYSENUMNOTCLASS EMAKEHR(0x12f2)
+#define VLDTR_E_TD_SYSENUMNOTEXTVTYPE EMAKEHR(0x12f3)
+#define VLDTR_E_MI_SIGMISMATCH EMAKEHR(0x12f4)
+#define VLDTR_E_TD_ENUMHASMETHODS EMAKEHR(0x12f5)
+#define VLDTR_E_TD_ENUMIMPLIFACE EMAKEHR(0x12f6)
+#define VLDTR_E_TD_ENUMHASPROP EMAKEHR(0x12f7)
+#define VLDTR_E_TD_ENUMHASEVENT EMAKEHR(0x12f8)
+#define VLDTR_E_TD_BADMETHODLST EMAKEHR(0x12f9)
+#define VLDTR_E_TD_BADFIELDLST EMAKEHR(0x12fa)
+#define VLDTR_E_CN_BADTYPE EMAKEHR(0x12fb)
+#define VLDTR_E_TD_ENUMNOINSTFLD EMAKEHR(0x12fc)
+#define VLDTR_E_TD_ENUMMULINSTFLD EMAKEHR(0x12fd)
+#define VLDTR_E_INTERRUPTED EMAKEHR(0x12fe)
+#define VLDTR_E_NOTINIT EMAKEHR(0x12ff)
+#define VLDTR_E_IFACE_NOTIFACE EMAKEHR(0x1b00)
+#define VLDTR_E_FD_RVAHASNORVA EMAKEHR(0x1b01)
+#define VLDTR_E_FD_RVAHASZERORVA EMAKEHR(0x1b02)
+#define VLDTR_E_MD_RVAANDIMPLMAP EMAKEHR(0x1b03)
+#define VLDTR_E_TD_EXTRAFLAGS EMAKEHR(0x1b04)
+#define VLDTR_E_TD_EXTENDSITSELF EMAKEHR(0x1b05)
+#define VLDTR_E_TD_SYSVTNOTEXTOBJ EMAKEHR(0x1b06)
+#define VLDTR_E_TD_EXTTYPESPEC EMAKEHR(0x1b07)
+#define VLDTR_E_TD_VTNOSIZE EMAKEHR(0x1b09)
+#define VLDTR_E_TD_IFACESEALED EMAKEHR(0x1b0a)
+#define VLDTR_E_NC_BADNESTED EMAKEHR(0x1b0b)
+#define VLDTR_E_NC_BADENCLOSER EMAKEHR(0x1b0c)
+#define VLDTR_E_NC_DUP EMAKEHR(0x1b0d)
+#define VLDTR_E_NC_DUPENCLOSER EMAKEHR(0x1b0e)
+#define VLDTR_E_FRVA_ZERORVA EMAKEHR(0x1b0f)
+#define VLDTR_E_FRVA_BADFIELD EMAKEHR(0x1b10)
+#define VLDTR_E_FRVA_DUPRVA EMAKEHR(0x1b11)
+#define VLDTR_E_FRVA_DUPFIELD EMAKEHR(0x1b12)
+#define VLDTR_E_EP_BADTOKEN EMAKEHR(0x1b13)
+#define VLDTR_E_EP_INSTANCE EMAKEHR(0x1b14)
+#define VLDTR_E_TD_ENUMFLDBADTYPE EMAKEHR(0x1b15)
+#define VLDTR_E_MD_BADRVA EMAKEHR(0x1b16)
+#define VLDTR_E_FD_LITERALNODEFAULT EMAKEHR(0x1b17)
+#define VLDTR_E_IFACE_METHNOTIMPL EMAKEHR(0x1b18)
+#define VLDTR_E_CA_BADPARENT EMAKEHR(0x1b19)
+#define VLDTR_E_CA_BADTYPE EMAKEHR(0x1b1a)
+#define VLDTR_E_CA_NOTCTOR EMAKEHR(0x1b1b)
+#define VLDTR_E_CA_BADSIG EMAKEHR(0x1b1c)
+#define VLDTR_E_CA_NOSIG EMAKEHR(0x1b1d)
+#define VLDTR_E_CA_BADPROLOG EMAKEHR(0x1b1e)
+#define VLDTR_E_MD_BADLOCALSIGTOK EMAKEHR(0x1b1f)
+#define VLDTR_E_MD_BADHEADER EMAKEHR(0x1b20)
+#define VLDTR_E_EP_TOOMANYARGS EMAKEHR(0x1b21)
+#define VLDTR_E_EP_BADRET EMAKEHR(0x1b22)
+#define VLDTR_E_EP_BADARG EMAKEHR(0x1b23)
+#define VLDTR_E_SIG_BADVOID EMAKEHR(0x1b24)
+#define VLDTR_E_IFACE_METHMULTIMPL EMAKEHR(0x1b25)
+#define VLDTR_E_GP_NAMENULL EMAKEHR(0x1b26)
+#define VLDTR_E_GP_OWNERNIL EMAKEHR(0x1b27)
+#define VLDTR_E_GP_DUPNAME EMAKEHR(0x1b28)
+#define VLDTR_E_GP_DUPNUMBER EMAKEHR(0x1b29)
+#define VLDTR_E_GP_NONSEQ_BY_OWNER EMAKEHR(0x1b2a)
+#define VLDTR_E_GP_NONSEQ_BY_NUMBER EMAKEHR(0x1b2b)
+#define VLDTR_E_GP_UNEXPECTED_OWNER_FOR_VARIANT_VAR EMAKEHR(0x1b2c)
+#define VLDTR_E_GP_ILLEGAL_VARIANT_MVAR EMAKEHR(0x1b2d)
+#define VLDTR_E_GP_ILLEGAL_VARIANCE_FLAGS EMAKEHR(0x1b2e)
+#define VLDTR_E_GP_REFANDVALUETYPE EMAKEHR(0x1b2f)
+#define VLDTR_E_GPC_OWNERNIL EMAKEHR(0x1b30)
+#define VLDTR_E_GPC_DUP EMAKEHR(0x1b31)
+#define VLDTR_E_GPC_NONCONTIGUOUS EMAKEHR(0x1b32)
+#define VLDTR_E_MS_METHODNIL EMAKEHR(0x1b33)
+#define VLDTR_E_MS_DUP EMAKEHR(0x1b34)
+#define VLDTR_E_MS_BADCALLINGCONV EMAKEHR(0x1b35)
+#define VLDTR_E_MS_MISSARITY EMAKEHR(0x1b36)
+#define VLDTR_E_MS_MISSARG EMAKEHR(0x1b37)
+#define VLDTR_E_MS_ARITYMISMATCH EMAKEHR(0x1b38)
+#define VLDTR_E_MS_METHODNOTGENERIC EMAKEHR(0x1b39)
+#define VLDTR_E_SIG_MISSARITY EMAKEHR(0x1b3a)
+#define VLDTR_E_SIG_ARITYMISMATCH EMAKEHR(0x1b3b)
+#define VLDTR_E_MD_GENERIC_CCTOR EMAKEHR(0x1b3c)
+#define VLDTR_E_MD_GENERIC_CTOR EMAKEHR(0x1b3d)
+#define VLDTR_E_MD_GENERIC_IMPORT EMAKEHR(0x1b3e)
+#define VLDTR_E_MD_GENERIC_BADCALLCONV EMAKEHR(0x1b3f)
+#define VLDTR_E_EP_GENERIC_METHOD EMAKEHR(0x1b40)
+#define VLDTR_E_MD_MISSARITY EMAKEHR(0x1b41)
+#define VLDTR_E_MD_ARITYZERO EMAKEHR(0x1b42)
+#define VLDTR_E_SIG_ARITYZERO EMAKEHR(0x1b43)
+#define VLDTR_E_MS_ARITYZERO EMAKEHR(0x1b44)
+#define VLDTR_E_MD_GPMISMATCH EMAKEHR(0x1b45)
+#define VLDTR_E_EP_GENERIC_TYPE EMAKEHR(0x1b46)
+#define VLDTR_E_MI_DECLNOTGENERIC EMAKEHR(0x1b47)
+#define VLDTR_E_MI_IMPLNOTGENERIC EMAKEHR(0x1b48)
+#define VLDTR_E_MI_ARITYMISMATCH EMAKEHR(0x1b49)
+#define VLDTR_E_TD_EXTBADTYPESPEC EMAKEHR(0x1b4a)
+#define VLDTR_E_SIG_BYREFINST EMAKEHR(0x1b4b)
+#define VLDTR_E_MS_BYREFINST EMAKEHR(0x1b4c)
+#define VLDTR_E_TS_EMPTY EMAKEHR(0x1b4d)
+#define VLDTR_E_TS_HASSENTINALS EMAKEHR(0x1b4e)
+#define VLDTR_E_TD_GENERICHASEXPLAYOUT EMAKEHR(0x1b4f)
+#define VLDTR_E_SIG_BADTOKTYPE EMAKEHR(0x1b50)
+#define VLDTR_E_IFACE_METHNOTIMPLTHISMOD EMAKEHR(0x1b51)
+
+#define VLDTR_S_WRN SMAKEHR(0x1200)
+#define VLDTR_S_ERR SMAKEHR(0x1201)
+#define VLDTR_S_WRNERR SMAKEHR(0x1202)
+
+#define CORDBG_E_UNRECOVERABLE_ERROR EMAKEHR(0x1300)
+#define CORDBG_E_PROCESS_TERMINATED EMAKEHR(0x1301)
+#define CORDBG_E_PROCESS_NOT_SYNCHRONIZED EMAKEHR(0x1302)
+#define CORDBG_E_CLASS_NOT_LOADED EMAKEHR(0x1303)
+#define CORDBG_E_IL_VAR_NOT_AVAILABLE EMAKEHR(0x1304)
+#define CORDBG_E_BAD_REFERENCE_VALUE EMAKEHR(0x1305)
+#define CORDBG_E_FIELD_NOT_AVAILABLE EMAKEHR(0x1306)
+#define CORDBG_E_NON_NATIVE_FRAME EMAKEHR(0x1307)
+#define CORDBG_E_NONCONTINUABLE_EXCEPTION EMAKEHR(0x1308)
+#define CORDBG_E_CODE_NOT_AVAILABLE EMAKEHR(0x1309)
+#define CORDBG_E_FUNCTION_NOT_IL EMAKEHR(0x130a)
+#define CORDBG_E_CANT_SET_IP_INTO_FINALLY EMAKEHR(0x130e)
+#define CORDBG_E_CANT_SET_IP_OUT_OF_FINALLY EMAKEHR(0x130f)
+#define CORDBG_E_CANT_SET_IP_INTO_CATCH EMAKEHR(0x1310)
+#define CORDBG_E_SET_IP_NOT_ALLOWED_ON_NONLEAF_FRAME EMAKEHR(0x1311)
+#define CORDBG_E_SET_IP_IMPOSSIBLE EMAKEHR(0x1312)
+#define CORDBG_E_FUNC_EVAL_BAD_START_POINT EMAKEHR(0x1313)
+#define CORDBG_E_INVALID_OBJECT EMAKEHR(0x1314)
+#define CORDBG_E_FUNC_EVAL_NOT_COMPLETE EMAKEHR(0x1315)
+#define CORDBG_E_INPROC_NOT_IMPL EMAKEHR(0x1318)
+#define CORDBG_E_STATIC_VAR_NOT_AVAILABLE EMAKEHR(0x131a)
+#define CORDBG_E_OBJECT_IS_NOT_COPYABLE_VALUE_CLASS EMAKEHR(0x131b)
+#define CORDBG_E_CANT_SETIP_INTO_OR_OUT_OF_FILTER EMAKEHR(0x131c)
+#define CORDBG_E_CANT_CHANGE_JIT_SETTING_FOR_ZAP_MODULE EMAKEHR(0x131d)
+#define CORDBG_E_CANT_SET_IP_OUT_OF_FINALLY_ON_WIN64 EMAKEHR(0x131e)
+#define CORDBG_E_CANT_SET_IP_OUT_OF_CATCH_ON_WIN64 EMAKEHR(0x131f)
+#define CORDBG_E_REMOTE_CONNECTION_CONN_RESET EMAKEHR(0x1320)
+#define CORDBG_E_REMOTE_CONNECTION_KEEP_ALIVE EMAKEHR(0x1321)
+#define CORDBG_E_REMOTE_CONNECTION_FATAL_ERROR EMAKEHR(0x1322)
+#define CORDBG_E_CANT_SET_TO_JMC EMAKEHR(0x1323)
+#define CORDBG_E_NO_CONTEXT_FOR_INTERNAL_FRAME EMAKEHR(0x1325)
+#define CORDBG_E_NOT_CHILD_FRAME EMAKEHR(0x1326)
+#define CORDBG_E_NON_MATCHING_CONTEXT EMAKEHR(0x1327)
+#define CORDBG_E_PAST_END_OF_STACK EMAKEHR(0x1328)
+#define CORDBG_E_FUNC_EVAL_CANNOT_UPDATE_REGISTER_IN_NONLEAF_FRAME EMAKEHR(0x1329)
+#define CORDBG_E_BAD_THREAD_STATE EMAKEHR(0x132d)
+#define CORDBG_E_DEBUGGER_ALREADY_ATTACHED EMAKEHR(0x132e)
+#define CORDBG_E_SUPERFLOUS_CONTINUE EMAKEHR(0x132f)
+#define CORDBG_E_SET_VALUE_NOT_ALLOWED_ON_NONLEAF_FRAME EMAKEHR(0x1330)
+#define CORDBG_E_ENC_EH_MAX_NESTING_LEVEL_CANT_INCREASE EMAKEHR(0x1331)
+#define CORDBG_E_ENC_MODULE_NOT_ENC_ENABLED EMAKEHR(0x1332)
+#define CORDBG_E_SET_IP_NOT_ALLOWED_ON_EXCEPTION EMAKEHR(0x1333)
+#define CORDBG_E_VARIABLE_IS_ACTUALLY_LITERAL EMAKEHR(0x1334)
+#define CORDBG_E_PROCESS_DETACHED EMAKEHR(0x1335)
+#define CORDBG_E_ENC_METHOD_SIG_CHANGED EMAKEHR(0x1336)
+#define CORDBG_E_ENC_METHOD_NO_LOCAL_SIG EMAKEHR(0x1337)
+#define CORDBG_E_ENC_CANT_ADD_FIELD_TO_VALUE_OR_LAYOUT_CLASS EMAKEHR(0x1338)
+#define CORDBG_E_ENC_CANT_CHANGE_FIELD EMAKEHR(0x1339)
+#define CORDBG_E_ENC_CANT_ADD_NON_PRIVATE_MEMBER EMAKEHR(0x133a)
+#define CORDBG_E_FIELD_NOT_STATIC EMAKEHR(0x133b)
+#define CORDBG_E_FIELD_NOT_INSTANCE EMAKEHR(0x133c)
+#define CORDBG_E_ENC_ZAPPED_WITHOUT_ENC EMAKEHR(0x133d)
+#define CORDBG_E_ENC_BAD_METHOD_INFO EMAKEHR(0x133e)
+#define CORDBG_E_ENC_JIT_CANT_UPDATE EMAKEHR(0x133f)
+#define CORDBG_E_ENC_MISSING_CLASS EMAKEHR(0x1340)
+#define CORDBG_E_ENC_INTERNAL_ERROR EMAKEHR(0x1341)
+#define CORDBG_E_ENC_HANGING_FIELD EMAKEHR(0x1342)
+#define CORDBG_E_MODULE_NOT_LOADED EMAKEHR(0x1343)
+#define CORDBG_E_ENC_CANT_CHANGE_SUPERCLASS EMAKEHR(0x1344)
+#define CORDBG_E_UNABLE_TO_SET_BREAKPOINT EMAKEHR(0x1345)
+#define CORDBG_E_DEBUGGING_NOT_POSSIBLE EMAKEHR(0x1346)
+#define CORDBG_E_KERNEL_DEBUGGER_ENABLED EMAKEHR(0x1347)
+#define CORDBG_E_KERNEL_DEBUGGER_PRESENT EMAKEHR(0x1348)
+#define CORDBG_E_HELPER_THREAD_DEAD EMAKEHR(0x1349)
+#define CORDBG_E_INTERFACE_INHERITANCE_CANT_CHANGE EMAKEHR(0x134a)
+#define CORDBG_E_INCOMPATIBLE_PROTOCOL EMAKEHR(0x134b)
+#define CORDBG_E_TOO_MANY_PROCESSES EMAKEHR(0x134c)
+#define CORDBG_E_INTEROP_NOT_SUPPORTED EMAKEHR(0x134d)
+#define CORDBG_E_NO_REMAP_BREAKPIONT EMAKEHR(0x134e)
+#define CORDBG_E_OBJECT_NEUTERED EMAKEHR(0x134f)
+#define CORDBG_E_THREAD_NOT_SCHEDULED EMAKEHR(0x1c00)
+#define CORDBG_E_HANDLE_HAS_BEEN_DISPOSED EMAKEHR(0x1c01)
+#define CORDBG_E_NONINTERCEPTABLE_EXCEPTION EMAKEHR(0x1c02)
+#define CORDBG_E_CANT_UNWIND_ABOVE_CALLBACK EMAKEHR(0x1c03)
+#define CORDBG_E_INTERCEPT_FRAME_ALREADY_SET EMAKEHR(0x1c04)
+#define CORDBG_E_NO_NATIVE_PATCH_AT_ADDR EMAKEHR(0x1c05)
+#define CORDBG_E_MUST_BE_INTEROP_DEBUGGING EMAKEHR(0x1c06)
+#define CORDBG_E_NATIVE_PATCH_ALREADY_AT_ADDR EMAKEHR(0x1c07)
+#define CORDBG_E_TIMEOUT EMAKEHR(0x1c08)
+#define CORDBG_E_CANT_CALL_ON_THIS_THREAD EMAKEHR(0x1c09)
+#define CORDBG_E_ENC_INFOLESS_METHOD EMAKEHR(0x1c0a)
+#define CORDBG_E_ENC_NESTED_HANLDERS EMAKEHR(0x1c0b)
+#define CORDBG_E_ENC_IN_FUNCLET EMAKEHR(0x1c0c)
+#define CORDBG_E_ENC_LOCALLOC EMAKEHR(0x1c0d)
+#define CORDBG_E_ENC_EDIT_NOT_SUPPORTED EMAKEHR(0x1c0e)
+#define CORDBG_E_FEABORT_DELAYED_UNTIL_THREAD_RESUMED EMAKEHR(0x1c0f)
+#define CORDBG_E_NOTREADY EMAKEHR(0x1c10)
+#define CORDBG_E_CANNOT_RESOLVE_ASSEMBLY EMAKEHR(0x1c11)
+#define CORDBG_E_MUST_BE_IN_LOAD_MODULE EMAKEHR(0x1c12)
+#define CORDBG_E_CANNOT_BE_ON_ATTACH EMAKEHR(0x1c13)
+#define CORDBG_E_NGEN_NOT_SUPPORTED EMAKEHR(0x1c14)
+#define CORDBG_E_ILLEGAL_SHUTDOWN_ORDER EMAKEHR(0x1c15)
+#define CORDBG_E_CANNOT_DEBUG_FIBER_PROCESS EMAKEHR(0x1c16)
+#define CORDBG_E_MUST_BE_IN_CREATE_PROCESS EMAKEHR(0x1c17)
+#define CORDBG_E_DETACH_FAILED_OUTSTANDING_EVALS EMAKEHR(0x1c18)
+#define CORDBG_E_DETACH_FAILED_OUTSTANDING_STEPPERS EMAKEHR(0x1c19)
+#define CORDBG_E_CANT_INTEROP_STEP_OUT EMAKEHR(0x1c20)
+#define CORDBG_E_DETACH_FAILED_OUTSTANDING_BREAKPOINTS EMAKEHR(0x1c21)
+#define CORDBG_E_ILLEGAL_IN_STACK_OVERFLOW EMAKEHR(0x1c22)
+#define CORDBG_E_ILLEGAL_AT_GC_UNSAFE_POINT EMAKEHR(0x1c23)
+#define CORDBG_E_ILLEGAL_IN_PROLOG EMAKEHR(0x1c24)
+#define CORDBG_E_ILLEGAL_IN_NATIVE_CODE EMAKEHR(0x1c25)
+#define CORDBG_E_ILLEGAL_IN_OPTIMIZED_CODE EMAKEHR(0x1c26)
+#define CORDBG_E_MINIDUMP_UNSUPPORTED EMAKEHR(0x1c27)
+#define CORDBG_E_APPDOMAIN_MISMATCH EMAKEHR(0x1c28)
+#define CORDBG_E_CONTEXT_UNVAILABLE EMAKEHR(0x1c29)
+#define CORDBG_E_UNCOMPATIBLE_PLATFORMS EMAKEHR(0x1c30)
+#define CORDBG_E_DEBUGGING_DISABLED EMAKEHR(0x1c31)
+#define CORDBG_E_DETACH_FAILED_ON_ENC EMAKEHR(0x1c32)
+#define CORDBG_E_CURRENT_EXCEPTION_IS_OUTSIDE_CURRENT_EXECUTION_SCOPE EMAKEHR(0x1c33)
+#define CORDBG_E_HELPER_MAY_DEADLOCK EMAKEHR(0x1c34)
+#define CORDBG_E_MISSING_METADATA EMAKEHR(0x1c35)
+#define CORDBG_E_TARGET_INCONSISTENT EMAKEHR(0x1c36)
+#define CORDBG_E_DETACH_FAILED_OUTSTANDING_TARGET_RESOURCES EMAKEHR(0x1c37)
+#define CORDBG_E_TARGET_READONLY EMAKEHR(0x1c38)
+#define CORDBG_E_MISMATCHED_CORWKS_AND_DACWKS_DLLS EMAKEHR(0x1c39)
+#define CORDBG_E_MODULE_LOADED_FROM_DISK EMAKEHR(0x1c3a)
+#define CORDBG_E_SYMBOLS_NOT_AVAILABLE EMAKEHR(0x1c3b)
+#define CORDBG_E_DEBUG_COMPONENT_MISSING EMAKEHR(0x1c3c)
+#define CORDBG_E_REMOTE_MISMATCHED_CERTS EMAKEHR(0x1c3d)
+#define CORDBG_E_REMOTE_NETWORK_FAILURE EMAKEHR(0x1c3e)
+#define CORDBG_E_REMOTE_NO_LISTENER EMAKEHR(0x1c3f)
+#define CORDBG_E_REMOTE_UNKNOWN_TARGET EMAKEHR(0x1c40)
+#define CORDBG_E_REMOTE_INVALID_CONFIG EMAKEHR(0x1c41)
+#define CORDBG_E_REMOTE_MISMATCHED_PROTOCOLS EMAKEHR(0x1c42)
+#define CORDBG_E_LIBRARY_PROVIDER_ERROR EMAKEHR(0x1c43)
+#define CORDBG_E_NOT_CLR EMAKEHR(0x1c44)
+#define CORDBG_E_MISSING_DATA_TARGET_INTERFACE EMAKEHR(0x1c45)
+#define CORDBG_E_UNSUPPORTED_DEBUGGING_MODEL EMAKEHR(0x1c46)
+#define CORDBG_E_UNSUPPORTED_FORWARD_COMPAT EMAKEHR(0x1c47)
+#define CORDBG_E_UNSUPPORTED_VERSION_STRUCT EMAKEHR(0x1c48)
+#define CORDBG_E_READVIRTUAL_FAILURE EMAKEHR(0x1c49)
+#define CORDBG_E_VALUE_POINTS_TO_FUNCTION EMAKEHR(0x1c4a)
+#define CORDBG_E_CORRUPT_OBJECT EMAKEHR(0x1c4b)
+#define CORDBG_E_GC_STRUCTURES_INVALID EMAKEHR(0x1c4c)
+
+#define CORDBG_S_BAD_START_SEQUENCE_POINT SMAKEHR(0x130b)
+#define CORDBG_S_BAD_END_SEQUENCE_POINT SMAKEHR(0x130c)
+#define CORDBG_S_INSUFFICIENT_INFO_FOR_SET_IP SMAKEHR(0x130d)
+#define CORDBG_S_FUNC_EVAL_HAS_NO_RESULT SMAKEHR(0x1316)
+#define CORDBG_S_VALUE_POINTS_TO_VOID SMAKEHR(0x1317)
+#define CORDBG_S_FUNC_EVAL_ABORTED SMAKEHR(0x1319)
+#define CORDBG_S_AT_END_OF_STACK SMAKEHR(0x1324)
+#define CORDBG_S_NOT_ALL_BITS_SET SMAKEHR(0x1c13)
+
+#define CORPROF_E_FUNCTION_NOT_COMPILED EMAKEHR(0x1350)
+#define CORPROF_E_DATAINCOMPLETE EMAKEHR(0x1351)
+#define CORPROF_E_NOT_REJITABLE_METHODS EMAKEHR(0x1352)
+#define CORPROF_E_CANNOT_UPDATE_METHOD EMAKEHR(0x1353)
+#define CORPROF_E_FUNCTION_NOT_IL EMAKEHR(0x1354)
+#define CORPROF_E_NOT_MANAGED_THREAD EMAKEHR(0x1355)
+#define CORPROF_E_CALL_ONLY_FROM_INIT EMAKEHR(0x1356)
+#define CORPROF_E_INPROC_NOT_ENABLED EMAKEHR(0x1357)
+#define CORPROF_E_JITMAPS_NOT_ENABLED EMAKEHR(0x1358)
+#define CORPROF_E_INPROC_ALREADY_BEGUN EMAKEHR(0x1359)
+#define CORPROF_E_INPROC_NOT_AVAILABLE EMAKEHR(0x135a)
+#define CORPROF_E_NOT_YET_AVAILABLE EMAKEHR(0x135b)
+#define CORPROF_E_TYPE_IS_PARAMETERIZED EMAKEHR(0x135c)
+#define CORPROF_E_FUNCTION_IS_PARAMETERIZED EMAKEHR(0x135d)
+#define CORPROF_E_STACKSNAPSHOT_INVALID_TGT_THREAD EMAKEHR(0x135e)
+#define CORPROF_E_STACKSNAPSHOT_UNMANAGED_CTX EMAKEHR(0x135f)
+#define CORPROF_E_STACKSNAPSHOT_UNSAFE EMAKEHR(0x1360)
+#define CORPROF_E_STACKSNAPSHOT_ABORTED EMAKEHR(0x1361)
+#define CORPROF_E_LITERALS_HAVE_NO_ADDRESS EMAKEHR(0x1362)
+#define CORPROF_E_UNSUPPORTED_CALL_SEQUENCE EMAKEHR(0x1363)
+#define CORPROF_E_ASYNCHRONOUS_UNSAFE EMAKEHR(0x1364)
+#define CORPROF_E_CLASSID_IS_ARRAY EMAKEHR(0x1365)
+#define CORPROF_E_CLASSID_IS_COMPOSITE EMAKEHR(0x1366)
+#define CORPROF_E_PROFILER_DETACHING EMAKEHR(0x1367)
+#define CORPROF_E_PROFILER_NOT_ATTACHABLE EMAKEHR(0x1368)
+#define CORPROF_E_UNRECOGNIZED_PIPE_MSG_FORMAT EMAKEHR(0x1369)
+#define CORPROF_E_PROFILER_ALREADY_ACTIVE EMAKEHR(0x136a)
+#define CORPROF_E_PROFILEE_INCOMPATIBLE_WITH_TRIGGER EMAKEHR(0x136b)
+#define CORPROF_E_IPC_FAILED EMAKEHR(0x136c)
+#define CORPROF_E_PROFILEE_PROCESS_NOT_FOUND EMAKEHR(0x136d)
+#define CORPROF_E_CALLBACK3_REQUIRED EMAKEHR(0x136e)
+#define CORPROF_E_UNSUPPORTED_FOR_ATTACHING_PROFILER EMAKEHR(0x136f)
+#define CORPROF_E_IRREVERSIBLE_INSTRUMENTATION_PRESENT EMAKEHR(0x1370)
+#define CORPROF_E_RUNTIME_UNINITIALIZED EMAKEHR(0x1371)
+#define CORPROF_E_IMMUTABLE_FLAGS_SET EMAKEHR(0x1372)
+#define CORPROF_E_PROFILER_NOT_YET_INITIALIZED EMAKEHR(0x1373)
+#define CORPROF_E_INCONSISTENT_WITH_FLAGS EMAKEHR(0x1374)
+#define CORPROF_E_PROFILER_CANCEL_ACTIVATION EMAKEHR(0x1375)
+#define CORPROF_E_CONCURRENT_GC_NOT_PROFILABLE EMAKEHR(0x1376)
+#define CORPROF_E_INCONSISTENT_FLAGS_WITH_HOST_PROTECTION_SETTING EMAKEHR(0x1377)
+#define CORPROF_E_DEBUGGING_DISABLED EMAKEHR(0x1378)
+#define CORPROF_E_TIMEOUT_WAITING_FOR_CONCURRENT_GC EMAKEHR(0x1379)
+#define CORPROF_E_MODULE_IS_DYNAMIC EMAKEHR(0x137a)
+#define CORPROF_E_CALLBACK4_REQUIRED EMAKEHR(0x137b)
+#define CORPROF_E_REJIT_NOT_ENABLED EMAKEHR(0x137c)
+#define CORPROF_E_ACTIVE_REJIT_REQUEST_NOT_FOUND EMAKEHR(0x137d)
+#define CORPROF_E_FUNCTION_IS_COLLECTIBLE EMAKEHR(0x137e)
+#define CORPROF_E_REJIT_REQUIRES_DISABLE_NGEN EMAKEHR(0x137f)
+
+#define CORSEC_E_DECODE_SET EMAKEHR(0x1410)
+#define CORSEC_E_ENCODE_SET EMAKEHR(0x1411)
+#define CORSEC_E_UNSUPPORTED_FORMAT EMAKEHR(0x1412)
+#define CORSEC_E_CRYPTOAPI_CALL_FAILED EMAKEHR(0x1413)
+#define CORSEC_E_NO_SUITABLE_CSP EMAKEHR(0x1414)
+#define CORSEC_E_INVALID_ATTR EMAKEHR(0x1415)
+#define CORSEC_E_POLICY_EXCEPTION EMAKEHR(0x1416)
+#define CORSEC_E_MIN_GRANT_FAIL EMAKEHR(0x1417)
+#define CORSEC_E_NO_EXEC_PERM EMAKEHR(0x1418)
+#define CORSEC_E_XMLSYNTAX EMAKEHR(0x1419)
+#define CORSEC_E_INVALID_STRONGNAME EMAKEHR(0x141a)
+#define CORSEC_E_MISSING_STRONGNAME EMAKEHR(0x141b)
+#define CORSEC_E_CONTAINER_NOT_FOUND EMAKEHR(0x141c)
+#define CORSEC_E_INVALID_IMAGE_FORMAT EMAKEHR(0x141d)
+#define CORSEC_E_INVALID_PUBLICKEY EMAKEHR(0x141e)
+#define CORSEC_E_SIGNATURE_MISMATCH EMAKEHR(0x1420)
+#define CORSEC_E_INVALID_SIGNATUREKEY EMAKEHR(0x1422)
+#define CORSEC_E_INVALID_COUNTERSIGNATURE EMAKEHR(0x1423)
+#define CORSEC_E_CRYPTO EMAKEHR(0x1430)
+#define CORSEC_E_CRYPTO_UNEX_OPER EMAKEHR(0x1431)
+
+#define CORSECATTR_E_BAD_ATTRIBUTE EMAKEHR(0x143a)
+#define CORSECATTR_E_MISSING_CONSTRUCTOR EMAKEHR(0x143b)
+#define CORSECATTR_E_FAILED_TO_CREATE_PERM EMAKEHR(0x143c)
+#define CORSECATTR_E_BAD_ACTION_ASM EMAKEHR(0x143d)
+#define CORSECATTR_E_BAD_ACTION_OTHER EMAKEHR(0x143e)
+#define CORSECATTR_E_BAD_PARENT EMAKEHR(0x143f)
+#define CORSECATTR_E_TRUNCATED EMAKEHR(0x1440)
+#define CORSECATTR_E_BAD_VERSION EMAKEHR(0x1441)
+#define CORSECATTR_E_BAD_ACTION EMAKEHR(0x1442)
+#define CORSECATTR_E_NO_SELF_REF EMAKEHR(0x1443)
+#define CORSECATTR_E_BAD_NONCAS EMAKEHR(0x1444)
+#define CORSECATTR_E_ASSEMBLY_LOAD_FAILED EMAKEHR(0x1445)
+#define CORSECATTR_E_ASSEMBLY_LOAD_FAILED_EX EMAKEHR(0x1446)
+#define CORSECATTR_E_TYPE_LOAD_FAILED EMAKEHR(0x1447)
+#define CORSECATTR_E_TYPE_LOAD_FAILED_EX EMAKEHR(0x1448)
+#define CORSECATTR_E_ABSTRACT EMAKEHR(0x1449)
+#define CORSECATTR_E_UNSUPPORTED_TYPE EMAKEHR(0x144a)
+#define CORSECATTR_E_UNSUPPORTED_ENUM_TYPE EMAKEHR(0x144b)
+#define CORSECATTR_E_NO_FIELD EMAKEHR(0x144c)
+#define CORSECATTR_E_NO_PROPERTY EMAKEHR(0x144d)
+#define CORSECATTR_E_EXCEPTION EMAKEHR(0x144e)
+#define CORSECATTR_E_EXCEPTION_HR EMAKEHR(0x144f)
+
+#define CEE_E_ENTRYPOINT EMAKEHR(0x1000)
+#define CEE_E_CVTRES_NOT_FOUND EMAKEHR(0x1001)
+
+#define HOST_E_DEADLOCK EMAKEHR(0x1020)
+#define HOST_E_INTERRUPTED EMAKEHR(0x1021)
+#define HOST_E_INVALIDOPERATION EMAKEHR(0x1022)
+#define HOST_E_CLRNOTAVAILABLE EMAKEHR(0x1023)
+#define HOST_E_TIMEOUT EMAKEHR(0x1024)
+#define HOST_E_NOT_OWNER EMAKEHR(0x1025)
+#define HOST_E_ABANDONED EMAKEHR(0x1026)
+#define HOST_E_EXITPROCESS_THREADABORT EMAKEHR(0x1027)
+#define HOST_E_EXITPROCESS_ADUNLOAD EMAKEHR(0x1028)
+#define HOST_E_EXITPROCESS_TIMEOUT EMAKEHR(0x1029)
+#define HOST_E_EXITPROCESS_OUTOFMEMORY EMAKEHR(0x102a)
+#define HOST_E_EXITPROCESS_STACKOVERFLOW EMAKEHR(0x102b)
+
+#define ISS_E_ISOSTORE_START EMAKEHR(0x1450)
+#define ISS_E_ISOSTORE EMAKEHR(0x1450)
+#define ISS_E_OPEN_STORE_FILE EMAKEHR(0x1460)
+#define ISS_E_OPEN_FILE_MAPPING EMAKEHR(0x1461)
+#define ISS_E_MAP_VIEW_OF_FILE EMAKEHR(0x1462)
+#define ISS_E_GET_FILE_SIZE EMAKEHR(0x1463)
+#define ISS_E_CREATE_MUTEX EMAKEHR(0x1464)
+#define ISS_E_LOCK_FAILED EMAKEHR(0x1465)
+#define ISS_E_FILE_WRITE EMAKEHR(0x1466)
+#define ISS_E_SET_FILE_POINTER EMAKEHR(0x1467)
+#define ISS_E_CREATE_DIR EMAKEHR(0x1468)
+#define ISS_E_STORE_NOT_OPEN EMAKEHR(0x1469)
+#define ISS_E_CORRUPTED_STORE_FILE EMAKEHR(0x1480)
+#define ISS_E_STORE_VERSION EMAKEHR(0x1481)
+#define ISS_E_FILE_NOT_MAPPED EMAKEHR(0x1482)
+#define ISS_E_BLOCK_SIZE_TOO_SMALL EMAKEHR(0x1483)
+#define ISS_E_ALLOC_TOO_LARGE EMAKEHR(0x1484)
+#define ISS_E_USAGE_WILL_EXCEED_QUOTA EMAKEHR(0x1485)
+#define ISS_E_TABLE_ROW_NOT_FOUND EMAKEHR(0x1486)
+#define ISS_E_DEPRECATE EMAKEHR(0x14a0)
+#define ISS_E_CALLER EMAKEHR(0x14a1)
+#define ISS_E_PATH_LENGTH EMAKEHR(0x14a2)
+#define ISS_E_MACHINE EMAKEHR(0x14a3)
+#define ISS_E_MACHINE_DACL EMAKEHR(0x14a4)
+#define ISS_E_ISOSTORE_END EMAKEHR(0x14ff)
+
+#define META_E_DUPLICATE EMAKEHR(0x1180)
+#define META_E_GUID_REQUIRED EMAKEHR(0x1181)
+#define META_E_TYPEDEF_MISMATCH EMAKEHR(0x1182)
+#define META_E_MERGE_COLLISION EMAKEHR(0x1183)
+#define META_E_METHD_NOT_FOUND EMAKEHR(0x1187)
+#define META_E_FIELD_NOT_FOUND EMAKEHR(0x1188)
+#define META_E_PARAM_MISMATCH EMAKEHR(0x1189)
+#define META_E_BADMETADATA EMAKEHR(0x118a)
+#define META_E_INTFCEIMPL_NOT_FOUND EMAKEHR(0x118b)
+#define META_E_CLASS_LAYOUT_INCONSISTENT EMAKEHR(0x118d)
+#define META_E_FIELD_MARSHAL_NOT_FOUND EMAKEHR(0x118e)
+#define META_E_METHODSEM_NOT_FOUND EMAKEHR(0x118f)
+#define META_E_EVENT_NOT_FOUND EMAKEHR(0x1190)
+#define META_E_PROP_NOT_FOUND EMAKEHR(0x1191)
+#define META_E_BAD_SIGNATURE EMAKEHR(0x1192)
+#define META_E_BAD_INPUT_PARAMETER EMAKEHR(0x1193)
+#define META_E_METHDIMPL_INCONSISTENT EMAKEHR(0x1194)
+#define META_E_MD_INCONSISTENCY EMAKEHR(0x1195)
+#define META_E_CANNOTRESOLVETYPEREF EMAKEHR(0x1196)
+#define META_E_STRINGSPACE_FULL EMAKEHR(0x1198)
+#define META_E_UNEXPECTED_REMAP EMAKEHR(0x1199)
+#define META_E_HAS_UNMARKALL EMAKEHR(0x119a)
+#define META_E_MUST_CALL_UNMARKALL EMAKEHR(0x119b)
+#define META_E_GENERICPARAM_INCONSISTENT EMAKEHR(0x119c)
+#define META_E_EVENT_COUNTS EMAKEHR(0x119d)
+#define META_E_PROPERTY_COUNTS EMAKEHR(0x119e)
+#define META_E_TYPEDEF_MISSING EMAKEHR(0x119f)
+#define META_E_INVALID_TOKEN_TYPE EMAKEHR(0x115f)
+#define META_E_CA_INVALID_TARGET EMAKEHR(0x11c0)
+#define META_E_CA_INVALID_VALUE EMAKEHR(0x11c1)
+#define META_E_CA_INVALID_BLOB EMAKEHR(0x11c2)
+#define META_E_CA_REPEATED_ARG EMAKEHR(0x11c3)
+#define META_E_CA_UNKNOWN_ARGUMENT EMAKEHR(0x11c4)
+#define META_E_CA_VARIANT_NYI EMAKEHR(0x11c5)
+#define META_E_CA_ARRAY_NYI EMAKEHR(0x11c6)
+#define META_E_CA_UNEXPECTED_TYPE EMAKEHR(0x11c7)
+#define META_E_CA_INVALID_ARGTYPE EMAKEHR(0x11c8)
+#define META_E_CA_INVALID_ARG_FOR_TYPE EMAKEHR(0x11c9)
+#define META_E_CA_INVALID_UUID EMAKEHR(0x11ca)
+#define META_E_CA_INVALID_MARSHALAS_FIELDS EMAKEHR(0x11cb)
+#define META_E_CA_NT_FIELDONLY EMAKEHR(0x11cc)
+#define META_E_CA_NEGATIVE_PARAMINDEX EMAKEHR(0x11cd)
+#define META_E_CA_NEGATIVE_MULTIPLIER EMAKEHR(0x11ce)
+#define META_E_CA_NEGATIVE_CONSTSIZE EMAKEHR(0x11cf)
+#define META_E_CA_FIXEDSTR_SIZE_REQUIRED EMAKEHR(0x11d0)
+#define META_E_CA_CUSTMARSH_TYPE_REQUIRED EMAKEHR(0x11d1)
+#define META_E_CA_FILENAME_REQUIRED EMAKEHR(0x11d2)
+#define META_E_NOT_IN_ENC_MODE EMAKEHR(0x11d4)
+#define META_E_METHOD_COUNTS EMAKEHR(0x11d6)
+#define META_E_FIELD_COUNTS EMAKEHR(0x11d7)
+#define META_E_PARAM_COUNTS EMAKEHR(0x11d8)
+#define META_E_MISMATCHED_VISIBLITY EMAKEHR(0x11e4)
+#define META_E_CA_BAD_FRIENDS_ARGS EMAKEHR(0x11e5)
+#define META_E_CA_FRIENDS_SN_REQUIRED EMAKEHR(0x11e6)
+
+#define MSEE_E_LOADLIBFAILED EMAKEHR(0x1010)
+#define MSEE_E_GETPROCFAILED EMAKEHR(0x1011)
+#define MSEE_E_MULTCOPIESLOADED EMAKEHR(0x1012)
+#define MSEE_E_ASSEMBLYLOADINPROGRESS EMAKEHR(0x1016)
+#define MSEE_E_CANNOTCREATEAPPDOMAIN EMAKEHR(0x1017)
+
+#define NGEN_FAILED_GET_DEPENDENCIES EMAKEHR(0x1f00)
+#define NGEN_FAILED_NATIVE_IMAGE_DELETE EMAKEHR(0x1f01)
+#define NGEN_E_TOO_MANY_INTERFACES EMAKEHR(0x1f02)
+#define NGEN_E_OLDER_RUNTIME EMAKEHR(0x1f03)
+#define NGEN_E_WORKER_UNEXPECTED_EXIT EMAKEHR(0x1f04)
+#define NGEN_E_WORKER_UNEXPECTED_SYNC EMAKEHR(0x1f05)
+#define NGEN_E_SYS_ASM_NI_MISSING EMAKEHR(0x1f06)
+#define NGEN_E_EXE_MACHINE_TYPE_MISMATCH EMAKEHR(0x1f07)
+#define NGEN_E_ASSEMBLY_EXCLUSION_FILE_PARSE_ERROR EMAKEHR(0x1f08)
+#define NGEN_E_HARDBOUND_DEPENDENCY_MISSING EMAKEHR(0x1f09)
+#define NGEN_E_NOT_RUNNING_IN_EXPECTED_PACKAGE EMAKEHR(0x1f0a)
+
+#define PEFMT_E_NO_CONTENTS      EMAKEHR(0x1d00)
+#define PEFMT_E_NO_NTHEADERS     EMAKEHR(0x1d01)
+#define PEFMT_E_64BIT            EMAKEHR(0x1d02)
+#define PEFMT_E_NO_CORHEADER     EMAKEHR(0x1d03)
+#define PEFMT_E_NOT_ILONLY       EMAKEHR(0x1d04)
+#define PEFMT_E_IMPORT_DLLS      EMAKEHR(0x1d05)
+#define PEFMT_E_EXE_NOENTRYPOINT EMAKEHR(0x1d06)
+#define PEFMT_E_BASE_RELOCS      EMAKEHR(0x1d07)
+#define PEFMT_E_ENTRYPOINT       EMAKEHR(0x1d08)
+#define PEFMT_E_ZERO_SIZEOFCODE  EMAKEHR(0x1d09)
+#define PEFMT_E_BAD_CORHEADER    EMAKEHR(0x1d0a)
+#define PEFMT_E_32BIT            EMAKEHR(0x1d0b)
+
+#define SECURITY_E_XML_TO_ASN_ENCODING   EMAKEHR(0x1400)
+#define SECURITY_E_INCOMPATIBLE_SHARE    EMAKEHR(0x1401)
+#define SECURITY_E_UNVERIFIABLE          EMAKEHR(0x1402)
+#define SECURITY_E_INCOMPATIBLE_EVIDENCE EMAKEHR(0x1403)
+
+#define SN_E_PUBLICKEY_MISMATCH EMAKEHR(0x1421)
+#define SN_CRYPTOAPI_CALL_FAILED EMAKEHR(0x1413)
+#define SN_NO_SUITABLE_CSP EMAKEHR(0x1414)
+
+#define VER_E_HRESULT EMAKEHR(0x1801)
+#define VER_E_OFFSET EMAKEHR(0x1802)
+#define VER_E_OPCODE EMAKEHR(0x1803)
+#define VER_E_OPERAND EMAKEHR(0x1804)
+#define VER_E_TOKEN EMAKEHR(0x1805)
+#define VER_E_EXCEPT EMAKEHR(0x1806)
+#define VER_E_STACK_SLOT EMAKEHR(0x1807)
+#define VER_E_LOC EMAKEHR(0x1808)
+#define VER_E_ARG EMAKEHR(0x1809)
+#define VER_E_FOUND EMAKEHR(0x180a)
+#define VER_E_EXPECTED EMAKEHR(0x180b)
+#define VER_E_LOC_BYNAME EMAKEHR(0x180c)
+#define VER_E_UNKNOWN_OPCODE EMAKEHR(0x1810)
+#define VER_E_SIG_CALLCONV EMAKEHR(0x1811)
+#define VER_E_SIG_ELEMTYPE EMAKEHR(0x1812)
+#define VER_E_RET_SIG EMAKEHR(0x1814)
+#define VER_E_FIELD_SIG EMAKEHR(0x1815)
+#define VER_E_OPEN_DLGT_PROT_ACC EMAKEHR(0x1816)
+#define VER_E_INTERNAL EMAKEHR(0x1818)
+#define VER_E_STACK_TOO_LARGE EMAKEHR(0x1819)
+#define VER_E_ARRAY_NAME_LONG EMAKEHR(0x181a)
+#define VER_E_FALLTHRU EMAKEHR(0x1820)
+#define VER_E_TRY_GTEQ_END EMAKEHR(0x1821)
+#define VER_E_TRYEND_GT_CS EMAKEHR(0x1822)
+#define VER_E_HND_GTEQ_END EMAKEHR(0x1823)
+#define VER_E_HNDEND_GT_CS EMAKEHR(0x1824)
+#define VER_E_FLT_GTEQ_CS EMAKEHR(0x1825)
+#define VER_E_TRY_START EMAKEHR(0x1826)
+#define VER_E_HND_START EMAKEHR(0x1827)
+#define VER_E_FLT_START EMAKEHR(0x1828)
+#define VER_E_TRY_OVERLAP EMAKEHR(0x1829)
+#define VER_E_TRY_EQ_HND_FIL EMAKEHR(0x182a)
+#define VER_E_TRY_SHARE_FIN_FAL EMAKEHR(0x182b)
+#define VER_E_HND_OVERLAP EMAKEHR(0x182c)
+#define VER_E_HND_EQ EMAKEHR(0x182d)
+#define VER_E_FIL_OVERLAP EMAKEHR(0x182e)
+#define VER_E_FIL_EQ EMAKEHR(0x182f)
+#define VER_E_FIL_CONT_TRY EMAKEHR(0x1830)
+#define VER_E_FIL_CONT_HND EMAKEHR(0x1831)
+#define VER_E_FIL_CONT_FIL EMAKEHR(0x1832)
+#define VER_E_FIL_GTEQ_CS EMAKEHR(0x1833)
+#define VER_E_FIL_START EMAKEHR(0x1834)
+#define VER_E_FALLTHRU_EXCEP EMAKEHR(0x1835)
+#define VER_E_FALLTHRU_INTO_HND EMAKEHR(0x1836)
+#define VER_E_FALLTHRU_INTO_FIL EMAKEHR(0x1837)
+#define VER_E_LEAVE EMAKEHR(0x1838)
+#define VER_E_RETHROW EMAKEHR(0x1839)
+#define VER_E_ENDFINALLY EMAKEHR(0x183a)
+#define VER_E_ENDFILTER EMAKEHR(0x183b)
+#define VER_E_ENDFILTER_MISSING EMAKEHR(0x183c)
+#define VER_E_BR_INTO_TRY EMAKEHR(0x183d)
+#define VER_E_BR_INTO_HND EMAKEHR(0x183e)
+#define VER_E_BR_INTO_FIL EMAKEHR(0x183f)
+#define VER_E_BR_OUTOF_TRY EMAKEHR(0x1840)
+#define VER_E_BR_OUTOF_HND EMAKEHR(0x1841)
+#define VER_E_BR_OUTOF_FIL EMAKEHR(0x1842)
+#define VER_E_BR_OUTOF_FIN EMAKEHR(0x1843)
+#define VER_E_RET_FROM_TRY EMAKEHR(0x1844)
+#define VER_E_RET_FROM_HND EMAKEHR(0x1845)
+#define VER_E_RET_FROM_FIL EMAKEHR(0x1846)
+#define VER_E_BAD_JMP_TARGET EMAKEHR(0x1847)
+#define VER_E_PATH_LOC EMAKEHR(0x1848)
+#define VER_E_PATH_THIS EMAKEHR(0x1849)
+#define VER_E_PATH_STACK EMAKEHR(0x184a)
+#define VER_E_PATH_STACK_DEPTH EMAKEHR(0x184b)
+#define VER_E_THIS EMAKEHR(0x184c)
+#define VER_E_THIS_UNINIT_EXCEP EMAKEHR(0x184d)
+#define VER_E_THIS_UNINIT_STORE EMAKEHR(0x184e)
+#define VER_E_THIS_UNINIT_RET EMAKEHR(0x184f)
+#define VER_E_THIS_UNINIT_V_RET EMAKEHR(0x1850)
+#define VER_E_THIS_UNINIT_BR EMAKEHR(0x1851)
+#define VER_E_LDFTN_CTOR EMAKEHR(0x1852)
+#define VER_E_STACK_NOT_EQ EMAKEHR(0x1853)
+#define VER_E_STACK_UNEXPECTED EMAKEHR(0x1854)
+#define VER_E_STACK_EXCEPTION EMAKEHR(0x1855)
+#define VER_E_STACK_OVERFLOW EMAKEHR(0x1856)
+#define VER_E_STACK_UNDERFLOW EMAKEHR(0x1857)
+#define VER_E_STACK_EMPTY EMAKEHR(0x1858)
+#define VER_E_STACK_UNINIT EMAKEHR(0x1859)
+#define VER_E_STACK_I_I4_I8 EMAKEHR(0x185a)
+#define VER_E_STACK_R_R4_R8 EMAKEHR(0x185b)
+#define VER_E_STACK_NO_R_I8 EMAKEHR(0x185c)
+#define VER_E_STACK_NUMERIC EMAKEHR(0x185d)
+#define VER_E_STACK_OBJREF EMAKEHR(0x185e)
+#define VER_E_STACK_P_OBJREF EMAKEHR(0x185f)
+#define VER_E_STACK_BYREF EMAKEHR(0x1860)
+#define VER_E_STACK_METHOD EMAKEHR(0x1861)
+#define VER_E_STACK_ARRAY_SD EMAKEHR(0x1862)
+#define VER_E_STACK_VALCLASS EMAKEHR(0x1863)
+#define VER_E_STACK_P_VALCLASS EMAKEHR(0x1864)
+#define VER_E_STACK_NO_VALCLASS EMAKEHR(0x1865)
+#define VER_E_LOC_DEAD EMAKEHR(0x1866)
+#define VER_E_LOC_NUM EMAKEHR(0x1867)
+#define VER_E_ARG_NUM EMAKEHR(0x1868)
+#define VER_E_TOKEN_RESOLVE EMAKEHR(0x1869)
+#define VER_E_TOKEN_TYPE EMAKEHR(0x186a)
+#define VER_E_TOKEN_TYPE_MEMBER EMAKEHR(0x186b)
+#define VER_E_TOKEN_TYPE_FIELD EMAKEHR(0x186c)
+#define VER_E_TOKEN_TYPE_SIG EMAKEHR(0x186d)
+#define VER_E_UNVERIFIABLE EMAKEHR(0x186e)
+#define VER_E_LDSTR_OPERAND EMAKEHR(0x186f)
+#define VER_E_RET_PTR_TO_STACK EMAKEHR(0x1870)
+#define VER_E_RET_VOID EMAKEHR(0x1871)
+#define VER_E_RET_MISSING EMAKEHR(0x1872)
+#define VER_E_RET_EMPTY EMAKEHR(0x1873)
+#define VER_E_RET_UNINIT EMAKEHR(0x1874)
+#define VER_E_ARRAY_ACCESS EMAKEHR(0x1875)
+#define VER_E_ARRAY_V_STORE EMAKEHR(0x1876)
+#define VER_E_ARRAY_SD EMAKEHR(0x1877)
+#define VER_E_ARRAY_SD_PTR EMAKEHR(0x1878)
+#define VER_E_ARRAY_FIELD EMAKEHR(0x1879)
+#define VER_E_ARGLIST EMAKEHR(0x187a)
+#define VER_E_VALCLASS EMAKEHR(0x187b)
+#define VER_E_METHOD_ACCESS EMAKEHR(0x187c)
+#define VER_E_FIELD_ACCESS EMAKEHR(0x187d)
+#define VER_E_DEAD EMAKEHR(0x187e)
+#define VER_E_FIELD_STATIC EMAKEHR(0x187f)
+#define VER_E_FIELD_NO_STATIC EMAKEHR(0x1880)
+#define VER_E_ADDR EMAKEHR(0x1881)
+#define VER_E_ADDR_BYREF EMAKEHR(0x1882)
+#define VER_E_ADDR_LITERAL EMAKEHR(0x1883)
+#define VER_E_INITONLY EMAKEHR(0x1884)
+#define VER_E_THROW EMAKEHR(0x1885)
+#define VER_E_CALLVIRT_VALCLASS EMAKEHR(0x1886)
+#define VER_E_CALL_SIG EMAKEHR(0x1887)
+#define VER_E_CALL_STATIC EMAKEHR(0x1888)
+#define VER_E_CTOR EMAKEHR(0x1889)
+#define VER_E_CTOR_VIRT EMAKEHR(0x188a)
+#define VER_E_CTOR_OR_SUPER EMAKEHR(0x188b)
+#define VER_E_CTOR_MUL_INIT EMAKEHR(0x188c)
+#define VER_E_SIG EMAKEHR(0x188d)
+#define VER_E_SIG_ARRAY EMAKEHR(0x188e)
+#define VER_E_SIG_ARRAY_PTR EMAKEHR(0x188f)
+#define VER_E_SIG_ARRAY_BYREF EMAKEHR(0x1890)
+#define VER_E_SIG_ELEM_PTR EMAKEHR(0x1891)
+#define VER_E_SIG_VARARG EMAKEHR(0x1892)
+#define VER_E_SIG_VOID EMAKEHR(0x1893)
+#define VER_E_SIG_BYREF_BYREF EMAKEHR(0x1894)
+#define VER_E_CODE_SIZE_ZERO EMAKEHR(0x1896)
+#define VER_E_BAD_VARARG EMAKEHR(0x1897)
+#define VER_E_TAIL_CALL EMAKEHR(0x1898)
+#define VER_E_TAIL_BYREF EMAKEHR(0x1899)
+#define VER_E_TAIL_RET EMAKEHR(0x189a)
+#define VER_E_TAIL_RET_VOID EMAKEHR(0x189b)
+#define VER_E_TAIL_RET_TYPE EMAKEHR(0x189c)
+#define VER_E_TAIL_STACK_EMPTY EMAKEHR(0x189d)
+#define VER_E_METHOD_END EMAKEHR(0x189e)
+#define VER_E_BAD_BRANCH EMAKEHR(0x189f)
+#define VER_E_FIN_OVERLAP EMAKEHR(0x18a0)
+#define VER_E_LEXICAL_NESTING EMAKEHR(0x18a1)
+#define VER_E_VOLATILE EMAKEHR(0x18a2)
+#define VER_E_UNALIGNED EMAKEHR(0x18a3)
+#define VER_E_INNERMOST_FIRST EMAKEHR(0x18a4)
+#define VER_E_CALLI_VIRTUAL EMAKEHR(0x18a5)
+#define VER_E_CALL_ABSTRACT EMAKEHR(0x18a6)
+#define VER_E_STACK_UNEXP_ARRAY EMAKEHR(0x18a7)
+#define VER_E_NOT_IN_GC_HEAP EMAKEHR(0x18a8)
+#define VER_E_TRY_N_EMPTY_STACK EMAKEHR(0x18a9)
+#define VER_E_DLGT_CTOR EMAKEHR(0x18aa)
+#define VER_E_DLGT_BB EMAKEHR(0x18ab)
+#define VER_E_DLGT_PATTERN EMAKEHR(0x18ac)
+#define VER_E_DLGT_LDFTN EMAKEHR(0x18ad)
+#define VER_E_FTN_ABSTRACT EMAKEHR(0x18ae)
+#define VER_E_SIG_C_VC EMAKEHR(0x18af)
+#define VER_E_SIG_VC_C EMAKEHR(0x18b0)
+#define VER_E_BOX_PTR_TO_STACK EMAKEHR(0x18b1)
+#define VER_E_SIG_BYREF_TB_AH EMAKEHR(0x18b2)
+#define VER_E_SIG_ARRAY_TB_AH EMAKEHR(0x18b3)
+#define VER_E_ENDFILTER_STACK EMAKEHR(0x18b4)
+#define VER_E_DLGT_SIG_I EMAKEHR(0x18b5)
+#define VER_E_DLGT_SIG_O EMAKEHR(0x18b6)
+#define VER_E_RA_PTR_TO_STACK EMAKEHR(0x18b7)
+#define VER_E_CATCH_VALUE_TYPE EMAKEHR(0x18b8)
+#define VER_E_CATCH_BYREF EMAKEHR(0x18b9)
+#define VER_E_FIL_PRECEED_HND EMAKEHR(0x18ba)
+#define VER_E_LDVIRTFTN_STATIC EMAKEHR(0x18bb)
+#define VER_E_CALLVIRT_STATIC EMAKEHR(0x18bc)
+#define VER_E_INITLOCALS EMAKEHR(0x18bd)
+#define VER_E_BR_TO_EXCEPTION EMAKEHR(0x18be)
+#define VER_E_CALL_CTOR EMAKEHR(0x18bf)
+#define VER_E_VALCLASS_OBJREF_VAR EMAKEHR(0x18c0)
+#define VER_E_STACK_P_VALCLASS_OBJREF_VAR EMAKEHR(0x18c1)
+#define VER_E_SIG_VAR_PARAM EMAKEHR(0x18c2)
+#define VER_E_SIG_MVAR_PARAM EMAKEHR(0x18c3)
+#define VER_E_SIG_VAR_ARG EMAKEHR(0x18c4)
+#define VER_E_SIG_MVAR_ARG EMAKEHR(0x18c5)
+#define VER_E_SIG_GENERICINST EMAKEHR(0x18c6)
+#define VER_E_SIG_METHOD_INST EMAKEHR(0x18c7)
+#define VER_E_SIG_METHOD_PARENT_INST EMAKEHR(0x18c8)
+#define VER_E_SIG_FIELD_PARENT_INST EMAKEHR(0x18c9)
+#define VER_E_CALLCONV_NOT_GENERICINST EMAKEHR(0x18ca)
+#define VER_E_TOKEN_BAD_METHOD_SPEC EMAKEHR(0x18cb)
+#define VER_E_BAD_READONLY_PREFIX EMAKEHR(0x18cc)
+#define VER_E_BAD_CONSTRAINED_PREFIX EMAKEHR(0x18cd)
+#define VER_E_CIRCULAR_VAR_CONSTRAINTS EMAKEHR(0x18ce)
+#define VER_E_CIRCULAR_MVAR_CONSTRAINTS EMAKEHR(0x18cf)
+#define VER_E_UNSATISFIED_METHOD_INST EMAKEHR(0x18d0)
+#define VER_E_UNSATISFIED_METHOD_PARENT_INST EMAKEHR(0x18d1)
+#define VER_E_UNSATISFIED_FIELD_PARENT_INST EMAKEHR(0x18d2)
+#define VER_E_UNSATISFIED_BOX_OPERAND EMAKEHR(0x18d3)
+#define VER_E_CONSTRAINED_CALL_WITH_NON_BYREF_THIS EMAKEHR(0x18d4)
+#define VER_E_CONSTRAINED_OF_NON_VARIABLE_TYPE EMAKEHR(0x18d5)
+#define VER_E_READONLY_UNEXPECTED_CALLEE EMAKEHR(0x18d6)
+#define VER_E_READONLY_ILLEGAL_WRITE EMAKEHR(0x18d7)
+#define VER_E_READONLY_IN_MKREFANY EMAKEHR(0x18d8)
+#define VER_E_UNALIGNED_ALIGNMENT EMAKEHR(0x18d9)
+#define VER_E_TAILCALL_INSIDE_EH EMAKEHR(0x18da)
+#define VER_E_BACKWARD_BRANCH EMAKEHR(0x18db)
+#define VER_E_CALL_TO_VTYPE_BASE EMAKEHR(0x18dc)
+#define VER_E_NEWOBJ_OF_ABSTRACT_CLASS EMAKEHR(0x18dd)
+#define VER_E_UNMANAGED_POINTER EMAKEHR(0x18de)
+#define VER_E_LDFTN_NON_FINAL_VIRTUAL EMAKEHR(0x18df)
+#define VER_E_FIELD_OVERLAP EMAKEHR(0x18e0)
+#define VER_E_THIS_MISMATCH EMAKEHR(0x18e1)
+#define VER_E_STACK_I_I4 EMAKEHR(0x18e2)
+#define VER_E_BAD_PE EMAKEHR(0x18f0)
+#define VER_E_BAD_MD EMAKEHR(0x18f1)
+#define VER_E_BAD_APPDOMAIN EMAKEHR(0x18f2)
+#define VER_E_TYPELOAD EMAKEHR(0x18f3)
+#define VER_E_PE_LOAD EMAKEHR(0x18f4)
+#define VER_E_WRITE_RVA_STATIC EMAKEHR(0x18f5)
+#define VER_E_INITIALIZE_ARRAY_MISSING_TOKEN EMAKEHR(0x18f6)
 
 #endif    /* __WINE_CORERROR_H */
diff --git a/include/dxgi.idl b/include/dxgi.idl
index bb12283..bc9538e 100644
--- a/include/dxgi.idl
+++ b/include/dxgi.idl
@@ -446,6 +446,18 @@ interface IDXGIAdapter1 : IDXGIAdapter
 
 [
     object,
+    uuid(77db970f-6276-48ba-ba28-070143b4392c),
+    local,
+    pointer_default(unique)
+]
+interface IDXGIDevice1 : IDXGIDevice
+{
+    HRESULT SetMaximumFrameLatency([in] UINT MaxLatency);
+    HRESULT GetMaximumFrameLatency([out] UINT *pMaxLatency);
+}
+
+[
+    object,
     uuid(770aae78-f26f-4dba-a829-253c83d1b387),
     local,
     pointer_default(unique)
diff --git a/include/dxgi1_2.idl b/include/dxgi1_2.idl
new file mode 100644
index 0000000..27dc34c
--- /dev/null
+++ b/include/dxgi1_2.idl
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2014 Jacek Caban for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+import "dxgi.idl";
+
+typedef enum _DXGI_OFFER_RESOURCE_PRIORITY {
+    DXGI_OFFER_RESOURCE_PRIORITY_LOW = 1,
+    DXGI_OFFER_RESOURCE_PRIORITY_NORMAL,
+    DXGI_OFFER_RESOURCE_PRIORITY_HIGH
+} DXGI_OFFER_RESOURCE_PRIORITY;
+
+[
+    object,
+    uuid(05008617-fbfd-4051-a790-144884b4f6a9),
+    local,
+    pointer_default(unique)
+]
+interface IDXGIDevice2 : IDXGIDevice1
+{
+    HRESULT OfferResources(
+            [in] UINT NumResources,
+            [in, size_is(NumResources)] IDXGIResource *const *ppResources,
+            [in] DXGI_OFFER_RESOURCE_PRIORITY Priority);
+
+    HRESULT ReclaimResources(
+            [in] UINT NumResources,
+            [in, size_is(NumResources)] IDXGIResource *const *ppResources,
+            [out, size_is(NumResources)] BOOL *pDiscarded);
+
+    HRESULT EnqueueSetEvent(
+            [in] HANDLE hEvent);
+}
diff --git a/include/netcfgx.idl b/include/netcfgx.idl
index 75c0a94..d51407f 100644
--- a/include/netcfgx.idl
+++ b/include/netcfgx.idl
@@ -26,6 +26,9 @@ import "wtypes.idl";
 #define vi_progid(str)
 #endif
 
+cpp_quote("#define NETCFG_E_ALREADY_INITIALIZED  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xA020)")
+cpp_quote("#define NETCFG_E_NO_WRITE_LOCK        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xA024)")
+
 [
     local,
     object,
@@ -91,6 +94,20 @@ interface IEnumNetCfgComponent : IUnknown
 [
     local,
     object,
+    uuid(c0e8ae9f-306e-11d1-aacf-00805fc1270e),
+    pointer_default(unique)
+]
+interface INetCfgLock : IUnknown
+{
+    HRESULT AcquireWriteLock ([in] DWORD cmsTimeout, [in]  LPCWSTR pszwClientDescription,
+                              [out] LPWSTR* ppszwClientDescription);
+    HRESULT ReleaseWriteLock ();
+    HRESULT IsWriteLocked ([out] LPWSTR* ppszwClientDescription);
+};
+
+[
+    local,
+    object,
     uuid(c0e8ae93-306e-11d1-aacf-00805fc1270e),
     pointer_default(unique)
 ]
diff --git a/include/rpcndr.h b/include/rpcndr.h
index 99200ac..f795566 100644
--- a/include/rpcndr.h
+++ b/include/rpcndr.h
@@ -429,7 +429,7 @@ typedef struct _MIDL_STUBLESS_PROXY_INFO
 } MIDL_STUBLESS_PROXY_INFO, *PMIDL_STUBLESS_PROXY_INFO;
 
 
-#if defined(__i386__) && !defined(__MSC_VER) && !defined(__MINGW32__) && !defined(__CYGWIN__)
+#if defined(__i386__) && !defined(_MSC_VER) && !defined(__MINGW32__) && !defined(__CYGWIN__)
 /* Calling convention for returning structures/unions is different between Windows and gcc on i386 */
 typedef LONG_PTR CLIENT_CALL_RETURN;
 #else
diff --git a/include/winbase.h b/include/winbase.h
index 6cc0a24..29ff218 100644
--- a/include/winbase.h
+++ b/include/winbase.h
@@ -1512,6 +1512,23 @@ typedef PRTL_RUN_ONCE LPINIT_ONCE;
 /* initialization callback prototype */
 typedef BOOL (WINAPI *PINIT_ONCE_FN)(PINIT_ONCE,PVOID,PVOID*);
 
+typedef struct _REASON_CONTEXT
+{
+    ULONG Version;
+    DWORD Flags;
+    union
+    {
+        struct
+        {
+            HMODULE LocalizedReasonModule;
+            ULONG LocalizedReasonId;
+            ULONG ReasonStringCount;
+            LPWSTR *ReasonStrings;
+        } Detailed;
+        LPWSTR SimpleReasonString;
+    } Reason;
+} REASON_CONTEXT, *PREASON_CONTEXT;
+
 WINBASEAPI BOOL        WINAPI ActivateActCtx(HANDLE,ULONG_PTR *);
 WINADVAPI  BOOL        WINAPI AddAccessAllowedAce(PACL,DWORD,DWORD,PSID);
 WINADVAPI  BOOL        WINAPI AddAccessAllowedAceEx(PACL,DWORD,DWORD,DWORD,PSID);
@@ -2363,6 +2380,7 @@ WINBASEAPI BOOL        WINAPI SetVolumeMountPointA(LPCSTR,LPCSTR);
 WINBASEAPI BOOL        WINAPI SetVolumeMountPointW(LPCSTR,LPCSTR);
 #define                       SetVolumeMountPoint WINELIB_NAME_AW(SetVolumeMountPoint)
 WINBASEAPI BOOL        WINAPI SetWaitableTimer(HANDLE,const LARGE_INTEGER*,LONG,PTIMERAPCROUTINE,LPVOID,BOOL);
+WINBASEAPI BOOL        WINAPI SetWaitableTimerEx(HANDLE,const LARGE_INTEGER*,LONG,PTIMERAPCROUTINE,LPVOID,REASON_CONTEXT*,ULONG);
 WINBASEAPI BOOL        WINAPI SetupComm(HANDLE,DWORD,DWORD);
 WINBASEAPI DWORD       WINAPI SignalObjectAndWait(HANDLE,HANDLE,DWORD,BOOL);
 WINBASEAPI DWORD       WINAPI SizeofResource(HMODULE,HRSRC);
diff --git a/include/wine/wined3d.h b/include/wine/wined3d.h
index e6fa2d1..33bf9ae 100644
--- a/include/wine/wined3d.h
+++ b/include/wine/wined3d.h
@@ -2340,15 +2340,12 @@ static inline HRESULT wined3d_private_store_set_private_data(struct wined3d_priv
     return WINED3D_OK;
 }
 
-HRESULT __cdecl wined3d_resource_free_private_data(struct wined3d_resource *resource, REFGUID guid);
 void __cdecl wined3d_resource_get_desc(const struct wined3d_resource *resource,
         struct wined3d_resource_desc *desc);
 void * __cdecl wined3d_resource_get_parent(const struct wined3d_resource *resource);
-HRESULT __cdecl wined3d_resource_get_private_data(const struct wined3d_resource *resource,
-        REFGUID guid, void *data, DWORD *data_size);
 void __cdecl wined3d_resource_set_parent(struct wined3d_resource *resource, void *parent);
-HRESULT __cdecl wined3d_resource_set_private_data(struct wined3d_resource *resource,
-        REFGUID guid, const void *data, DWORD data_size, DWORD flags);
+void __cdecl wined3d_resource_get_pitch(const struct wined3d_resource *resource, UINT *row_pitch,
+        UINT *slice_pitch);
 
 HRESULT __cdecl wined3d_rendertarget_view_create(struct wined3d_resource *resource,
         void *parent, struct wined3d_rendertarget_view **rendertarget_view);
@@ -2396,7 +2393,6 @@ HRESULT __cdecl wined3d_surface_get_flip_status(const struct wined3d_surface *su
 HRESULT __cdecl wined3d_surface_get_overlay_position(const struct wined3d_surface *surface, LONG *x, LONG *y);
 struct wined3d_palette * __cdecl wined3d_surface_get_palette(const struct wined3d_surface *surface);
 void * __cdecl wined3d_surface_get_parent(const struct wined3d_surface *surface);
-DWORD __cdecl wined3d_surface_get_pitch(const struct wined3d_surface *surface);
 DWORD __cdecl wined3d_surface_get_priority(const struct wined3d_surface *surface);
 HRESULT __cdecl wined3d_surface_get_render_target_data(struct wined3d_surface *surface,
         struct wined3d_surface *render_target);
diff --git a/include/winnt.h b/include/winnt.h
index f785d33..93fd70a 100644
--- a/include/winnt.h
+++ b/include/winnt.h
@@ -154,7 +154,7 @@ extern "C" {
 # define DECLSPEC_EXPORT
 #endif
 
-#if defined(__MSC_VER) || defined(__MINGW32__) || defined(__CYGWIN__)
+#if defined(_MSC_VER) || defined(__MINGW32__) || defined(__CYGWIN__)
 # define DECLSPEC_HIDDEN
 #elif defined(__GNUC__) && ((__GNUC__ > 3) || ((__GNUC__ == 3) && (__GNUC_MINOR__ >= 3)))
 # define DECLSPEC_HIDDEN __attribute__((visibility ("hidden")))
diff --git a/loader/wine.inf.in b/loader/wine.inf.in
index d6e6994..1f08d2e 100644
--- a/loader/wine.inf.in
+++ b/loader/wine.inf.in
@@ -2546,6 +2546,9 @@ HKLM,%CurrentVersion%\Telephony\Country List\998,"SameAreaRule",,"G"
 11,wbem,wbemprox.dll
 11,wbem,wmic.exe
 11,wbem,wmiutils.dll
+; empty folders to make sure the parent dirs are not removed
+16410,Microsoft,
+16412,Microsoft,
 16422,Internet Explorer,iexplore.exe
 16427,System\OLE DB,oledb32.dll
 16427,System\OLE DB,msdaps.dll
diff --git a/po/ar.po b/po/ar.po
index ae04b20..1d498a7 100644
--- a/po/ar.po
+++ b/po/ar.po
@@ -11628,6 +11628,76 @@ msgstr "إضافة قيمة جديدة متعددة السلاسل"
 msgid "Exports selected branch of the registry to a text file"
 msgstr "تصدير الفرع المختار من السجل إلى ملف نصي"
 
+#: regsvr32.rc:32
+msgid ""
+"Wine DLL Registration Server\n"
+"\n"
+"Provides DLL registration services.\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:40
+msgid ""
+"Usage:\n"
+"  regsvr32 [/u] [/s] [/n] [/i[:cmdline]] DllName\n"
+"\n"
+"Options:\n"
+"  [/u]  Unregister a module from the server.\n"
+"  [/s]  Silent mode (no messages will be displayed).\n"
+"  [/i]  Call DllInstall, passing an optional [cmdline].\n"
+"\tWhen used with [/u], regsvr32 also calls DLL Uninstall.\n"
+"  [/n]  Do not call DllRegisterServer. This option must be used with [/i].\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:41
+msgid ""
+"regsvr32: Invalid or unrecognized switch [%1]\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:42
+#, fuzzy
+#| msgid "Failed to open '%1'\n"
+msgid "regsvr32: Failed to load DLL '%1'\n"
+msgstr "فشل فتح '%1'\n"
+
+#: regsvr32.rc:43
+msgid "regsvr32: %1 not implemented in DLL '%2'\n"
+msgstr ""
+
+#: regsvr32.rc:44
+msgid "regsvr32: Failed to register DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:45
+msgid "regsvr32: Successfully registered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:46
+msgid "regsvr32: Failed to unregister DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:47
+msgid "regsvr32: Successfully unregistered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:48
+msgid "regsvr32: Failed to install DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:49
+msgid "regsvr32: Successfully installed DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:50
+msgid "regsvr32: Failed to uninstall DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:51
+msgid "regsvr32: Successfully uninstalled DLL '%1'\n"
+msgstr ""
+
 #: start.rc:55
 msgid ""
 "Application could not be started, or no application associated with the "
diff --git a/po/bg.po b/po/bg.po
index 275713f..4812c42 100644
--- a/po/bg.po
+++ b/po/bg.po
@@ -11500,6 +11500,74 @@ msgstr ""
 "Записва цялото или част от съдържанието на системния регистър във текстов "
 "файл"
 
+#: regsvr32.rc:32
+msgid ""
+"Wine DLL Registration Server\n"
+"\n"
+"Provides DLL registration services.\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:40
+msgid ""
+"Usage:\n"
+"  regsvr32 [/u] [/s] [/n] [/i[:cmdline]] DllName\n"
+"\n"
+"Options:\n"
+"  [/u]  Unregister a module from the server.\n"
+"  [/s]  Silent mode (no messages will be displayed).\n"
+"  [/i]  Call DllInstall, passing an optional [cmdline].\n"
+"\tWhen used with [/u], regsvr32 also calls DLL Uninstall.\n"
+"  [/n]  Do not call DllRegisterServer. This option must be used with [/i].\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:41
+msgid ""
+"regsvr32: Invalid or unrecognized switch [%1]\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:42
+msgid "regsvr32: Failed to load DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:43
+msgid "regsvr32: %1 not implemented in DLL '%2'\n"
+msgstr ""
+
+#: regsvr32.rc:44
+msgid "regsvr32: Failed to register DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:45
+msgid "regsvr32: Successfully registered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:46
+msgid "regsvr32: Failed to unregister DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:47
+msgid "regsvr32: Successfully unregistered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:48
+msgid "regsvr32: Failed to install DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:49
+msgid "regsvr32: Successfully installed DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:50
+msgid "regsvr32: Failed to uninstall DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:51
+msgid "regsvr32: Successfully uninstalled DLL '%1'\n"
+msgstr ""
+
 #: start.rc:55
 msgid ""
 "Application could not be started, or no application associated with the "
diff --git a/po/ca.po b/po/ca.po
index 5c940a0..65b537f 100644
--- a/po/ca.po
+++ b/po/ca.po
@@ -11856,6 +11856,76 @@ msgstr "Afegeix un valor de cadena múltiple nou"
 msgid "Exports selected branch of the registry to a text file"
 msgstr "Exporta la branca del registre seleccionada a un fitxer de text"
 
+#: regsvr32.rc:32
+msgid ""
+"Wine DLL Registration Server\n"
+"\n"
+"Provides DLL registration services.\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:40
+msgid ""
+"Usage:\n"
+"  regsvr32 [/u] [/s] [/n] [/i[:cmdline]] DllName\n"
+"\n"
+"Options:\n"
+"  [/u]  Unregister a module from the server.\n"
+"  [/s]  Silent mode (no messages will be displayed).\n"
+"  [/i]  Call DllInstall, passing an optional [cmdline].\n"
+"\tWhen used with [/u], regsvr32 also calls DLL Uninstall.\n"
+"  [/n]  Do not call DllRegisterServer. This option must be used with [/i].\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:41
+msgid ""
+"regsvr32: Invalid or unrecognized switch [%1]\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:42
+#, fuzzy
+#| msgid "Failed to open '%1'\n"
+msgid "regsvr32: Failed to load DLL '%1'\n"
+msgstr "S'ha fallat en obrir '%1'\n"
+
+#: regsvr32.rc:43
+msgid "regsvr32: %1 not implemented in DLL '%2'\n"
+msgstr ""
+
+#: regsvr32.rc:44
+msgid "regsvr32: Failed to register DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:45
+msgid "regsvr32: Successfully registered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:46
+msgid "regsvr32: Failed to unregister DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:47
+msgid "regsvr32: Successfully unregistered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:48
+msgid "regsvr32: Failed to install DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:49
+msgid "regsvr32: Successfully installed DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:50
+msgid "regsvr32: Failed to uninstall DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:51
+msgid "regsvr32: Successfully uninstalled DLL '%1'\n"
+msgstr ""
+
 #: start.rc:55
 msgid ""
 "Application could not be started, or no application associated with the "
diff --git a/po/cs.po b/po/cs.po
index f3fda6e..ac7bfd5 100644
--- a/po/cs.po
+++ b/po/cs.po
@@ -11509,6 +11509,76 @@ msgstr "Přidá novou více-řetězcovou položku"
 msgid "Exports selected branch of the registry to a text file"
 msgstr "Exportuje vybranou větev registru do textového souboru"
 
+#: regsvr32.rc:32
+msgid ""
+"Wine DLL Registration Server\n"
+"\n"
+"Provides DLL registration services.\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:40
+msgid ""
+"Usage:\n"
+"  regsvr32 [/u] [/s] [/n] [/i[:cmdline]] DllName\n"
+"\n"
+"Options:\n"
+"  [/u]  Unregister a module from the server.\n"
+"  [/s]  Silent mode (no messages will be displayed).\n"
+"  [/i]  Call DllInstall, passing an optional [cmdline].\n"
+"\tWhen used with [/u], regsvr32 also calls DLL Uninstall.\n"
+"  [/n]  Do not call DllRegisterServer. This option must be used with [/i].\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:41
+msgid ""
+"regsvr32: Invalid or unrecognized switch [%1]\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:42
+#, fuzzy
+#| msgid "Failed to open '%1'\n"
+msgid "regsvr32: Failed to load DLL '%1'\n"
+msgstr "Otevření „%1“ se nezdařilo\n"
+
+#: regsvr32.rc:43
+msgid "regsvr32: %1 not implemented in DLL '%2'\n"
+msgstr ""
+
+#: regsvr32.rc:44
+msgid "regsvr32: Failed to register DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:45
+msgid "regsvr32: Successfully registered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:46
+msgid "regsvr32: Failed to unregister DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:47
+msgid "regsvr32: Successfully unregistered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:48
+msgid "regsvr32: Failed to install DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:49
+msgid "regsvr32: Successfully installed DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:50
+msgid "regsvr32: Failed to uninstall DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:51
+msgid "regsvr32: Successfully uninstalled DLL '%1'\n"
+msgstr ""
+
 #: start.rc:55
 msgid ""
 "Application could not be started, or no application associated with the "
diff --git a/po/da.po b/po/da.po
index 10603a8..eba1ef7 100644
--- a/po/da.po
+++ b/po/da.po
@@ -11765,6 +11765,76 @@ msgstr "Tilføj en ny flerstrenget værdi"
 msgid "Exports selected branch of the registry to a text file"
 msgstr "Eksporter udvalgte gren af registreringsdatabasen til en tekst fil"
 
+#: regsvr32.rc:32
+msgid ""
+"Wine DLL Registration Server\n"
+"\n"
+"Provides DLL registration services.\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:40
+msgid ""
+"Usage:\n"
+"  regsvr32 [/u] [/s] [/n] [/i[:cmdline]] DllName\n"
+"\n"
+"Options:\n"
+"  [/u]  Unregister a module from the server.\n"
+"  [/s]  Silent mode (no messages will be displayed).\n"
+"  [/i]  Call DllInstall, passing an optional [cmdline].\n"
+"\tWhen used with [/u], regsvr32 also calls DLL Uninstall.\n"
+"  [/n]  Do not call DllRegisterServer. This option must be used with [/i].\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:41
+msgid ""
+"regsvr32: Invalid or unrecognized switch [%1]\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:42
+#, fuzzy
+#| msgid "Failed to open '%1'\n"
+msgid "regsvr32: Failed to load DLL '%1'\n"
+msgstr "Kunne ikke åbne «%1»\n"
+
+#: regsvr32.rc:43
+msgid "regsvr32: %1 not implemented in DLL '%2'\n"
+msgstr ""
+
+#: regsvr32.rc:44
+msgid "regsvr32: Failed to register DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:45
+msgid "regsvr32: Successfully registered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:46
+msgid "regsvr32: Failed to unregister DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:47
+msgid "regsvr32: Successfully unregistered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:48
+msgid "regsvr32: Failed to install DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:49
+msgid "regsvr32: Successfully installed DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:50
+msgid "regsvr32: Failed to uninstall DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:51
+msgid "regsvr32: Successfully uninstalled DLL '%1'\n"
+msgstr ""
+
 #: start.rc:55
 msgid ""
 "Application could not be started, or no application associated with the "
diff --git a/po/de.po b/po/de.po
index f6b062a..35a2455 100644
--- a/po/de.po
+++ b/po/de.po
@@ -11745,6 +11745,76 @@ msgstr "Fügt eine neue mehrteilige Zeichenfolge hinzu"
 msgid "Exports selected branch of the registry to a text file"
 msgstr "Exportiert den ausgewählten Zweig der Registry in eine Textdatei"
 
+#: regsvr32.rc:32
+msgid ""
+"Wine DLL Registration Server\n"
+"\n"
+"Provides DLL registration services.\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:40
+msgid ""
+"Usage:\n"
+"  regsvr32 [/u] [/s] [/n] [/i[:cmdline]] DllName\n"
+"\n"
+"Options:\n"
+"  [/u]  Unregister a module from the server.\n"
+"  [/s]  Silent mode (no messages will be displayed).\n"
+"  [/i]  Call DllInstall, passing an optional [cmdline].\n"
+"\tWhen used with [/u], regsvr32 also calls DLL Uninstall.\n"
+"  [/n]  Do not call DllRegisterServer. This option must be used with [/i].\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:41
+msgid ""
+"regsvr32: Invalid or unrecognized switch [%1]\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:42
+#, fuzzy
+#| msgid "Failed to open '%1'\n"
+msgid "regsvr32: Failed to load DLL '%1'\n"
+msgstr "'%1' konnte nicht geöffnet werden\n"
+
+#: regsvr32.rc:43
+msgid "regsvr32: %1 not implemented in DLL '%2'\n"
+msgstr ""
+
+#: regsvr32.rc:44
+msgid "regsvr32: Failed to register DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:45
+msgid "regsvr32: Successfully registered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:46
+msgid "regsvr32: Failed to unregister DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:47
+msgid "regsvr32: Successfully unregistered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:48
+msgid "regsvr32: Failed to install DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:49
+msgid "regsvr32: Successfully installed DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:50
+msgid "regsvr32: Failed to uninstall DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:51
+msgid "regsvr32: Successfully uninstalled DLL '%1'\n"
+msgstr ""
+
 #: start.rc:55
 msgid ""
 "Application could not be started, or no application associated with the "
diff --git a/po/el.po b/po/el.po
index 7ad9167..c4fc576 100644
--- a/po/el.po
+++ b/po/el.po
@@ -11297,6 +11297,74 @@ msgstr ""
 msgid "Exports selected branch of the registry to a text file"
 msgstr ""
 
+#: regsvr32.rc:32
+msgid ""
+"Wine DLL Registration Server\n"
+"\n"
+"Provides DLL registration services.\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:40
+msgid ""
+"Usage:\n"
+"  regsvr32 [/u] [/s] [/n] [/i[:cmdline]] DllName\n"
+"\n"
+"Options:\n"
+"  [/u]  Unregister a module from the server.\n"
+"  [/s]  Silent mode (no messages will be displayed).\n"
+"  [/i]  Call DllInstall, passing an optional [cmdline].\n"
+"\tWhen used with [/u], regsvr32 also calls DLL Uninstall.\n"
+"  [/n]  Do not call DllRegisterServer. This option must be used with [/i].\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:41
+msgid ""
+"regsvr32: Invalid or unrecognized switch [%1]\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:42
+msgid "regsvr32: Failed to load DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:43
+msgid "regsvr32: %1 not implemented in DLL '%2'\n"
+msgstr ""
+
+#: regsvr32.rc:44
+msgid "regsvr32: Failed to register DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:45
+msgid "regsvr32: Successfully registered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:46
+msgid "regsvr32: Failed to unregister DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:47
+msgid "regsvr32: Successfully unregistered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:48
+msgid "regsvr32: Failed to install DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:49
+msgid "regsvr32: Successfully installed DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:50
+msgid "regsvr32: Failed to uninstall DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:51
+msgid "regsvr32: Successfully uninstalled DLL '%1'\n"
+msgstr ""
+
 #: start.rc:55
 msgid ""
 "Application could not be started, or no application associated with the "
diff --git a/po/en.po b/po/en.po
index 3c33f74..fc8288a 100644
--- a/po/en.po
+++ b/po/en.po
@@ -11667,6 +11667,90 @@ msgstr "Adds a new multi-string value"
 msgid "Exports selected branch of the registry to a text file"
 msgstr "Exports selected branch of the registry to a text file"
 
+#: regsvr32.rc:32
+msgid ""
+"Wine DLL Registration Server\n"
+"\n"
+"Provides DLL registration services.\n"
+"\n"
+msgstr ""
+"Wine DLL Registration Server\n"
+"\n"
+"Provides DLL registration services.\n"
+"\n"
+
+#: regsvr32.rc:40
+msgid ""
+"Usage:\n"
+"  regsvr32 [/u] [/s] [/n] [/i[:cmdline]] DllName\n"
+"\n"
+"Options:\n"
+"  [/u]  Unregister a module from the server.\n"
+"  [/s]  Silent mode (no messages will be displayed).\n"
+"  [/i]  Call DllInstall, passing an optional [cmdline].\n"
+"\tWhen used with [/u], regsvr32 also calls DLL Uninstall.\n"
+"  [/n]  Do not call DllRegisterServer. This option must be used with [/i].\n"
+"\n"
+msgstr ""
+"Usage:\n"
+"  regsvr32 [/u] [/s] [/n] [/i[:cmdline]] DllName\n"
+"\n"
+"Options:\n"
+"  [/u]  Unregister a module from the server.\n"
+"  [/s]  Silent mode (no messages will be displayed).\n"
+"  [/i]  Call DllInstall, passing an optional [cmdline].\n"
+"\tWhen used with [/u], regsvr32 also calls DLL Uninstall.\n"
+"  [/n]  Do not call DllRegisterServer. This option must be used with [/i].\n"
+"\n"
+
+#: regsvr32.rc:41
+msgid ""
+"regsvr32: Invalid or unrecognized switch [%1]\n"
+"\n"
+msgstr ""
+"regsvr32: Invalid or unrecognized switch [%1]\n"
+"\n"
+
+#: regsvr32.rc:42
+msgid "regsvr32: Failed to load DLL '%1'\n"
+msgstr "regsvr32: Failed to load DLL '%1'\n"
+
+#: regsvr32.rc:43
+msgid "regsvr32: %1 not implemented in DLL '%2'\n"
+msgstr "regsvr32: %1 not implemented in DLL '%2'\n"
+
+#: regsvr32.rc:44
+msgid "regsvr32: Failed to register DLL '%1'\n"
+msgstr "regsvr32: Failed to register DLL '%1'\n"
+
+#: regsvr32.rc:45
+msgid "regsvr32: Successfully registered DLL '%1'\n"
+msgstr "regsvr32: Successfully registered DLL '%1'\n"
+
+#: regsvr32.rc:46
+msgid "regsvr32: Failed to unregister DLL '%1'\n"
+msgstr "regsvr32: Failed to unregister DLL '%1'\n"
+
+#: regsvr32.rc:47
+msgid "regsvr32: Successfully unregistered DLL '%1'\n"
+msgstr "regsvr32: Successfully unregistered DLL '%1'\n"
+
+#: regsvr32.rc:48
+msgid "regsvr32: Failed to install DLL '%1'\n"
+msgstr "regsvr32: Failed to install DLL '%1'\n"
+
+#: regsvr32.rc:49
+msgid "regsvr32: Successfully installed DLL '%1'\n"
+msgstr "regsvr32: Successfully installed DLL '%1'\n"
+
+#: regsvr32.rc:50
+msgid "regsvr32: Failed to uninstall DLL '%1'\n"
+msgstr "regsvr32: Failed to uninstall DLL '%1'\n"
+
+#: regsvr32.rc:51
+msgid "regsvr32: Successfully uninstalled DLL '%1'\n"
+msgstr "regsvr32: Successfully uninstalled DLL '%1'\n"
+
 #: start.rc:55
 msgid ""
 "Application could not be started, or no application associated with the "
diff --git a/po/en_US.po b/po/en_US.po
index 802b8d5..2450e46 100644
--- a/po/en_US.po
+++ b/po/en_US.po
@@ -11667,6 +11667,90 @@ msgstr "Adds a new multi-string value"
 msgid "Exports selected branch of the registry to a text file"
 msgstr "Exports selected branch of the registry to a text file"
 
+#: regsvr32.rc:32
+msgid ""
+"Wine DLL Registration Server\n"
+"\n"
+"Provides DLL registration services.\n"
+"\n"
+msgstr ""
+"Wine DLL Registration Server\n"
+"\n"
+"Provides DLL registration services.\n"
+"\n"
+
+#: regsvr32.rc:40
+msgid ""
+"Usage:\n"
+"  regsvr32 [/u] [/s] [/n] [/i[:cmdline]] DllName\n"
+"\n"
+"Options:\n"
+"  [/u]  Unregister a module from the server.\n"
+"  [/s]  Silent mode (no messages will be displayed).\n"
+"  [/i]  Call DllInstall, passing an optional [cmdline].\n"
+"\tWhen used with [/u], regsvr32 also calls DLL Uninstall.\n"
+"  [/n]  Do not call DllRegisterServer. This option must be used with [/i].\n"
+"\n"
+msgstr ""
+"Usage:\n"
+"  regsvr32 [/u] [/s] [/n] [/i[:cmdline]] DllName\n"
+"\n"
+"Options:\n"
+"  [/u]  Unregister a module from the server.\n"
+"  [/s]  Silent mode (no messages will be displayed).\n"
+"  [/i]  Call DllInstall, passing an optional [cmdline].\n"
+"\tWhen used with [/u], regsvr32 also calls DLL Uninstall.\n"
+"  [/n]  Do not call DllRegisterServer. This option must be used with [/i].\n"
+"\n"
+
+#: regsvr32.rc:41
+msgid ""
+"regsvr32: Invalid or unrecognized switch [%1]\n"
+"\n"
+msgstr ""
+"regsvr32: Invalid or unrecognized switch [%1]\n"
+"\n"
+
+#: regsvr32.rc:42
+msgid "regsvr32: Failed to load DLL '%1'\n"
+msgstr "regsvr32: Failed to load DLL '%1'\n"
+
+#: regsvr32.rc:43
+msgid "regsvr32: %1 not implemented in DLL '%2'\n"
+msgstr "regsvr32: %1 not implemented in DLL '%2'\n"
+
+#: regsvr32.rc:44
+msgid "regsvr32: Failed to register DLL '%1'\n"
+msgstr "regsvr32: Failed to register DLL '%1'\n"
+
+#: regsvr32.rc:45
+msgid "regsvr32: Successfully registered DLL '%1'\n"
+msgstr "regsvr32: Successfully registered DLL '%1'\n"
+
+#: regsvr32.rc:46
+msgid "regsvr32: Failed to unregister DLL '%1'\n"
+msgstr "regsvr32: Failed to unregister DLL '%1'\n"
+
+#: regsvr32.rc:47
+msgid "regsvr32: Successfully unregistered DLL '%1'\n"
+msgstr "regsvr32: Successfully unregistered DLL '%1'\n"
+
+#: regsvr32.rc:48
+msgid "regsvr32: Failed to install DLL '%1'\n"
+msgstr "regsvr32: Failed to install DLL '%1'\n"
+
+#: regsvr32.rc:49
+msgid "regsvr32: Successfully installed DLL '%1'\n"
+msgstr "regsvr32: Successfully installed DLL '%1'\n"
+
+#: regsvr32.rc:50
+msgid "regsvr32: Failed to uninstall DLL '%1'\n"
+msgstr "regsvr32: Failed to uninstall DLL '%1'\n"
+
+#: regsvr32.rc:51
+msgid "regsvr32: Successfully uninstalled DLL '%1'\n"
+msgstr "regsvr32: Successfully uninstalled DLL '%1'\n"
+
 #: start.rc:55
 msgid ""
 "Application could not be started, or no application associated with the "
diff --git a/po/eo.po b/po/eo.po
index 2a2e491..d7028a4 100644
--- a/po/eo.po
+++ b/po/eo.po
@@ -11163,6 +11163,74 @@ msgstr "Aldonis novan ĉenan valoron"
 msgid "Exports selected branch of the registry to a text file"
 msgstr "Eksportas elektitan branĉon de la registrejo al tekstodosiero"
 
+#: regsvr32.rc:32
+msgid ""
+"Wine DLL Registration Server\n"
+"\n"
+"Provides DLL registration services.\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:40
+msgid ""
+"Usage:\n"
+"  regsvr32 [/u] [/s] [/n] [/i[:cmdline]] DllName\n"
+"\n"
+"Options:\n"
+"  [/u]  Unregister a module from the server.\n"
+"  [/s]  Silent mode (no messages will be displayed).\n"
+"  [/i]  Call DllInstall, passing an optional [cmdline].\n"
+"\tWhen used with [/u], regsvr32 also calls DLL Uninstall.\n"
+"  [/n]  Do not call DllRegisterServer. This option must be used with [/i].\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:41
+msgid ""
+"regsvr32: Invalid or unrecognized switch [%1]\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:42
+msgid "regsvr32: Failed to load DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:43
+msgid "regsvr32: %1 not implemented in DLL '%2'\n"
+msgstr ""
+
+#: regsvr32.rc:44
+msgid "regsvr32: Failed to register DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:45
+msgid "regsvr32: Successfully registered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:46
+msgid "regsvr32: Failed to unregister DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:47
+msgid "regsvr32: Successfully unregistered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:48
+msgid "regsvr32: Failed to install DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:49
+msgid "regsvr32: Successfully installed DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:50
+msgid "regsvr32: Failed to uninstall DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:51
+msgid "regsvr32: Successfully uninstalled DLL '%1'\n"
+msgstr ""
+
 #: start.rc:55
 msgid ""
 "Application could not be started, or no application associated with the "
diff --git a/po/es.po b/po/es.po
index 3a041fd..c041feb 100644
--- a/po/es.po
+++ b/po/es.po
@@ -11852,6 +11852,76 @@ msgstr "Añade un nuevo valor de cadena múltiple"
 msgid "Exports selected branch of the registry to a text file"
 msgstr "Exporta la rama seleccionada del registro a un archivo de texto"
 
+#: regsvr32.rc:32
+msgid ""
+"Wine DLL Registration Server\n"
+"\n"
+"Provides DLL registration services.\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:40
+msgid ""
+"Usage:\n"
+"  regsvr32 [/u] [/s] [/n] [/i[:cmdline]] DllName\n"
+"\n"
+"Options:\n"
+"  [/u]  Unregister a module from the server.\n"
+"  [/s]  Silent mode (no messages will be displayed).\n"
+"  [/i]  Call DllInstall, passing an optional [cmdline].\n"
+"\tWhen used with [/u], regsvr32 also calls DLL Uninstall.\n"
+"  [/n]  Do not call DllRegisterServer. This option must be used with [/i].\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:41
+msgid ""
+"regsvr32: Invalid or unrecognized switch [%1]\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:42
+#, fuzzy
+#| msgid "Failed to open '%1'\n"
+msgid "regsvr32: Failed to load DLL '%1'\n"
+msgstr "No se pudo abrir '%1'\n"
+
+#: regsvr32.rc:43
+msgid "regsvr32: %1 not implemented in DLL '%2'\n"
+msgstr ""
+
+#: regsvr32.rc:44
+msgid "regsvr32: Failed to register DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:45
+msgid "regsvr32: Successfully registered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:46
+msgid "regsvr32: Failed to unregister DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:47
+msgid "regsvr32: Successfully unregistered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:48
+msgid "regsvr32: Failed to install DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:49
+msgid "regsvr32: Successfully installed DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:50
+msgid "regsvr32: Failed to uninstall DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:51
+msgid "regsvr32: Successfully uninstalled DLL '%1'\n"
+msgstr ""
+
 #: start.rc:55
 msgid ""
 "Application could not be started, or no application associated with the "
diff --git a/po/fa.po b/po/fa.po
index 39f166c..a96125d 100644
--- a/po/fa.po
+++ b/po/fa.po
@@ -11304,6 +11304,74 @@ msgstr ""
 msgid "Exports selected branch of the registry to a text file"
 msgstr ""
 
+#: regsvr32.rc:32
+msgid ""
+"Wine DLL Registration Server\n"
+"\n"
+"Provides DLL registration services.\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:40
+msgid ""
+"Usage:\n"
+"  regsvr32 [/u] [/s] [/n] [/i[:cmdline]] DllName\n"
+"\n"
+"Options:\n"
+"  [/u]  Unregister a module from the server.\n"
+"  [/s]  Silent mode (no messages will be displayed).\n"
+"  [/i]  Call DllInstall, passing an optional [cmdline].\n"
+"\tWhen used with [/u], regsvr32 also calls DLL Uninstall.\n"
+"  [/n]  Do not call DllRegisterServer. This option must be used with [/i].\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:41
+msgid ""
+"regsvr32: Invalid or unrecognized switch [%1]\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:42
+msgid "regsvr32: Failed to load DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:43
+msgid "regsvr32: %1 not implemented in DLL '%2'\n"
+msgstr ""
+
+#: regsvr32.rc:44
+msgid "regsvr32: Failed to register DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:45
+msgid "regsvr32: Successfully registered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:46
+msgid "regsvr32: Failed to unregister DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:47
+msgid "regsvr32: Successfully unregistered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:48
+msgid "regsvr32: Failed to install DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:49
+msgid "regsvr32: Successfully installed DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:50
+msgid "regsvr32: Failed to uninstall DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:51
+msgid "regsvr32: Successfully uninstalled DLL '%1'\n"
+msgstr ""
+
 #: start.rc:55
 msgid ""
 "Application could not be started, or no application associated with the "
diff --git a/po/fi.po b/po/fi.po
index cc3e358..4822d7d 100644
--- a/po/fi.po
+++ b/po/fi.po
@@ -11647,6 +11647,76 @@ msgstr "Lisää uuden monen merkkijonon arvon"
 msgid "Exports selected branch of the registry to a text file"
 msgstr "Vie rekisterin valitun haaran tekstitiedostoon"
 
+#: regsvr32.rc:32
+msgid ""
+"Wine DLL Registration Server\n"
+"\n"
+"Provides DLL registration services.\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:40
+msgid ""
+"Usage:\n"
+"  regsvr32 [/u] [/s] [/n] [/i[:cmdline]] DllName\n"
+"\n"
+"Options:\n"
+"  [/u]  Unregister a module from the server.\n"
+"  [/s]  Silent mode (no messages will be displayed).\n"
+"  [/i]  Call DllInstall, passing an optional [cmdline].\n"
+"\tWhen used with [/u], regsvr32 also calls DLL Uninstall.\n"
+"  [/n]  Do not call DllRegisterServer. This option must be used with [/i].\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:41
+msgid ""
+"regsvr32: Invalid or unrecognized switch [%1]\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:42
+#, fuzzy
+#| msgid "Failed to open '%1'\n"
+msgid "regsvr32: Failed to load DLL '%1'\n"
+msgstr "'%1' ei auennut\n"
+
+#: regsvr32.rc:43
+msgid "regsvr32: %1 not implemented in DLL '%2'\n"
+msgstr ""
+
+#: regsvr32.rc:44
+msgid "regsvr32: Failed to register DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:45
+msgid "regsvr32: Successfully registered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:46
+msgid "regsvr32: Failed to unregister DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:47
+msgid "regsvr32: Successfully unregistered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:48
+msgid "regsvr32: Failed to install DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:49
+msgid "regsvr32: Successfully installed DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:50
+msgid "regsvr32: Failed to uninstall DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:51
+msgid "regsvr32: Successfully uninstalled DLL '%1'\n"
+msgstr ""
+
 #: start.rc:55
 msgid ""
 "Application could not be started, or no application associated with the "
diff --git a/po/fr.po b/po/fr.po
index fda23df..14604a4 100644
--- a/po/fr.po
+++ b/po/fr.po
@@ -11803,6 +11803,76 @@ msgstr "Ajoute une nouvelle valeur chaîne extensible"
 msgid "Exports selected branch of the registry to a text file"
 msgstr "Exporte la branche du registre sélectionnée dans un fichier texte"
 
+#: regsvr32.rc:32
+msgid ""
+"Wine DLL Registration Server\n"
+"\n"
+"Provides DLL registration services.\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:40
+msgid ""
+"Usage:\n"
+"  regsvr32 [/u] [/s] [/n] [/i[:cmdline]] DllName\n"
+"\n"
+"Options:\n"
+"  [/u]  Unregister a module from the server.\n"
+"  [/s]  Silent mode (no messages will be displayed).\n"
+"  [/i]  Call DllInstall, passing an optional [cmdline].\n"
+"\tWhen used with [/u], regsvr32 also calls DLL Uninstall.\n"
+"  [/n]  Do not call DllRegisterServer. This option must be used with [/i].\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:41
+msgid ""
+"regsvr32: Invalid or unrecognized switch [%1]\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:42
+#, fuzzy
+#| msgid "Failed to open '%1'\n"
+msgid "regsvr32: Failed to load DLL '%1'\n"
+msgstr "Impossible d'ouvrir « %1 »\n"
+
+#: regsvr32.rc:43
+msgid "regsvr32: %1 not implemented in DLL '%2'\n"
+msgstr ""
+
+#: regsvr32.rc:44
+msgid "regsvr32: Failed to register DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:45
+msgid "regsvr32: Successfully registered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:46
+msgid "regsvr32: Failed to unregister DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:47
+msgid "regsvr32: Successfully unregistered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:48
+msgid "regsvr32: Failed to install DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:49
+msgid "regsvr32: Successfully installed DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:50
+msgid "regsvr32: Failed to uninstall DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:51
+msgid "regsvr32: Successfully uninstalled DLL '%1'\n"
+msgstr ""
+
 #: start.rc:55
 msgid ""
 "Application could not be started, or no application associated with the "
diff --git a/po/he.po b/po/he.po
index a06a401..1a71bf0 100644
--- a/po/he.po
+++ b/po/he.po
@@ -11840,6 +11840,76 @@ msgstr "הוספת ערך מרובה מחרוזות חדש"
 msgid "Exports selected branch of the registry to a text file"
 msgstr "יצוא הענף הנבחר מרישום המערכת לקובץ טקסט"
 
+#: regsvr32.rc:32
+msgid ""
+"Wine DLL Registration Server\n"
+"\n"
+"Provides DLL registration services.\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:40
+msgid ""
+"Usage:\n"
+"  regsvr32 [/u] [/s] [/n] [/i[:cmdline]] DllName\n"
+"\n"
+"Options:\n"
+"  [/u]  Unregister a module from the server.\n"
+"  [/s]  Silent mode (no messages will be displayed).\n"
+"  [/i]  Call DllInstall, passing an optional [cmdline].\n"
+"\tWhen used with [/u], regsvr32 also calls DLL Uninstall.\n"
+"  [/n]  Do not call DllRegisterServer. This option must be used with [/i].\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:41
+msgid ""
+"regsvr32: Invalid or unrecognized switch [%1]\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:42
+#, fuzzy
+#| msgid "Failed to open '%1'\n"
+msgid "regsvr32: Failed to load DLL '%1'\n"
+msgstr "Failed to open '%1'\n"
+
+#: regsvr32.rc:43
+msgid "regsvr32: %1 not implemented in DLL '%2'\n"
+msgstr ""
+
+#: regsvr32.rc:44
+msgid "regsvr32: Failed to register DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:45
+msgid "regsvr32: Successfully registered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:46
+msgid "regsvr32: Failed to unregister DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:47
+msgid "regsvr32: Successfully unregistered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:48
+msgid "regsvr32: Failed to install DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:49
+msgid "regsvr32: Successfully installed DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:50
+msgid "regsvr32: Failed to uninstall DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:51
+msgid "regsvr32: Successfully uninstalled DLL '%1'\n"
+msgstr ""
+
 #: start.rc:55
 msgid ""
 "Application could not be started, or no application associated with the "
diff --git a/po/hi.po b/po/hi.po
index 5fe9ccb..1b54d05 100644
--- a/po/hi.po
+++ b/po/hi.po
@@ -11118,6 +11118,74 @@ msgstr ""
 msgid "Exports selected branch of the registry to a text file"
 msgstr ""
 
+#: regsvr32.rc:32
+msgid ""
+"Wine DLL Registration Server\n"
+"\n"
+"Provides DLL registration services.\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:40
+msgid ""
+"Usage:\n"
+"  regsvr32 [/u] [/s] [/n] [/i[:cmdline]] DllName\n"
+"\n"
+"Options:\n"
+"  [/u]  Unregister a module from the server.\n"
+"  [/s]  Silent mode (no messages will be displayed).\n"
+"  [/i]  Call DllInstall, passing an optional [cmdline].\n"
+"\tWhen used with [/u], regsvr32 also calls DLL Uninstall.\n"
+"  [/n]  Do not call DllRegisterServer. This option must be used with [/i].\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:41
+msgid ""
+"regsvr32: Invalid or unrecognized switch [%1]\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:42
+msgid "regsvr32: Failed to load DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:43
+msgid "regsvr32: %1 not implemented in DLL '%2'\n"
+msgstr ""
+
+#: regsvr32.rc:44
+msgid "regsvr32: Failed to register DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:45
+msgid "regsvr32: Successfully registered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:46
+msgid "regsvr32: Failed to unregister DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:47
+msgid "regsvr32: Successfully unregistered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:48
+msgid "regsvr32: Failed to install DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:49
+msgid "regsvr32: Successfully installed DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:50
+msgid "regsvr32: Failed to uninstall DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:51
+msgid "regsvr32: Successfully uninstalled DLL '%1'\n"
+msgstr ""
+
 #: start.rc:55
 msgid ""
 "Application could not be started, or no application associated with the "
diff --git a/po/hr.po b/po/hr.po
index c172431..4f8538a 100644
--- a/po/hr.po
+++ b/po/hr.po
@@ -11327,6 +11327,76 @@ msgstr ""
 msgid "Exports selected branch of the registry to a text file"
 msgstr ""
 
+#: regsvr32.rc:32
+msgid ""
+"Wine DLL Registration Server\n"
+"\n"
+"Provides DLL registration services.\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:40
+msgid ""
+"Usage:\n"
+"  regsvr32 [/u] [/s] [/n] [/i[:cmdline]] DllName\n"
+"\n"
+"Options:\n"
+"  [/u]  Unregister a module from the server.\n"
+"  [/s]  Silent mode (no messages will be displayed).\n"
+"  [/i]  Call DllInstall, passing an optional [cmdline].\n"
+"\tWhen used with [/u], regsvr32 also calls DLL Uninstall.\n"
+"  [/n]  Do not call DllRegisterServer. This option must be used with [/i].\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:41
+msgid ""
+"regsvr32: Invalid or unrecognized switch [%1]\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:42
+#, fuzzy
+#| msgid "Failed to open '%1'\n"
+msgid "regsvr32: Failed to load DLL '%1'\n"
+msgstr "Neuspjelo otvaranje '%1'\n"
+
+#: regsvr32.rc:43
+msgid "regsvr32: %1 not implemented in DLL '%2'\n"
+msgstr ""
+
+#: regsvr32.rc:44
+msgid "regsvr32: Failed to register DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:45
+msgid "regsvr32: Successfully registered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:46
+msgid "regsvr32: Failed to unregister DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:47
+msgid "regsvr32: Successfully unregistered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:48
+msgid "regsvr32: Failed to install DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:49
+msgid "regsvr32: Successfully installed DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:50
+msgid "regsvr32: Failed to uninstall DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:51
+msgid "regsvr32: Successfully uninstalled DLL '%1'\n"
+msgstr ""
+
 #: start.rc:55
 msgid ""
 "Application could not be started, or no application associated with the "
diff --git a/po/hu.po b/po/hu.po
index 35ef73d..dd38d28 100644
--- a/po/hu.po
+++ b/po/hu.po
@@ -11771,6 +11771,76 @@ msgstr "Hozzáad egy új karakterláncsoros értéket"
 msgid "Exports selected branch of the registry to a text file"
 msgstr "Az egész kijelölt regisztrációs ágat kiexportálja egy szövegfájlba"
 
+#: regsvr32.rc:32
+msgid ""
+"Wine DLL Registration Server\n"
+"\n"
+"Provides DLL registration services.\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:40
+msgid ""
+"Usage:\n"
+"  regsvr32 [/u] [/s] [/n] [/i[:cmdline]] DllName\n"
+"\n"
+"Options:\n"
+"  [/u]  Unregister a module from the server.\n"
+"  [/s]  Silent mode (no messages will be displayed).\n"
+"  [/i]  Call DllInstall, passing an optional [cmdline].\n"
+"\tWhen used with [/u], regsvr32 also calls DLL Uninstall.\n"
+"  [/n]  Do not call DllRegisterServer. This option must be used with [/i].\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:41
+msgid ""
+"regsvr32: Invalid or unrecognized switch [%1]\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:42
+#, fuzzy
+#| msgid "Failed to open '%1'\n"
+msgid "regsvr32: Failed to load DLL '%1'\n"
+msgstr "'%1' megnyitása sikertelen\n"
+
+#: regsvr32.rc:43
+msgid "regsvr32: %1 not implemented in DLL '%2'\n"
+msgstr ""
+
+#: regsvr32.rc:44
+msgid "regsvr32: Failed to register DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:45
+msgid "regsvr32: Successfully registered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:46
+msgid "regsvr32: Failed to unregister DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:47
+msgid "regsvr32: Successfully unregistered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:48
+msgid "regsvr32: Failed to install DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:49
+msgid "regsvr32: Successfully installed DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:50
+msgid "regsvr32: Failed to uninstall DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:51
+msgid "regsvr32: Successfully uninstalled DLL '%1'\n"
+msgstr ""
+
 #: start.rc:55
 msgid ""
 "Application could not be started, or no application associated with the "
diff --git a/po/it.po b/po/it.po
index ce6e2e2..a9f6075 100644
--- a/po/it.po
+++ b/po/it.po
@@ -11852,6 +11852,76 @@ msgstr "Aggiunge un nuovo valore multi stringa"
 msgid "Exports selected branch of the registry to a text file"
 msgstr "Esporta il ramo selezionato del registro in un file di testo"
 
+#: regsvr32.rc:32
+msgid ""
+"Wine DLL Registration Server\n"
+"\n"
+"Provides DLL registration services.\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:40
+msgid ""
+"Usage:\n"
+"  regsvr32 [/u] [/s] [/n] [/i[:cmdline]] DllName\n"
+"\n"
+"Options:\n"
+"  [/u]  Unregister a module from the server.\n"
+"  [/s]  Silent mode (no messages will be displayed).\n"
+"  [/i]  Call DllInstall, passing an optional [cmdline].\n"
+"\tWhen used with [/u], regsvr32 also calls DLL Uninstall.\n"
+"  [/n]  Do not call DllRegisterServer. This option must be used with [/i].\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:41
+msgid ""
+"regsvr32: Invalid or unrecognized switch [%1]\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:42
+#, fuzzy
+#| msgid "Failed to open '%1'\n"
+msgid "regsvr32: Failed to load DLL '%1'\n"
+msgstr "Impossibile aprire '%1'\n"
+
+#: regsvr32.rc:43
+msgid "regsvr32: %1 not implemented in DLL '%2'\n"
+msgstr ""
+
+#: regsvr32.rc:44
+msgid "regsvr32: Failed to register DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:45
+msgid "regsvr32: Successfully registered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:46
+msgid "regsvr32: Failed to unregister DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:47
+msgid "regsvr32: Successfully unregistered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:48
+msgid "regsvr32: Failed to install DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:49
+msgid "regsvr32: Successfully installed DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:50
+msgid "regsvr32: Failed to uninstall DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:51
+msgid "regsvr32: Successfully uninstalled DLL '%1'\n"
+msgstr ""
+
 #: start.rc:55
 msgid ""
 "Application could not be started, or no application associated with the "
diff --git a/po/ja.po b/po/ja.po
index 2ed30b8..2595f5c 100644
--- a/po/ja.po
+++ b/po/ja.po
@@ -11661,6 +11661,76 @@ msgstr "新しい複数文字列値を追加"
 msgid "Exports selected branch of the registry to a text file"
 msgstr "選択したレジストリ キー以下をテキスト ファイルに出力"
 
+#: regsvr32.rc:32
+msgid ""
+"Wine DLL Registration Server\n"
+"\n"
+"Provides DLL registration services.\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:40
+msgid ""
+"Usage:\n"
+"  regsvr32 [/u] [/s] [/n] [/i[:cmdline]] DllName\n"
+"\n"
+"Options:\n"
+"  [/u]  Unregister a module from the server.\n"
+"  [/s]  Silent mode (no messages will be displayed).\n"
+"  [/i]  Call DllInstall, passing an optional [cmdline].\n"
+"\tWhen used with [/u], regsvr32 also calls DLL Uninstall.\n"
+"  [/n]  Do not call DllRegisterServer. This option must be used with [/i].\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:41
+msgid ""
+"regsvr32: Invalid or unrecognized switch [%1]\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:42
+#, fuzzy
+#| msgid "Failed to open '%1'\n"
+msgid "regsvr32: Failed to load DLL '%1'\n"
+msgstr "'%1' を開けません\n"
+
+#: regsvr32.rc:43
+msgid "regsvr32: %1 not implemented in DLL '%2'\n"
+msgstr ""
+
+#: regsvr32.rc:44
+msgid "regsvr32: Failed to register DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:45
+msgid "regsvr32: Successfully registered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:46
+msgid "regsvr32: Failed to unregister DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:47
+msgid "regsvr32: Successfully unregistered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:48
+msgid "regsvr32: Failed to install DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:49
+msgid "regsvr32: Successfully installed DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:50
+msgid "regsvr32: Failed to uninstall DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:51
+msgid "regsvr32: Successfully uninstalled DLL '%1'\n"
+msgstr ""
+
 #: start.rc:55
 msgid ""
 "Application could not be started, or no application associated with the "
diff --git a/po/ko.po b/po/ko.po
index 94fc4df..3df59b2 100644
--- a/po/ko.po
+++ b/po/ko.po
@@ -11652,6 +11652,76 @@ msgstr "새 다중 문자열 값 더하기"
 msgid "Exports selected branch of the registry to a text file"
 msgstr "레지스트리의 선택된 부분을 텍스트 파일로 내보내기"
 
+#: regsvr32.rc:32
+msgid ""
+"Wine DLL Registration Server\n"
+"\n"
+"Provides DLL registration services.\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:40
+msgid ""
+"Usage:\n"
+"  regsvr32 [/u] [/s] [/n] [/i[:cmdline]] DllName\n"
+"\n"
+"Options:\n"
+"  [/u]  Unregister a module from the server.\n"
+"  [/s]  Silent mode (no messages will be displayed).\n"
+"  [/i]  Call DllInstall, passing an optional [cmdline].\n"
+"\tWhen used with [/u], regsvr32 also calls DLL Uninstall.\n"
+"  [/n]  Do not call DllRegisterServer. This option must be used with [/i].\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:41
+msgid ""
+"regsvr32: Invalid or unrecognized switch [%1]\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:42
+#, fuzzy
+#| msgid "Failed to open '%1'\n"
+msgid "regsvr32: Failed to load DLL '%1'\n"
+msgstr "'%1' 열기 실패\n"
+
+#: regsvr32.rc:43
+msgid "regsvr32: %1 not implemented in DLL '%2'\n"
+msgstr ""
+
+#: regsvr32.rc:44
+msgid "regsvr32: Failed to register DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:45
+msgid "regsvr32: Successfully registered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:46
+msgid "regsvr32: Failed to unregister DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:47
+msgid "regsvr32: Successfully unregistered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:48
+msgid "regsvr32: Failed to install DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:49
+msgid "regsvr32: Successfully installed DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:50
+msgid "regsvr32: Failed to uninstall DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:51
+msgid "regsvr32: Successfully uninstalled DLL '%1'\n"
+msgstr ""
+
 #: start.rc:55
 msgid ""
 "Application could not be started, or no application associated with the "
diff --git a/po/lt.po b/po/lt.po
index efc5cc0..f573e7e 100644
--- a/po/lt.po
+++ b/po/lt.po
@@ -5,7 +5,7 @@ msgstr ""
 "Project-Id-Version: Wine\n"
 "Report-Msgid-Bugs-To: http://bugs.winehq.org\n"
 "POT-Creation-Date: N/A\n"
-"PO-Revision-Date: 2014-02-10 22:51+0300\n"
+"PO-Revision-Date: 2014-03-26 22:34+0300\n"
 "Last-Translator: Aurimas Fišeras <aurimas@members.fsf.org>\n"
 "Language-Team: komp_lt@konf.lt\n"
 "Language: Lithuanian\n"
@@ -11673,6 +11673,90 @@ msgstr "Prideda naują kelių eilučių reikšmę"
 msgid "Exports selected branch of the registry to a text file"
 msgstr "Eksportuoja pasirinktą registro šaką į tekstinį failą"
 
+#: regsvr32.rc:32
+msgid ""
+"Wine DLL Registration Server\n"
+"\n"
+"Provides DLL registration services.\n"
+"\n"
+msgstr ""
+"Wine DLL bibliotekų registravimo serveris\n"
+"\n"
+"Teikia DLL bibliotekų registravimo paslaugą.\n"
+"\n"
+
+#: regsvr32.rc:40
+msgid ""
+"Usage:\n"
+"  regsvr32 [/u] [/s] [/n] [/i[:cmdline]] DllName\n"
+"\n"
+"Options:\n"
+"  [/u]  Unregister a module from the server.\n"
+"  [/s]  Silent mode (no messages will be displayed).\n"
+"  [/i]  Call DllInstall, passing an optional [cmdline].\n"
+"\tWhen used with [/u], regsvr32 also calls DLL Uninstall.\n"
+"  [/n]  Do not call DllRegisterServer. This option must be used with [/i].\n"
+"\n"
+msgstr ""
+"Naudojimas:\n"
+"  regsvr32 [/u] [/s] [/n] [/i[:cmdeilutė]] DllVardas\n"
+"\n"
+"Parametrai:\n"
+"  [/u]  Išregistruoti modulį serveryje.\n"
+"  [/s]  Tyli veiksena (nebus rodomi pranešimai).\n"
+"  [/i]  Kviesti „DllInstall“, perduodant nebūtiną [cmdeilutę].\n"
+"\tKai naudojama su [/u], regsvr32 taip pat kviečia „DLL Uninstall“.\n"
+"  [/n]  Nekviesti „DllRegisterServer“. Privalo būti naudojamas su [/i].\n"
+"\n"
+
+#: regsvr32.rc:41
+msgid ""
+"regsvr32: Invalid or unrecognized switch [%1]\n"
+"\n"
+msgstr ""
+"regsvr32: Netinkamas arba neatpažintas parametras [%1]\n"
+"\n"
+
+#: regsvr32.rc:42
+msgid "regsvr32: Failed to load DLL '%1'\n"
+msgstr "regsvr32: Nepavyko įkelti DLL bibliotekos „%1“\n"
+
+#: regsvr32.rc:43
+msgid "regsvr32: %1 not implemented in DLL '%2'\n"
+msgstr "regsvr32: %1 neįgyvendinta DLL bibliotekoje „%2“\n"
+
+#: regsvr32.rc:44
+msgid "regsvr32: Failed to register DLL '%1'\n"
+msgstr "regsvr32: Nepavyko užregistruoti DLL bibliotekos „%1“\n"
+
+#: regsvr32.rc:45
+msgid "regsvr32: Successfully registered DLL '%1'\n"
+msgstr "regsvr32: Sėkmingai užregistruota DLL biblioteka „%1“\n"
+
+#: regsvr32.rc:46
+msgid "regsvr32: Failed to unregister DLL '%1'\n"
+msgstr "regsvr32: Nepavyko išregistruoti DLL bibliotekos „%1“\n"
+
+#: regsvr32.rc:47
+msgid "regsvr32: Successfully unregistered DLL '%1'\n"
+msgstr "regsvr32: Sėkmingai išregistruota DLL biblioteka „%1“\n"
+
+#: regsvr32.rc:48
+msgid "regsvr32: Failed to install DLL '%1'\n"
+msgstr "regsvr32: Nepavyko įdiegti DLL bibliotekos „%1“\n"
+
+#: regsvr32.rc:49
+msgid "regsvr32: Successfully installed DLL '%1'\n"
+msgstr "regsvr32: Sėkmingai įdiegta DLL biblioteka „%1“\n"
+
+#: regsvr32.rc:50
+msgid "regsvr32: Failed to uninstall DLL '%1'\n"
+msgstr "regsvr32: Nepavyko pašalinti DLL bibliotekos „%1“\n"
+
+#: regsvr32.rc:51
+msgid "regsvr32: Successfully uninstalled DLL '%1'\n"
+msgstr "regsvr32: Sėkmingai pašalinta DLL biblioteka „%1“\n"
+
 #: start.rc:55
 msgid ""
 "Application could not be started, or no application associated with the "
diff --git a/po/ml.po b/po/ml.po
index 9e2e165..ecc92e2 100644
--- a/po/ml.po
+++ b/po/ml.po
@@ -11118,6 +11118,74 @@ msgstr ""
 msgid "Exports selected branch of the registry to a text file"
 msgstr ""
 
+#: regsvr32.rc:32
+msgid ""
+"Wine DLL Registration Server\n"
+"\n"
+"Provides DLL registration services.\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:40
+msgid ""
+"Usage:\n"
+"  regsvr32 [/u] [/s] [/n] [/i[:cmdline]] DllName\n"
+"\n"
+"Options:\n"
+"  [/u]  Unregister a module from the server.\n"
+"  [/s]  Silent mode (no messages will be displayed).\n"
+"  [/i]  Call DllInstall, passing an optional [cmdline].\n"
+"\tWhen used with [/u], regsvr32 also calls DLL Uninstall.\n"
+"  [/n]  Do not call DllRegisterServer. This option must be used with [/i].\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:41
+msgid ""
+"regsvr32: Invalid or unrecognized switch [%1]\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:42
+msgid "regsvr32: Failed to load DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:43
+msgid "regsvr32: %1 not implemented in DLL '%2'\n"
+msgstr ""
+
+#: regsvr32.rc:44
+msgid "regsvr32: Failed to register DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:45
+msgid "regsvr32: Successfully registered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:46
+msgid "regsvr32: Failed to unregister DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:47
+msgid "regsvr32: Successfully unregistered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:48
+msgid "regsvr32: Failed to install DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:49
+msgid "regsvr32: Successfully installed DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:50
+msgid "regsvr32: Failed to uninstall DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:51
+msgid "regsvr32: Successfully uninstalled DLL '%1'\n"
+msgstr ""
+
 #: start.rc:55
 msgid ""
 "Application could not be started, or no application associated with the "
diff --git a/po/nb_NO.po b/po/nb_NO.po
index 4ad4d27..0cb1ba0 100644
--- a/po/nb_NO.po
+++ b/po/nb_NO.po
@@ -11670,6 +11670,76 @@ msgstr "Legger til en ny flerstrengverdi"
 msgid "Exports selected branch of the registry to a text file"
 msgstr "Eksporterer den valgte greinen av registeret til en tekstfil"
 
+#: regsvr32.rc:32
+msgid ""
+"Wine DLL Registration Server\n"
+"\n"
+"Provides DLL registration services.\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:40
+msgid ""
+"Usage:\n"
+"  regsvr32 [/u] [/s] [/n] [/i[:cmdline]] DllName\n"
+"\n"
+"Options:\n"
+"  [/u]  Unregister a module from the server.\n"
+"  [/s]  Silent mode (no messages will be displayed).\n"
+"  [/i]  Call DllInstall, passing an optional [cmdline].\n"
+"\tWhen used with [/u], regsvr32 also calls DLL Uninstall.\n"
+"  [/n]  Do not call DllRegisterServer. This option must be used with [/i].\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:41
+msgid ""
+"regsvr32: Invalid or unrecognized switch [%1]\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:42
+#, fuzzy
+#| msgid "Failed to open '%1'\n"
+msgid "regsvr32: Failed to load DLL '%1'\n"
+msgstr "Klarte ikke åpne «%1»\n"
+
+#: regsvr32.rc:43
+msgid "regsvr32: %1 not implemented in DLL '%2'\n"
+msgstr ""
+
+#: regsvr32.rc:44
+msgid "regsvr32: Failed to register DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:45
+msgid "regsvr32: Successfully registered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:46
+msgid "regsvr32: Failed to unregister DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:47
+msgid "regsvr32: Successfully unregistered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:48
+msgid "regsvr32: Failed to install DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:49
+msgid "regsvr32: Successfully installed DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:50
+msgid "regsvr32: Failed to uninstall DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:51
+msgid "regsvr32: Successfully uninstalled DLL '%1'\n"
+msgstr ""
+
 #: start.rc:55
 msgid ""
 "Application could not be started, or no application associated with the "
diff --git a/po/nl.po b/po/nl.po
index 081e5e8..f10520f 100644
--- a/po/nl.po
+++ b/po/nl.po
@@ -11818,6 +11818,76 @@ msgstr ""
 "Exporteert de geselecteerde subsleutel van het register naar een tekst "
 "bestand"
 
+#: regsvr32.rc:32
+msgid ""
+"Wine DLL Registration Server\n"
+"\n"
+"Provides DLL registration services.\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:40
+msgid ""
+"Usage:\n"
+"  regsvr32 [/u] [/s] [/n] [/i[:cmdline]] DllName\n"
+"\n"
+"Options:\n"
+"  [/u]  Unregister a module from the server.\n"
+"  [/s]  Silent mode (no messages will be displayed).\n"
+"  [/i]  Call DllInstall, passing an optional [cmdline].\n"
+"\tWhen used with [/u], regsvr32 also calls DLL Uninstall.\n"
+"  [/n]  Do not call DllRegisterServer. This option must be used with [/i].\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:41
+msgid ""
+"regsvr32: Invalid or unrecognized switch [%1]\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:42
+#, fuzzy
+#| msgid "Failed to open '%1'\n"
+msgid "regsvr32: Failed to load DLL '%1'\n"
+msgstr "Openen van '%1' is mislukt\n"
+
+#: regsvr32.rc:43
+msgid "regsvr32: %1 not implemented in DLL '%2'\n"
+msgstr ""
+
+#: regsvr32.rc:44
+msgid "regsvr32: Failed to register DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:45
+msgid "regsvr32: Successfully registered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:46
+msgid "regsvr32: Failed to unregister DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:47
+msgid "regsvr32: Successfully unregistered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:48
+msgid "regsvr32: Failed to install DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:49
+msgid "regsvr32: Successfully installed DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:50
+msgid "regsvr32: Failed to uninstall DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:51
+msgid "regsvr32: Successfully uninstalled DLL '%1'\n"
+msgstr ""
+
 #: start.rc:55
 msgid ""
 "Application could not be started, or no application associated with the "
diff --git a/po/or.po b/po/or.po
index a557ae1..7a3610d 100644
--- a/po/or.po
+++ b/po/or.po
@@ -11118,6 +11118,74 @@ msgstr ""
 msgid "Exports selected branch of the registry to a text file"
 msgstr ""
 
+#: regsvr32.rc:32
+msgid ""
+"Wine DLL Registration Server\n"
+"\n"
+"Provides DLL registration services.\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:40
+msgid ""
+"Usage:\n"
+"  regsvr32 [/u] [/s] [/n] [/i[:cmdline]] DllName\n"
+"\n"
+"Options:\n"
+"  [/u]  Unregister a module from the server.\n"
+"  [/s]  Silent mode (no messages will be displayed).\n"
+"  [/i]  Call DllInstall, passing an optional [cmdline].\n"
+"\tWhen used with [/u], regsvr32 also calls DLL Uninstall.\n"
+"  [/n]  Do not call DllRegisterServer. This option must be used with [/i].\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:41
+msgid ""
+"regsvr32: Invalid or unrecognized switch [%1]\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:42
+msgid "regsvr32: Failed to load DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:43
+msgid "regsvr32: %1 not implemented in DLL '%2'\n"
+msgstr ""
+
+#: regsvr32.rc:44
+msgid "regsvr32: Failed to register DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:45
+msgid "regsvr32: Successfully registered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:46
+msgid "regsvr32: Failed to unregister DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:47
+msgid "regsvr32: Successfully unregistered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:48
+msgid "regsvr32: Failed to install DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:49
+msgid "regsvr32: Successfully installed DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:50
+msgid "regsvr32: Failed to uninstall DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:51
+msgid "regsvr32: Successfully uninstalled DLL '%1'\n"
+msgstr ""
+
 #: start.rc:55
 msgid ""
 "Application could not be started, or no application associated with the "
diff --git a/po/pa.po b/po/pa.po
index ba1532a..fb25400 100644
--- a/po/pa.po
+++ b/po/pa.po
@@ -11118,6 +11118,74 @@ msgstr ""
 msgid "Exports selected branch of the registry to a text file"
 msgstr ""
 
+#: regsvr32.rc:32
+msgid ""
+"Wine DLL Registration Server\n"
+"\n"
+"Provides DLL registration services.\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:40
+msgid ""
+"Usage:\n"
+"  regsvr32 [/u] [/s] [/n] [/i[:cmdline]] DllName\n"
+"\n"
+"Options:\n"
+"  [/u]  Unregister a module from the server.\n"
+"  [/s]  Silent mode (no messages will be displayed).\n"
+"  [/i]  Call DllInstall, passing an optional [cmdline].\n"
+"\tWhen used with [/u], regsvr32 also calls DLL Uninstall.\n"
+"  [/n]  Do not call DllRegisterServer. This option must be used with [/i].\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:41
+msgid ""
+"regsvr32: Invalid or unrecognized switch [%1]\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:42
+msgid "regsvr32: Failed to load DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:43
+msgid "regsvr32: %1 not implemented in DLL '%2'\n"
+msgstr ""
+
+#: regsvr32.rc:44
+msgid "regsvr32: Failed to register DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:45
+msgid "regsvr32: Successfully registered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:46
+msgid "regsvr32: Failed to unregister DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:47
+msgid "regsvr32: Successfully unregistered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:48
+msgid "regsvr32: Failed to install DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:49
+msgid "regsvr32: Successfully installed DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:50
+msgid "regsvr32: Failed to uninstall DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:51
+msgid "regsvr32: Successfully uninstalled DLL '%1'\n"
+msgstr ""
+
 #: start.rc:55
 msgid ""
 "Application could not be started, or no application associated with the "
diff --git a/po/pl.po b/po/pl.po
index 2368da6..0977a51 100644
--- a/po/pl.po
+++ b/po/pl.po
@@ -11727,6 +11727,76 @@ msgstr "Dodaje nową wartość ciągu rozwijalnego"
 msgid "Exports selected branch of the registry to a text file"
 msgstr "Eksportuje zaznaczoną gałąź rejestru do pliku tekstowego"
 
+#: regsvr32.rc:32
+msgid ""
+"Wine DLL Registration Server\n"
+"\n"
+"Provides DLL registration services.\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:40
+msgid ""
+"Usage:\n"
+"  regsvr32 [/u] [/s] [/n] [/i[:cmdline]] DllName\n"
+"\n"
+"Options:\n"
+"  [/u]  Unregister a module from the server.\n"
+"  [/s]  Silent mode (no messages will be displayed).\n"
+"  [/i]  Call DllInstall, passing an optional [cmdline].\n"
+"\tWhen used with [/u], regsvr32 also calls DLL Uninstall.\n"
+"  [/n]  Do not call DllRegisterServer. This option must be used with [/i].\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:41
+msgid ""
+"regsvr32: Invalid or unrecognized switch [%1]\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:42
+#, fuzzy
+#| msgid "Failed to open '%1'\n"
+msgid "regsvr32: Failed to load DLL '%1'\n"
+msgstr "Nieudane otwarcie '%1'\n"
+
+#: regsvr32.rc:43
+msgid "regsvr32: %1 not implemented in DLL '%2'\n"
+msgstr ""
+
+#: regsvr32.rc:44
+msgid "regsvr32: Failed to register DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:45
+msgid "regsvr32: Successfully registered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:46
+msgid "regsvr32: Failed to unregister DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:47
+msgid "regsvr32: Successfully unregistered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:48
+msgid "regsvr32: Failed to install DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:49
+msgid "regsvr32: Successfully installed DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:50
+msgid "regsvr32: Failed to uninstall DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:51
+msgid "regsvr32: Successfully uninstalled DLL '%1'\n"
+msgstr ""
+
 #: start.rc:55
 msgid ""
 "Application could not be started, or no application associated with the "
diff --git a/po/pt_BR.po b/po/pt_BR.po
index cebd394..e3862b9 100644
--- a/po/pt_BR.po
+++ b/po/pt_BR.po
@@ -11730,6 +11730,76 @@ msgstr "Adiciona um novo valor de múltiplas strings"
 msgid "Exports selected branch of the registry to a text file"
 msgstr "Exporta o ramo do registro selecionado para um arquivo de texto"
 
+#: regsvr32.rc:32
+msgid ""
+"Wine DLL Registration Server\n"
+"\n"
+"Provides DLL registration services.\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:40
+msgid ""
+"Usage:\n"
+"  regsvr32 [/u] [/s] [/n] [/i[:cmdline]] DllName\n"
+"\n"
+"Options:\n"
+"  [/u]  Unregister a module from the server.\n"
+"  [/s]  Silent mode (no messages will be displayed).\n"
+"  [/i]  Call DllInstall, passing an optional [cmdline].\n"
+"\tWhen used with [/u], regsvr32 also calls DLL Uninstall.\n"
+"  [/n]  Do not call DllRegisterServer. This option must be used with [/i].\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:41
+msgid ""
+"regsvr32: Invalid or unrecognized switch [%1]\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:42
+#, fuzzy
+#| msgid "Failed to open '%1'\n"
+msgid "regsvr32: Failed to load DLL '%1'\n"
+msgstr "Falha ao abrir '%1'\n"
+
+#: regsvr32.rc:43
+msgid "regsvr32: %1 not implemented in DLL '%2'\n"
+msgstr ""
+
+#: regsvr32.rc:44
+msgid "regsvr32: Failed to register DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:45
+msgid "regsvr32: Successfully registered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:46
+msgid "regsvr32: Failed to unregister DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:47
+msgid "regsvr32: Successfully unregistered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:48
+msgid "regsvr32: Failed to install DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:49
+msgid "regsvr32: Successfully installed DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:50
+msgid "regsvr32: Failed to uninstall DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:51
+msgid "regsvr32: Successfully uninstalled DLL '%1'\n"
+msgstr ""
+
 #: start.rc:55
 msgid ""
 "Application could not be started, or no application associated with the "
diff --git a/po/pt_PT.po b/po/pt_PT.po
index a754e68..0bb9378 100644
--- a/po/pt_PT.po
+++ b/po/pt_PT.po
@@ -11737,6 +11737,76 @@ msgstr "Adiciona um novo valor multi string"
 msgid "Exports selected branch of the registry to a text file"
 msgstr "Exporta o ramo seleccionado do registo para um ficheiro de texto"
 
+#: regsvr32.rc:32
+msgid ""
+"Wine DLL Registration Server\n"
+"\n"
+"Provides DLL registration services.\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:40
+msgid ""
+"Usage:\n"
+"  regsvr32 [/u] [/s] [/n] [/i[:cmdline]] DllName\n"
+"\n"
+"Options:\n"
+"  [/u]  Unregister a module from the server.\n"
+"  [/s]  Silent mode (no messages will be displayed).\n"
+"  [/i]  Call DllInstall, passing an optional [cmdline].\n"
+"\tWhen used with [/u], regsvr32 also calls DLL Uninstall.\n"
+"  [/n]  Do not call DllRegisterServer. This option must be used with [/i].\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:41
+msgid ""
+"regsvr32: Invalid or unrecognized switch [%1]\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:42
+#, fuzzy
+#| msgid "Failed to open '%1'\n"
+msgid "regsvr32: Failed to load DLL '%1'\n"
+msgstr "Falhou ao abrir '%1'\n"
+
+#: regsvr32.rc:43
+msgid "regsvr32: %1 not implemented in DLL '%2'\n"
+msgstr ""
+
+#: regsvr32.rc:44
+msgid "regsvr32: Failed to register DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:45
+msgid "regsvr32: Successfully registered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:46
+msgid "regsvr32: Failed to unregister DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:47
+msgid "regsvr32: Successfully unregistered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:48
+msgid "regsvr32: Failed to install DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:49
+msgid "regsvr32: Successfully installed DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:50
+msgid "regsvr32: Failed to uninstall DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:51
+msgid "regsvr32: Successfully uninstalled DLL '%1'\n"
+msgstr ""
+
 #: start.rc:55
 msgid ""
 "Application could not be started, or no application associated with the "
diff --git a/po/rm.po b/po/rm.po
index e486306..3a87484 100644
--- a/po/rm.po
+++ b/po/rm.po
@@ -11200,6 +11200,74 @@ msgstr ""
 msgid "Exports selected branch of the registry to a text file"
 msgstr ""
 
+#: regsvr32.rc:32
+msgid ""
+"Wine DLL Registration Server\n"
+"\n"
+"Provides DLL registration services.\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:40
+msgid ""
+"Usage:\n"
+"  regsvr32 [/u] [/s] [/n] [/i[:cmdline]] DllName\n"
+"\n"
+"Options:\n"
+"  [/u]  Unregister a module from the server.\n"
+"  [/s]  Silent mode (no messages will be displayed).\n"
+"  [/i]  Call DllInstall, passing an optional [cmdline].\n"
+"\tWhen used with [/u], regsvr32 also calls DLL Uninstall.\n"
+"  [/n]  Do not call DllRegisterServer. This option must be used with [/i].\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:41
+msgid ""
+"regsvr32: Invalid or unrecognized switch [%1]\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:42
+msgid "regsvr32: Failed to load DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:43
+msgid "regsvr32: %1 not implemented in DLL '%2'\n"
+msgstr ""
+
+#: regsvr32.rc:44
+msgid "regsvr32: Failed to register DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:45
+msgid "regsvr32: Successfully registered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:46
+msgid "regsvr32: Failed to unregister DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:47
+msgid "regsvr32: Successfully unregistered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:48
+msgid "regsvr32: Failed to install DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:49
+msgid "regsvr32: Successfully installed DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:50
+msgid "regsvr32: Failed to uninstall DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:51
+msgid "regsvr32: Successfully uninstalled DLL '%1'\n"
+msgstr ""
+
 #: start.rc:55
 msgid ""
 "Application could not be started, or no application associated with the "
diff --git a/po/ro.po b/po/ro.po
index d721be9..6b5178b 100644
--- a/po/ro.po
+++ b/po/ro.po
@@ -11859,6 +11859,76 @@ msgstr "Adaugă o nouă valoare de șir multiplu"
 msgid "Exports selected branch of the registry to a text file"
 msgstr "Exportă ramura de registru selectată ca fișier text"
 
+#: regsvr32.rc:32
+msgid ""
+"Wine DLL Registration Server\n"
+"\n"
+"Provides DLL registration services.\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:40
+msgid ""
+"Usage:\n"
+"  regsvr32 [/u] [/s] [/n] [/i[:cmdline]] DllName\n"
+"\n"
+"Options:\n"
+"  [/u]  Unregister a module from the server.\n"
+"  [/s]  Silent mode (no messages will be displayed).\n"
+"  [/i]  Call DllInstall, passing an optional [cmdline].\n"
+"\tWhen used with [/u], regsvr32 also calls DLL Uninstall.\n"
+"  [/n]  Do not call DllRegisterServer. This option must be used with [/i].\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:41
+msgid ""
+"regsvr32: Invalid or unrecognized switch [%1]\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:42
+#, fuzzy
+#| msgid "Failed to open '%1'\n"
+msgid "regsvr32: Failed to load DLL '%1'\n"
+msgstr "Deschiderea „%1” a eșuat\n"
+
+#: regsvr32.rc:43
+msgid "regsvr32: %1 not implemented in DLL '%2'\n"
+msgstr ""
+
+#: regsvr32.rc:44
+msgid "regsvr32: Failed to register DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:45
+msgid "regsvr32: Successfully registered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:46
+msgid "regsvr32: Failed to unregister DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:47
+msgid "regsvr32: Successfully unregistered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:48
+msgid "regsvr32: Failed to install DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:49
+msgid "regsvr32: Successfully installed DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:50
+msgid "regsvr32: Failed to uninstall DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:51
+msgid "regsvr32: Successfully uninstalled DLL '%1'\n"
+msgstr ""
+
 #: start.rc:55
 msgid ""
 "Application could not be started, or no application associated with the "
diff --git a/po/ru.po b/po/ru.po
index 370b28c..47383a9 100644
--- a/po/ru.po
+++ b/po/ru.po
@@ -11673,6 +11673,76 @@ msgstr "Добавляет новое многостроковое значен
 msgid "Exports selected branch of the registry to a text file"
 msgstr "Экспортирует выделенную ветку реестра в текстовый файл"
 
+#: regsvr32.rc:32
+msgid ""
+"Wine DLL Registration Server\n"
+"\n"
+"Provides DLL registration services.\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:40
+msgid ""
+"Usage:\n"
+"  regsvr32 [/u] [/s] [/n] [/i[:cmdline]] DllName\n"
+"\n"
+"Options:\n"
+"  [/u]  Unregister a module from the server.\n"
+"  [/s]  Silent mode (no messages will be displayed).\n"
+"  [/i]  Call DllInstall, passing an optional [cmdline].\n"
+"\tWhen used with [/u], regsvr32 also calls DLL Uninstall.\n"
+"  [/n]  Do not call DllRegisterServer. This option must be used with [/i].\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:41
+msgid ""
+"regsvr32: Invalid or unrecognized switch [%1]\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:42
+#, fuzzy
+#| msgid "Failed to open '%1'\n"
+msgid "regsvr32: Failed to load DLL '%1'\n"
+msgstr "Не удалось открыть «%1»\n"
+
+#: regsvr32.rc:43
+msgid "regsvr32: %1 not implemented in DLL '%2'\n"
+msgstr ""
+
+#: regsvr32.rc:44
+msgid "regsvr32: Failed to register DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:45
+msgid "regsvr32: Successfully registered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:46
+msgid "regsvr32: Failed to unregister DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:47
+msgid "regsvr32: Successfully unregistered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:48
+msgid "regsvr32: Failed to install DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:49
+msgid "regsvr32: Successfully installed DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:50
+msgid "regsvr32: Failed to uninstall DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:51
+msgid "regsvr32: Successfully uninstalled DLL '%1'\n"
+msgstr ""
+
 #: start.rc:55
 msgid ""
 "Application could not be started, or no application associated with the "
diff --git a/po/sk.po b/po/sk.po
index 21d297e..a4c2b41 100644
--- a/po/sk.po
+++ b/po/sk.po
@@ -11316,6 +11316,74 @@ msgstr ""
 msgid "Exports selected branch of the registry to a text file"
 msgstr ""
 
+#: regsvr32.rc:32
+msgid ""
+"Wine DLL Registration Server\n"
+"\n"
+"Provides DLL registration services.\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:40
+msgid ""
+"Usage:\n"
+"  regsvr32 [/u] [/s] [/n] [/i[:cmdline]] DllName\n"
+"\n"
+"Options:\n"
+"  [/u]  Unregister a module from the server.\n"
+"  [/s]  Silent mode (no messages will be displayed).\n"
+"  [/i]  Call DllInstall, passing an optional [cmdline].\n"
+"\tWhen used with [/u], regsvr32 also calls DLL Uninstall.\n"
+"  [/n]  Do not call DllRegisterServer. This option must be used with [/i].\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:41
+msgid ""
+"regsvr32: Invalid or unrecognized switch [%1]\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:42
+msgid "regsvr32: Failed to load DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:43
+msgid "regsvr32: %1 not implemented in DLL '%2'\n"
+msgstr ""
+
+#: regsvr32.rc:44
+msgid "regsvr32: Failed to register DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:45
+msgid "regsvr32: Successfully registered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:46
+msgid "regsvr32: Failed to unregister DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:47
+msgid "regsvr32: Successfully unregistered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:48
+msgid "regsvr32: Failed to install DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:49
+msgid "regsvr32: Successfully installed DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:50
+msgid "regsvr32: Failed to uninstall DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:51
+msgid "regsvr32: Successfully uninstalled DLL '%1'\n"
+msgstr ""
+
 #: start.rc:55
 msgid ""
 "Application could not be started, or no application associated with the "
diff --git a/po/sl.po b/po/sl.po
index 6f8cb9d..3aa95d3 100644
--- a/po/sl.po
+++ b/po/sl.po
@@ -11793,6 +11793,76 @@ msgstr "Doda novo več-nizno vrednost"
 msgid "Exports selected branch of the registry to a text file"
 msgstr "Izvozi izbrano vejo registra v besedilno datoteko"
 
+#: regsvr32.rc:32
+msgid ""
+"Wine DLL Registration Server\n"
+"\n"
+"Provides DLL registration services.\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:40
+msgid ""
+"Usage:\n"
+"  regsvr32 [/u] [/s] [/n] [/i[:cmdline]] DllName\n"
+"\n"
+"Options:\n"
+"  [/u]  Unregister a module from the server.\n"
+"  [/s]  Silent mode (no messages will be displayed).\n"
+"  [/i]  Call DllInstall, passing an optional [cmdline].\n"
+"\tWhen used with [/u], regsvr32 also calls DLL Uninstall.\n"
+"  [/n]  Do not call DllRegisterServer. This option must be used with [/i].\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:41
+msgid ""
+"regsvr32: Invalid or unrecognized switch [%1]\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:42
+#, fuzzy
+#| msgid "Failed to open '%1'\n"
+msgid "regsvr32: Failed to load DLL '%1'\n"
+msgstr "Odpiranje '%1' je spodletelo\n"
+
+#: regsvr32.rc:43
+msgid "regsvr32: %1 not implemented in DLL '%2'\n"
+msgstr ""
+
+#: regsvr32.rc:44
+msgid "regsvr32: Failed to register DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:45
+msgid "regsvr32: Successfully registered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:46
+msgid "regsvr32: Failed to unregister DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:47
+msgid "regsvr32: Successfully unregistered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:48
+msgid "regsvr32: Failed to install DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:49
+msgid "regsvr32: Successfully installed DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:50
+msgid "regsvr32: Failed to uninstall DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:51
+msgid "regsvr32: Successfully uninstalled DLL '%1'\n"
+msgstr ""
+
 #: start.rc:55
 msgid ""
 "Application could not be started, or no application associated with the "
diff --git a/po/sr_RS@cyrillic.po b/po/sr_RS@cyrillic.po
index 3071705..6d3c94c 100644
--- a/po/sr_RS@cyrillic.po
+++ b/po/sr_RS@cyrillic.po
@@ -11733,6 +11733,75 @@ msgstr ""
 msgid "Exports selected branch of the registry to a text file"
 msgstr ""
 
+#: regsvr32.rc:32
+msgid ""
+"Wine DLL Registration Server\n"
+"\n"
+"Provides DLL registration services.\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:40
+msgid ""
+"Usage:\n"
+"  regsvr32 [/u] [/s] [/n] [/i[:cmdline]] DllName\n"
+"\n"
+"Options:\n"
+"  [/u]  Unregister a module from the server.\n"
+"  [/s]  Silent mode (no messages will be displayed).\n"
+"  [/i]  Call DllInstall, passing an optional [cmdline].\n"
+"\tWhen used with [/u], regsvr32 also calls DLL Uninstall.\n"
+"  [/n]  Do not call DllRegisterServer. This option must be used with [/i].\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:41
+msgid ""
+"regsvr32: Invalid or unrecognized switch [%1]\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:42
+#, fuzzy
+msgid "regsvr32: Failed to load DLL '%1'\n"
+msgstr "Отварање „%s“ датотеке није успело\n"
+
+#: regsvr32.rc:43
+msgid "regsvr32: %1 not implemented in DLL '%2'\n"
+msgstr ""
+
+#: regsvr32.rc:44
+msgid "regsvr32: Failed to register DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:45
+msgid "regsvr32: Successfully registered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:46
+msgid "regsvr32: Failed to unregister DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:47
+msgid "regsvr32: Successfully unregistered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:48
+msgid "regsvr32: Failed to install DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:49
+msgid "regsvr32: Successfully installed DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:50
+msgid "regsvr32: Failed to uninstall DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:51
+msgid "regsvr32: Successfully uninstalled DLL '%1'\n"
+msgstr ""
+
 #: start.rc:55
 msgid ""
 "Application could not be started, or no application associated with the "
diff --git a/po/sr_RS@latin.po b/po/sr_RS@latin.po
index 6cc5ddb..d9dfd45 100644
--- a/po/sr_RS@latin.po
+++ b/po/sr_RS@latin.po
@@ -11879,6 +11879,75 @@ msgstr ""
 msgid "Exports selected branch of the registry to a text file"
 msgstr ""
 
+#: regsvr32.rc:32
+msgid ""
+"Wine DLL Registration Server\n"
+"\n"
+"Provides DLL registration services.\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:40
+msgid ""
+"Usage:\n"
+"  regsvr32 [/u] [/s] [/n] [/i[:cmdline]] DllName\n"
+"\n"
+"Options:\n"
+"  [/u]  Unregister a module from the server.\n"
+"  [/s]  Silent mode (no messages will be displayed).\n"
+"  [/i]  Call DllInstall, passing an optional [cmdline].\n"
+"\tWhen used with [/u], regsvr32 also calls DLL Uninstall.\n"
+"  [/n]  Do not call DllRegisterServer. This option must be used with [/i].\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:41
+msgid ""
+"regsvr32: Invalid or unrecognized switch [%1]\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:42
+#, fuzzy
+msgid "regsvr32: Failed to load DLL '%1'\n"
+msgstr "Otvaranje „%s“ datoteke nije uspelo\n"
+
+#: regsvr32.rc:43
+msgid "regsvr32: %1 not implemented in DLL '%2'\n"
+msgstr ""
+
+#: regsvr32.rc:44
+msgid "regsvr32: Failed to register DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:45
+msgid "regsvr32: Successfully registered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:46
+msgid "regsvr32: Failed to unregister DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:47
+msgid "regsvr32: Successfully unregistered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:48
+msgid "regsvr32: Failed to install DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:49
+msgid "regsvr32: Successfully installed DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:50
+msgid "regsvr32: Failed to uninstall DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:51
+msgid "regsvr32: Successfully uninstalled DLL '%1'\n"
+msgstr ""
+
 #: start.rc:55
 msgid ""
 "Application could not be started, or no application associated with the "
diff --git a/po/sv.po b/po/sv.po
index de39b26..9cdb818 100644
--- a/po/sv.po
+++ b/po/sv.po
@@ -11562,6 +11562,76 @@ msgstr "Lägger till ett nytt flersträngsvärde"
 msgid "Exports selected branch of the registry to a text file"
 msgstr "Exporterar vald gren av registret till en textfil"
 
+#: regsvr32.rc:32
+msgid ""
+"Wine DLL Registration Server\n"
+"\n"
+"Provides DLL registration services.\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:40
+msgid ""
+"Usage:\n"
+"  regsvr32 [/u] [/s] [/n] [/i[:cmdline]] DllName\n"
+"\n"
+"Options:\n"
+"  [/u]  Unregister a module from the server.\n"
+"  [/s]  Silent mode (no messages will be displayed).\n"
+"  [/i]  Call DllInstall, passing an optional [cmdline].\n"
+"\tWhen used with [/u], regsvr32 also calls DLL Uninstall.\n"
+"  [/n]  Do not call DllRegisterServer. This option must be used with [/i].\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:41
+msgid ""
+"regsvr32: Invalid or unrecognized switch [%1]\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:42
+#, fuzzy
+#| msgid "Failed to open '%1'\n"
+msgid "regsvr32: Failed to load DLL '%1'\n"
+msgstr "Misslyckades med att öppna '%1'\n"
+
+#: regsvr32.rc:43
+msgid "regsvr32: %1 not implemented in DLL '%2'\n"
+msgstr ""
+
+#: regsvr32.rc:44
+msgid "regsvr32: Failed to register DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:45
+msgid "regsvr32: Successfully registered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:46
+msgid "regsvr32: Failed to unregister DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:47
+msgid "regsvr32: Successfully unregistered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:48
+msgid "regsvr32: Failed to install DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:49
+msgid "regsvr32: Successfully installed DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:50
+msgid "regsvr32: Failed to uninstall DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:51
+msgid "regsvr32: Successfully uninstalled DLL '%1'\n"
+msgstr ""
+
 #: start.rc:55
 msgid ""
 "Application could not be started, or no application associated with the "
diff --git a/po/te.po b/po/te.po
index 65e093e..b2572b4 100644
--- a/po/te.po
+++ b/po/te.po
@@ -11118,6 +11118,74 @@ msgstr ""
 msgid "Exports selected branch of the registry to a text file"
 msgstr ""
 
+#: regsvr32.rc:32
+msgid ""
+"Wine DLL Registration Server\n"
+"\n"
+"Provides DLL registration services.\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:40
+msgid ""
+"Usage:\n"
+"  regsvr32 [/u] [/s] [/n] [/i[:cmdline]] DllName\n"
+"\n"
+"Options:\n"
+"  [/u]  Unregister a module from the server.\n"
+"  [/s]  Silent mode (no messages will be displayed).\n"
+"  [/i]  Call DllInstall, passing an optional [cmdline].\n"
+"\tWhen used with [/u], regsvr32 also calls DLL Uninstall.\n"
+"  [/n]  Do not call DllRegisterServer. This option must be used with [/i].\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:41
+msgid ""
+"regsvr32: Invalid or unrecognized switch [%1]\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:42
+msgid "regsvr32: Failed to load DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:43
+msgid "regsvr32: %1 not implemented in DLL '%2'\n"
+msgstr ""
+
+#: regsvr32.rc:44
+msgid "regsvr32: Failed to register DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:45
+msgid "regsvr32: Successfully registered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:46
+msgid "regsvr32: Failed to unregister DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:47
+msgid "regsvr32: Successfully unregistered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:48
+msgid "regsvr32: Failed to install DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:49
+msgid "regsvr32: Successfully installed DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:50
+msgid "regsvr32: Failed to uninstall DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:51
+msgid "regsvr32: Successfully uninstalled DLL '%1'\n"
+msgstr ""
+
 #: start.rc:55
 msgid ""
 "Application could not be started, or no application associated with the "
diff --git a/po/th.po b/po/th.po
index 500a4ae..11d4b1e 100644
--- a/po/th.po
+++ b/po/th.po
@@ -11334,6 +11334,74 @@ msgstr ""
 msgid "Exports selected branch of the registry to a text file"
 msgstr ""
 
+#: regsvr32.rc:32
+msgid ""
+"Wine DLL Registration Server\n"
+"\n"
+"Provides DLL registration services.\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:40
+msgid ""
+"Usage:\n"
+"  regsvr32 [/u] [/s] [/n] [/i[:cmdline]] DllName\n"
+"\n"
+"Options:\n"
+"  [/u]  Unregister a module from the server.\n"
+"  [/s]  Silent mode (no messages will be displayed).\n"
+"  [/i]  Call DllInstall, passing an optional [cmdline].\n"
+"\tWhen used with [/u], regsvr32 also calls DLL Uninstall.\n"
+"  [/n]  Do not call DllRegisterServer. This option must be used with [/i].\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:41
+msgid ""
+"regsvr32: Invalid or unrecognized switch [%1]\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:42
+msgid "regsvr32: Failed to load DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:43
+msgid "regsvr32: %1 not implemented in DLL '%2'\n"
+msgstr ""
+
+#: regsvr32.rc:44
+msgid "regsvr32: Failed to register DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:45
+msgid "regsvr32: Successfully registered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:46
+msgid "regsvr32: Failed to unregister DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:47
+msgid "regsvr32: Successfully unregistered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:48
+msgid "regsvr32: Failed to install DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:49
+msgid "regsvr32: Successfully installed DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:50
+msgid "regsvr32: Failed to uninstall DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:51
+msgid "regsvr32: Successfully uninstalled DLL '%1'\n"
+msgstr ""
+
 #: start.rc:55
 msgid ""
 "Application could not be started, or no application associated with the "
diff --git a/po/tr.po b/po/tr.po
index 57b06b8..c6df978 100644
--- a/po/tr.po
+++ b/po/tr.po
@@ -11623,6 +11623,76 @@ msgstr "Yeni bir çoklu dize değeri ekler"
 msgid "Exports selected branch of the registry to a text file"
 msgstr "Sistem kaydının seçilen kısmını dosyasına aktarır"
 
+#: regsvr32.rc:32
+msgid ""
+"Wine DLL Registration Server\n"
+"\n"
+"Provides DLL registration services.\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:40
+msgid ""
+"Usage:\n"
+"  regsvr32 [/u] [/s] [/n] [/i[:cmdline]] DllName\n"
+"\n"
+"Options:\n"
+"  [/u]  Unregister a module from the server.\n"
+"  [/s]  Silent mode (no messages will be displayed).\n"
+"  [/i]  Call DllInstall, passing an optional [cmdline].\n"
+"\tWhen used with [/u], regsvr32 also calls DLL Uninstall.\n"
+"  [/n]  Do not call DllRegisterServer. This option must be used with [/i].\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:41
+msgid ""
+"regsvr32: Invalid or unrecognized switch [%1]\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:42
+#, fuzzy
+#| msgid "Failed to open '%1'\n"
+msgid "regsvr32: Failed to load DLL '%1'\n"
+msgstr "'%1' açılamadı\n"
+
+#: regsvr32.rc:43
+msgid "regsvr32: %1 not implemented in DLL '%2'\n"
+msgstr ""
+
+#: regsvr32.rc:44
+msgid "regsvr32: Failed to register DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:45
+msgid "regsvr32: Successfully registered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:46
+msgid "regsvr32: Failed to unregister DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:47
+msgid "regsvr32: Successfully unregistered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:48
+msgid "regsvr32: Failed to install DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:49
+msgid "regsvr32: Successfully installed DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:50
+msgid "regsvr32: Failed to uninstall DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:51
+msgid "regsvr32: Successfully uninstalled DLL '%1'\n"
+msgstr ""
+
 #: start.rc:55
 msgid ""
 "Application could not be started, or no application associated with the "
diff --git a/po/uk.po b/po/uk.po
index 0caec06..f7ed7d7 100644
--- a/po/uk.po
+++ b/po/uk.po
@@ -11701,6 +11701,76 @@ msgstr "Додає нове багаторядкове значення"
 msgid "Exports selected branch of the registry to a text file"
 msgstr "Експортує вибрану гілку реєстру до текстового файлу"
 
+#: regsvr32.rc:32
+msgid ""
+"Wine DLL Registration Server\n"
+"\n"
+"Provides DLL registration services.\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:40
+msgid ""
+"Usage:\n"
+"  regsvr32 [/u] [/s] [/n] [/i[:cmdline]] DllName\n"
+"\n"
+"Options:\n"
+"  [/u]  Unregister a module from the server.\n"
+"  [/s]  Silent mode (no messages will be displayed).\n"
+"  [/i]  Call DllInstall, passing an optional [cmdline].\n"
+"\tWhen used with [/u], regsvr32 also calls DLL Uninstall.\n"
+"  [/n]  Do not call DllRegisterServer. This option must be used with [/i].\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:41
+msgid ""
+"regsvr32: Invalid or unrecognized switch [%1]\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:42
+#, fuzzy
+#| msgid "Failed to open '%1'\n"
+msgid "regsvr32: Failed to load DLL '%1'\n"
+msgstr "Не вдалось відкрити '%1'\n"
+
+#: regsvr32.rc:43
+msgid "regsvr32: %1 not implemented in DLL '%2'\n"
+msgstr ""
+
+#: regsvr32.rc:44
+msgid "regsvr32: Failed to register DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:45
+msgid "regsvr32: Successfully registered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:46
+msgid "regsvr32: Failed to unregister DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:47
+msgid "regsvr32: Successfully unregistered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:48
+msgid "regsvr32: Failed to install DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:49
+msgid "regsvr32: Successfully installed DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:50
+msgid "regsvr32: Failed to uninstall DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:51
+msgid "regsvr32: Successfully uninstalled DLL '%1'\n"
+msgstr ""
+
 #: start.rc:55
 msgid ""
 "Application could not be started, or no application associated with the "
diff --git a/po/wa.po b/po/wa.po
index 52ad0c9..24c3209 100644
--- a/po/wa.po
+++ b/po/wa.po
@@ -11248,6 +11248,74 @@ msgstr ""
 msgid "Exports selected branch of the registry to a text file"
 msgstr ""
 
+#: regsvr32.rc:32
+msgid ""
+"Wine DLL Registration Server\n"
+"\n"
+"Provides DLL registration services.\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:40
+msgid ""
+"Usage:\n"
+"  regsvr32 [/u] [/s] [/n] [/i[:cmdline]] DllName\n"
+"\n"
+"Options:\n"
+"  [/u]  Unregister a module from the server.\n"
+"  [/s]  Silent mode (no messages will be displayed).\n"
+"  [/i]  Call DllInstall, passing an optional [cmdline].\n"
+"\tWhen used with [/u], regsvr32 also calls DLL Uninstall.\n"
+"  [/n]  Do not call DllRegisterServer. This option must be used with [/i].\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:41
+msgid ""
+"regsvr32: Invalid or unrecognized switch [%1]\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:42
+msgid "regsvr32: Failed to load DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:43
+msgid "regsvr32: %1 not implemented in DLL '%2'\n"
+msgstr ""
+
+#: regsvr32.rc:44
+msgid "regsvr32: Failed to register DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:45
+msgid "regsvr32: Successfully registered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:46
+msgid "regsvr32: Failed to unregister DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:47
+msgid "regsvr32: Successfully unregistered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:48
+msgid "regsvr32: Failed to install DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:49
+msgid "regsvr32: Successfully installed DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:50
+msgid "regsvr32: Failed to uninstall DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:51
+msgid "regsvr32: Successfully uninstalled DLL '%1'\n"
+msgstr ""
+
 #: start.rc:55
 msgid ""
 "Application could not be started, or no application associated with the "
diff --git a/po/wine.pot b/po/wine.pot
index 5f30045..d639a7d 100644
--- a/po/wine.pot
+++ b/po/wine.pot
@@ -11057,6 +11057,74 @@ msgstr ""
 msgid "Exports selected branch of the registry to a text file"
 msgstr ""
 
+#: regsvr32.rc:32
+msgid ""
+"Wine DLL Registration Server\n"
+"\n"
+"Provides DLL registration services.\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:40
+msgid ""
+"Usage:\n"
+"  regsvr32 [/u] [/s] [/n] [/i[:cmdline]] DllName\n"
+"\n"
+"Options:\n"
+"  [/u]  Unregister a module from the server.\n"
+"  [/s]  Silent mode (no messages will be displayed).\n"
+"  [/i]  Call DllInstall, passing an optional [cmdline].\n"
+"\tWhen used with [/u], regsvr32 also calls DLL Uninstall.\n"
+"  [/n]  Do not call DllRegisterServer. This option must be used with [/i].\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:41
+msgid ""
+"regsvr32: Invalid or unrecognized switch [%1]\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:42
+msgid "regsvr32: Failed to load DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:43
+msgid "regsvr32: %1 not implemented in DLL '%2'\n"
+msgstr ""
+
+#: regsvr32.rc:44
+msgid "regsvr32: Failed to register DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:45
+msgid "regsvr32: Successfully registered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:46
+msgid "regsvr32: Failed to unregister DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:47
+msgid "regsvr32: Successfully unregistered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:48
+msgid "regsvr32: Failed to install DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:49
+msgid "regsvr32: Successfully installed DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:50
+msgid "regsvr32: Failed to uninstall DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:51
+msgid "regsvr32: Successfully uninstalled DLL '%1'\n"
+msgstr ""
+
 #: start.rc:55
 msgid ""
 "Application could not be started, or no application associated with the "
diff --git a/po/zh_CN.po b/po/zh_CN.po
index 7f645a2..9c719a2 100644
--- a/po/zh_CN.po
+++ b/po/zh_CN.po
@@ -11169,6 +11169,74 @@ msgstr "添加新多字符串值"
 msgid "Exports selected branch of the registry to a text file"
 msgstr "把选定的注册表分支导出为文本文件"
 
+#: regsvr32.rc:32
+msgid ""
+"Wine DLL Registration Server\n"
+"\n"
+"Provides DLL registration services.\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:40
+msgid ""
+"Usage:\n"
+"  regsvr32 [/u] [/s] [/n] [/i[:cmdline]] DllName\n"
+"\n"
+"Options:\n"
+"  [/u]  Unregister a module from the server.\n"
+"  [/s]  Silent mode (no messages will be displayed).\n"
+"  [/i]  Call DllInstall, passing an optional [cmdline].\n"
+"\tWhen used with [/u], regsvr32 also calls DLL Uninstall.\n"
+"  [/n]  Do not call DllRegisterServer. This option must be used with [/i].\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:41
+msgid ""
+"regsvr32: Invalid or unrecognized switch [%1]\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:42
+msgid "regsvr32: Failed to load DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:43
+msgid "regsvr32: %1 not implemented in DLL '%2'\n"
+msgstr ""
+
+#: regsvr32.rc:44
+msgid "regsvr32: Failed to register DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:45
+msgid "regsvr32: Successfully registered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:46
+msgid "regsvr32: Failed to unregister DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:47
+msgid "regsvr32: Successfully unregistered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:48
+msgid "regsvr32: Failed to install DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:49
+msgid "regsvr32: Successfully installed DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:50
+msgid "regsvr32: Failed to uninstall DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:51
+msgid "regsvr32: Successfully uninstalled DLL '%1'\n"
+msgstr ""
+
 #: start.rc:55
 msgid ""
 "Application could not be started, or no application associated with the "
diff --git a/po/zh_TW.po b/po/zh_TW.po
index 112e20c..027de79 100644
--- a/po/zh_TW.po
+++ b/po/zh_TW.po
@@ -11537,6 +11537,76 @@ msgstr "新增一個多字串值"
 msgid "Exports selected branch of the registry to a text file"
 msgstr "匯出註冊表的所選分支到文字檔"
 
+#: regsvr32.rc:32
+msgid ""
+"Wine DLL Registration Server\n"
+"\n"
+"Provides DLL registration services.\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:40
+msgid ""
+"Usage:\n"
+"  regsvr32 [/u] [/s] [/n] [/i[:cmdline]] DllName\n"
+"\n"
+"Options:\n"
+"  [/u]  Unregister a module from the server.\n"
+"  [/s]  Silent mode (no messages will be displayed).\n"
+"  [/i]  Call DllInstall, passing an optional [cmdline].\n"
+"\tWhen used with [/u], regsvr32 also calls DLL Uninstall.\n"
+"  [/n]  Do not call DllRegisterServer. This option must be used with [/i].\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:41
+msgid ""
+"regsvr32: Invalid or unrecognized switch [%1]\n"
+"\n"
+msgstr ""
+
+#: regsvr32.rc:42
+#, fuzzy
+#| msgid "Failed to open '%1'\n"
+msgid "regsvr32: Failed to load DLL '%1'\n"
+msgstr "開啟 %1 失敗\n"
+
+#: regsvr32.rc:43
+msgid "regsvr32: %1 not implemented in DLL '%2'\n"
+msgstr ""
+
+#: regsvr32.rc:44
+msgid "regsvr32: Failed to register DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:45
+msgid "regsvr32: Successfully registered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:46
+msgid "regsvr32: Failed to unregister DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:47
+msgid "regsvr32: Successfully unregistered DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:48
+msgid "regsvr32: Failed to install DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:49
+msgid "regsvr32: Successfully installed DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:50
+msgid "regsvr32: Failed to uninstall DLL '%1'\n"
+msgstr ""
+
+#: regsvr32.rc:51
+msgid "regsvr32: Successfully uninstalled DLL '%1'\n"
+msgstr ""
+
 #: start.rc:55
 msgid ""
 "Application could not be started, or no application associated with the "
diff --git a/programs/oleview/details.c b/programs/oleview/details.c
index f7bb523..9fdd9f3 100644
--- a/programs/oleview/details.c
+++ b/programs/oleview/details.c
@@ -158,7 +158,7 @@ static void CreateRegRec(HKEY hKey, HTREEITEM parent, WCHAR *wszKeyName, BOOL ad
 
             RegCloseKey(hCurKey);
 
-            memmove(&wszData[6], wszData, sizeof(WCHAR[lenData]));
+            memmove(&wszData[6], wszData, lenData * sizeof(WCHAR));
             memcpy(wszData, wszCLSID, sizeof(WCHAR[6]));
             wszData[5] = '\\';
 
@@ -187,7 +187,7 @@ static void CreateRegRec(HKEY hKey, HTREEITEM parent, WCHAR *wszKeyName, BOOL ad
 
             RegCloseKey(hCurKey);
 
-            memmove(&wszData[8], wszData, sizeof(WCHAR[lenData]));
+            memmove(&wszData[8], wszData, lenData * sizeof(WCHAR));
             memcpy(wszData, wszTypeLib, sizeof(WCHAR[8]));
             wszData[7] = '\\';
             RegOpenKeyW(HKEY_CLASSES_ROOT, wszData, &hCurKey);
@@ -238,9 +238,9 @@ static void CreateReg(WCHAR *buffer)
             if(RegQueryValueW(hKey, NULL, wszTree, (LONG *)&lenTree) == ERROR_SUCCESS)
             {
                 memmove(&wszTree[lenBuffer-lastLenBuffer+3], wszTree,
-                        sizeof(WCHAR[lenTree]));
+                        lenTree * sizeof(WCHAR));
                 memcpy(wszTree, &buffer[lastLenBuffer],
-                        sizeof(WCHAR[lenBuffer-lastLenBuffer]));
+                        (lenBuffer - lastLenBuffer) * sizeof(WCHAR));
 
                 if(lenTree == 1) wszTree[lenBuffer-lastLenBuffer] = '\0';
                 else
diff --git a/programs/oleview/tree.c b/programs/oleview/tree.c
index 241c32c..34021e7 100644
--- a/programs/oleview/tree.c
+++ b/programs/oleview/tree.c
@@ -225,7 +225,7 @@ BOOL CreateRegPath(HTREEITEM item, WCHAR *buffer, int bufSize)
     int bufLen;
     BOOL ret;
 
-    memset(buffer, 0, sizeof(WCHAR[bufSize]));
+    memset(buffer, 0, bufSize * sizeof(WCHAR));
     memset(&tvi, 0, sizeof(TVITEMW));
     tvi.hItem = item;
 
@@ -239,8 +239,8 @@ BOOL CreateRegPath(HTREEITEM item, WCHAR *buffer, int bufSize)
         if(tvi.lParam && (((ITEM_INFO *)tvi.lParam)->cFlag & (REGPATH|REGTOP)))
         {
             bufLen = lstrlenW(((ITEM_INFO *)tvi.lParam)->info);
-            memmove(&buffer[bufLen], buffer, sizeof(WCHAR[bufSize-bufLen]));
-            memcpy(buffer, ((ITEM_INFO *)tvi.lParam)->info, sizeof(WCHAR[bufLen]));
+            memmove(&buffer[bufLen], buffer, (bufSize - bufLen) * sizeof(WCHAR));
+            memcpy(buffer, ((ITEM_INFO *)tvi.lParam)->info, bufLen * sizeof(WCHAR));
         }
 
         if(tvi.lParam && ((ITEM_INFO *)tvi.lParam)->cFlag & REGTOP) break;
diff --git a/programs/regsvr32/Makefile.in b/programs/regsvr32/Makefile.in
index b2c4e1b..db567ea 100644
--- a/programs/regsvr32/Makefile.in
+++ b/programs/regsvr32/Makefile.in
@@ -1,6 +1,6 @@
 MODULE    = regsvr32.exe
 APPMODE   = -mconsole
-IMPORTS   = ole32
+IMPORTS   = ole32 user32
 
 C_SRCS = \
 	regsvr32.c
diff --git a/programs/regsvr32/regsvr32.c b/programs/regsvr32/regsvr32.c
index 3536e93..624acd6 100644
--- a/programs/regsvr32/regsvr32.c
+++ b/programs/regsvr32/regsvr32.c
@@ -51,10 +51,13 @@
 #include "config.h"
 #include "wine/port.h"
 
-#include <stdio.h>
 #include <string.h>
 #include <windows.h>
 #include <ole2.h>
+#include "regsvr32.h"
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(regsvr32);
 
 typedef HRESULT (*DLLREGISTER)          (void);
 typedef HRESULT (*DLLUNREGISTER)        (void);
@@ -62,16 +65,38 @@ typedef HRESULT (*DLLINSTALL)           (BOOL,LPCWSTR);
 
 static BOOL Silent = FALSE;
 
-static int Usage(void)
+static void __cdecl output_write(UINT id, ...)
 {
-    printf("regsvr32 [/u] [/s] [/n] [/i[:cmdline]] dllname ...\n");
-    printf("\t[/u]  unregister server\n");
-    printf("\t[/s]  silent (no message boxes)\n");
-    printf("\t[/i]  Call DllInstall passing it an optional [cmdline];\n");
-    printf("\t      when used with /u calls dll uninstall\n");
-    printf("\t[/n]  Do not call DllRegisterServer; this option "
-           "must be used with [/i]\n");
-    return 0;
+    char fmt[1024];
+    __ms_va_list va_args;
+    char *str;
+    DWORD len, nOut, ret;
+
+    if (Silent) return;
+
+    if (!LoadStringA(GetModuleHandleA(NULL), id, fmt, sizeof(fmt)/sizeof(fmt[0])))
+    {
+        WINE_FIXME("LoadString failed with %d\n", GetLastError());
+        return;
+    }
+
+    __ms_va_start(va_args, id);
+    SetLastError(NO_ERROR);
+    len = FormatMessageA(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ALLOCATE_BUFFER,
+                         fmt, 0, 0, (LPSTR)&str, 0, &va_args);
+    __ms_va_end(va_args);
+    if (len == 0 && GetLastError() != NO_ERROR)
+    {
+        WINE_FIXME("Could not format string: le=%u, fmt=%s\n", GetLastError(), wine_dbgstr_a(fmt));
+        return;
+    }
+
+    ret = WriteConsoleA(GetStdHandle(STD_OUTPUT_HANDLE), str, len, &nOut, NULL);
+
+    if (!ret)
+        WINE_WARN("regsvr32: WriteConsoleA() failed.\n");
+
+    LocalFree(str);
 }
 
 /**
@@ -89,16 +114,13 @@ static VOID *LoadProc(const char* strDll, const char* procName, HMODULE* DllHand
     *DllHandle = LoadLibraryExA(strDll, 0, LOAD_WITH_ALTERED_SEARCH_PATH);
     if(!*DllHandle)
     {
-        if(!Silent)
-            printf("Failed to load DLL %s\n", strDll);
-
+        output_write(STRING_DLL_LOAD_FAILED, strDll);
         ExitProcess(1);
     }
     proc = (VOID *) GetProcAddress(*DllHandle, procName);
     if(!proc)
     {
-        if(!Silent)
-            printf("%s not implemented in DLL %s\n", procName, strDll);
+        output_write(STRING_PROC_NOT_IMPLEMENTED, procName, strDll);
         FreeLibrary(*DllHandle);
         return NULL;
     }
@@ -118,13 +140,10 @@ static int RegisterDll(const char* strDll)
     hr = pfRegister();
     if(FAILED(hr))
     {
-        if(!Silent)
-            printf("Failed to register DLL %s\n", strDll);
-
+        output_write(STRING_REGISTER_FAILED, strDll);
         return -1;
     }
-    if(!Silent)
-        printf("Successfully registered DLL %s\n", strDll);
+    output_write(STRING_REGISTER_SUCCESSFUL, strDll);
 
     if(DllHandle)
         FreeLibrary(DllHandle);
@@ -144,13 +163,10 @@ static int UnregisterDll(char* strDll)
     hr = pfUnregister();
     if(FAILED(hr))
     {
-        if(!Silent)
-            printf("Failed to unregister DLL %s\n", strDll);
-
+        output_write(STRING_UNREGISTER_FAILED, strDll);
         return -1;
     }
-    if(!Silent)
-        printf("Successfully unregistered DLL %s\n", strDll);
+    output_write(STRING_UNREGISTER_SUCCESSFUL, strDll);
 
     if(DllHandle)
         FreeLibrary(DllHandle);
@@ -170,14 +186,16 @@ static int InstallDll(BOOL install, char *strDll, WCHAR *command_line)
     hr = pfInstall(install, command_line);
     if(FAILED(hr))
     {
-        if(!Silent)
-            printf("Failed to %s DLL %s\n", install ? "install" : "uninstall",
-                   strDll);
+        if (install)
+            output_write(STRING_INSTALL_FAILED, strDll);
+        else
+            output_write(STRING_UNINSTALL_FAILED, strDll);
         return -1;
     }
-    if(!Silent)
-        printf("Successfully %s DLL %s\n",  install ? "installed" : "uninstalled",
-               strDll);
+    if (install)
+        output_write(STRING_INSTALL_SUCCESSFUL, strDll);
+    else
+        output_write(STRING_UNINSTALL_SUCCESSFUL, strDll);
 
     if(DllHandle)
         FreeLibrary(DllHandle);
@@ -197,7 +215,7 @@ int main(int argc, char* argv[])
     OleInitialize(NULL);
 
     /* Strictly, the Microsoft version processes all the flags before
-     * the files (e.g. regsvr32 file1 /s file2 is silent even for file1.
+     * the files (e.g. regsvr32 file1 /s file2 is silent even for file1).
      * For ease, we will not replicate that and will process the arguments
      * in order.
      */
@@ -254,7 +272,11 @@ int main(int argc, char* argv[])
         else if((!strcasecmp(argv[i], "/c"))||(!strcasecmp(argv[i], "-c")))
             /* console output */;
         else if (argv[i][0] == '/' && (!argv[i][2] || argv[i][2] == ':'))
-            printf("Unrecognized switch %s\n", argv[i]);
+        {
+            output_write(STRING_UNRECOGNIZED_SWITCH, argv[i]);
+            output_write(STRING_USAGE);
+            return 1;
+        }
         else
         {
             char *DllName = argv[i];
@@ -285,10 +307,9 @@ int main(int argc, char* argv[])
 
     if (!DllFound)
     {
-        if(!Silent)
-            return Usage();
-        else
-            return -1;
+        output_write(STRING_HEADER);
+        output_write(STRING_USAGE);
+        return 1;
     }
 
     OleUninitialize();
diff --git a/programs/regsvr32/regsvr32.h b/programs/regsvr32/regsvr32.h
new file mode 100644
index 0000000..e3b50eb
--- /dev/null
+++ b/programs/regsvr32/regsvr32.h
@@ -0,0 +1,34 @@
+/*
+ * Regsvr32 definitions
+ *
+ * Copyright 2014 Hugh McMaster
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+/* Resource strings */
+#define STRING_HEADER                      1000
+#define STRING_USAGE                       1001
+#define STRING_UNRECOGNIZED_SWITCH         1002
+#define STRING_DLL_LOAD_FAILED             1003
+#define STRING_PROC_NOT_IMPLEMENTED        1004
+#define STRING_REGISTER_FAILED             1005
+#define STRING_REGISTER_SUCCESSFUL         1006
+#define STRING_UNREGISTER_FAILED           1007
+#define STRING_UNREGISTER_SUCCESSFUL       1008
+#define STRING_INSTALL_FAILED              1009
+#define STRING_INSTALL_SUCCESSFUL          1010
+#define STRING_UNINSTALL_FAILED            1011
+#define STRING_UNINSTALL_SUCCESSFUL        1012
diff --git a/programs/regsvr32/regsvr32.rc b/programs/regsvr32/regsvr32.rc
index c1ebe47..ba6d799 100644
--- a/programs/regsvr32/regsvr32.rc
+++ b/programs/regsvr32/regsvr32.rc
@@ -1,6 +1,7 @@
-/* Language neutral resources.
+/* Regsvr32 resource strings
  *
  * Copyright 2003 Stefan Leichter
+ * Copyright 2014 Hugh McMaster
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -17,6 +18,38 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#include <windef.h>
+#include "regsvr32.h"
+
+#pragma makedep po
+
+LANGUAGE LANG_ENGLISH, SUBLANG_DEFAULT
+
+STRINGTABLE
+{
+    STRING_HEADER, "Wine DLL Registration Server\n\n\
+Provides DLL registration services.\n\n"
+    STRING_USAGE, "Usage:\n\
+\  regsvr32 [/u] [/s] [/n] [/i[:cmdline]] DllName\n\n\
+Options:\n\
+\  [/u]  Unregister a module from the server.\n\
+\  [/s]  Silent mode (no messages will be displayed).\n\
+\  [/i]  Call DllInstall, passing an optional [cmdline].\n\
+\tWhen used with [/u], regsvr32 also calls DLL Uninstall.\n\
+\  [/n]  Do not call DllRegisterServer. This option must be used with [/i].\n\n"
+    STRING_UNRECOGNIZED_SWITCH, "regsvr32: Invalid or unrecognized switch [%1]\n\n"
+    STRING_DLL_LOAD_FAILED, "regsvr32: Failed to load DLL '%1'\n"
+    STRING_PROC_NOT_IMPLEMENTED, "regsvr32: %1 not implemented in DLL '%2'\n"
+    STRING_REGISTER_FAILED, "regsvr32: Failed to register DLL '%1'\n"
+    STRING_REGISTER_SUCCESSFUL, "regsvr32: Successfully registered DLL '%1'\n"
+    STRING_UNREGISTER_FAILED, "regsvr32: Failed to unregister DLL '%1'\n"
+    STRING_UNREGISTER_SUCCESSFUL, "regsvr32: Successfully unregistered DLL '%1'\n"
+    STRING_INSTALL_FAILED, "regsvr32: Failed to install DLL '%1'\n"
+    STRING_INSTALL_SUCCESSFUL, "regsvr32: Successfully installed DLL '%1'\n"
+    STRING_UNINSTALL_FAILED, "regsvr32: Failed to uninstall DLL '%1'\n"
+    STRING_UNINSTALL_SUCCESSFUL, "regsvr32: Successfully uninstalled DLL '%1'\n"
+}
+
 #define WINE_FILEDESCRIPTION_STR "Wine Register Server"
 #define WINE_FILENAME_STR "REGSVR32"
 #define WINE_FILETYPE VFT_APP
diff --git a/server/queue.c b/server/queue.c
index a410691..d919f01 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -2869,9 +2869,9 @@ DECL_HANDLER(set_foreground_window)
     reply->send_msg_old = (reply->previous && desktop->foreground_input != queue->input);
     reply->send_msg_new = FALSE;
 
-    if (is_top_level_window( req->handle ) &&
-        ((thread = get_window_thread( req->handle ))) &&
-        (thread->queue->input->desktop == desktop))
+    if (is_valid_foreground_window( req->handle ) &&
+        (thread = get_window_thread( req->handle )) &&
+        thread->queue->input->desktop == desktop)
     {
         set_foreground_input( desktop, thread->queue->input );
         reply->send_msg_new = (desktop->foreground_input != queue->input);
diff --git a/server/user.h b/server/user.h
index 2947de7..8535903 100644
--- a/server/user.h
+++ b/server/user.h
@@ -152,7 +152,7 @@ extern void post_desktop_message( struct desktop *desktop, unsigned int message,
 extern void destroy_window( struct window *win );
 extern void destroy_thread_windows( struct thread *thread );
 extern int is_child_window( user_handle_t parent, user_handle_t child );
-extern int is_top_level_window( user_handle_t window );
+extern int is_valid_foreground_window( user_handle_t window );
 extern int is_window_visible( user_handle_t window );
 extern int is_window_transparent( user_handle_t window );
 extern int make_window_active( user_handle_t window );
diff --git a/server/window.c b/server/window.c
index 1696fce..484cd22 100644
--- a/server/window.c
+++ b/server/window.c
@@ -581,11 +581,11 @@ int is_child_window( user_handle_t parent, user_handle_t child )
     return 0;
 }
 
-/* check whether window is a top-level window */
-int is_top_level_window( user_handle_t window )
+/* check if window can be set as foreground window */
+int is_valid_foreground_window( user_handle_t window )
 {
     struct window *win = get_user_object( window, USER_WINDOW );
-    return (win && (is_desktop_window(win) || is_desktop_window(win->parent)));
+    return win && (win->style & (WS_POPUP|WS_CHILD)) != WS_CHILD;
 }
 
 /* make a window active if possible */
