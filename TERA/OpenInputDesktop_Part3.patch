--- a/server/winstation.c
+++ b/server/winstation.c
@@ -121,6 +121,7 @@
             winstation->flags = flags;
             winstation->clipboard = NULL;
             winstation->atom_table = NULL;
+           winstation->active_desktop = NULL;
             list_add_tail( &winstation_list, &winstation->entry );
             list_init( &winstation->desktops );
         }
@@ -503,6 +504,8 @@
         if ((desktop = create_desktop( &name, req->attributes, req->flags, winstation )))
         {
             reply->handle = alloc_handle( current->process, desktop, req->access, req->attributes );
+           if (!(winstation->active_desktop))
+               winstation->active_desktop = desktop;   /* This is the first desktop of the winstation */
             release_object( desktop );
         }
         release_object( winstation );
@@ -538,17 +541,82 @@
     }
 }
 
+/* open a handle to input desktop */
+DECL_HANDLER(open_input_desktop)
+{
+    struct winstation *winstation = NULL;
+    struct desktop *desktop;
+    struct object *obj;
+
+    winstation = get_process_winstation( current->process, 0 );
+    if (winstation)
+    {
+       desktop = winstation->active_desktop;
+       if (!desktop) return;
+       obj = &(desktop->obj);
+       if (&desktop_ops && obj->ops != &desktop_ops)
+           set_error( STATUS_OBJECT_TYPE_MISMATCH );
+       else
+           reply->handle = alloc_handle( current->process, obj, req->access, req->attributes );
+       release_object( obj );
+       release_object( winstation );
+    }
+}
 
 /* close a desktop */
 DECL_HANDLER(close_desktop)
 {
-    struct desktop *desktop;
+    struct desktop *desktop, *prev_desktop = NULL, *next_desktop = NULL, *current_desktop = NULL;
+    struct winstation *winstation = NULL;
+    int j = 0;
+
+    if (!(winstation = get_process_winstation( current->process, 0 ))) return;
 
     /* make sure it is a desktop handle */
     if ((desktop = (struct desktop *)get_handle_obj( current->process, req->handle,
                                                      0, &desktop_ops )))
     {
-        if (close_handle( current->process, req->handle )) set_error( STATUS_DEVICE_BUSY );
+       if (desktop == winstation->active_desktop)
+       {
+           LIST_FOR_EACH_ENTRY( next_desktop, &winstation->desktops, struct desktop, entry )
+           {
+               if (!current_desktop) current_desktop = next_desktop;
+               if (current_desktop == desktop)
+               {
+                   if (prev_desktop)
+                   {
+                       winstation->active_desktop = prev_desktop;
+                       break;
+                   }
+                   /* If we are closing first desktop then we need to assign next desktop as active if it exists */
+                   else
+                   {
+                       if (j)
+                       {
+                           if (next_desktop)
+                           {
+                               winstation->active_desktop = next_desktop;
+                               break;
+                           }
+                           else break;
+                       }
+                       else
+                       {
+                           j++;
+                           continue;
+                       }
+                   }
+               }
+               current_desktop = next_desktop;
+               prev_desktop = next_desktop;
+           }
+       }
+
+       if (!close_handle( current->process, req->handle ))
+       {
+           set_error( STATUS_DEVICE_BUSY );
+           winstation->active_desktop = desktop;
+       }
         release_object( desktop );
     }
 }
